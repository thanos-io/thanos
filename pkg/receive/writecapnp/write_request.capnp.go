// Copyright (c) The Thanos Authors.
// Licensed under the Apache License 2.0.

// Code generated by capnpc-go. DO NOT EDIT.

package writecapnp

import (
	context "context"
	math "math"
	strconv "strconv"

	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	fc "capnproto.org/go/capnp/v3/flowcontrol"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
)

type Symbols capnp.Struct

// Symbols_TypeID is the unique identifier for the type Symbols.
const Symbols_TypeID = 0xab79e1a6ecfeb87a

func NewSymbols(s *capnp.Segment) (Symbols, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Symbols(st), err
}

func NewRootSymbols(s *capnp.Segment) (Symbols, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Symbols(st), err
}

func ReadRootSymbols(msg *capnp.Message) (Symbols, error) {
	root, err := msg.Root()
	return Symbols(root.Struct()), err
}

func (s Symbols) String() string {
	str, _ := text.Marshal(0xab79e1a6ecfeb87a, capnp.Struct(s))
	return str
}

func (s Symbols) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Symbols) DecodeFromPtr(p capnp.Ptr) Symbols {
	return Symbols(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Symbols) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Symbols) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Symbols) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Symbols) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Symbols) Data() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Symbols) HasData() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Symbols) SetData(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

func (s Symbols) Offsets() (capnp.UInt32List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.UInt32List(p.List()), err
}

func (s Symbols) HasOffsets() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Symbols) SetOffsets(v capnp.UInt32List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewOffsets sets the offsets field to a newly
// allocated capnp.UInt32List, preferring placement in s's segment.
func (s Symbols) NewOffsets(n int32) (capnp.UInt32List, error) {
	l, err := capnp.NewUInt32List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.UInt32List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}

// Symbols_List is a list of Symbols.
type Symbols_List = capnp.StructList[Symbols]

// NewSymbols creates a new list of Symbols.
func NewSymbols_List(s *capnp.Segment, sz int32) (Symbols_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Symbols](l), err
}

// Symbols_Future is a wrapper for a Symbols promised by a client call.
type Symbols_Future struct{ *capnp.Future }

func (f Symbols_Future) Struct() (Symbols, error) {
	p, err := f.Future.Ptr()
	return Symbols(p.Struct()), err
}

type Label capnp.Struct

// Label_TypeID is the unique identifier for the type Label.
const Label_TypeID = 0xf192c7ee07114b32

func NewLabel(s *capnp.Segment) (Label, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Label(st), err
}

func NewRootLabel(s *capnp.Segment) (Label, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Label(st), err
}

func ReadRootLabel(msg *capnp.Message) (Label, error) {
	root, err := msg.Root()
	return Label(root.Struct()), err
}

func (s Label) String() string {
	str, _ := text.Marshal(0xf192c7ee07114b32, capnp.Struct(s))
	return str
}

func (s Label) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Label) DecodeFromPtr(p capnp.Ptr) Label {
	return Label(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Label) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Label) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Label) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Label) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Label) Name() uint32 {
	return capnp.Struct(s).Uint32(0)
}

func (s Label) SetName(v uint32) {
	capnp.Struct(s).SetUint32(0, v)
}

func (s Label) Value() uint32 {
	return capnp.Struct(s).Uint32(4)
}

func (s Label) SetValue(v uint32) {
	capnp.Struct(s).SetUint32(4, v)
}

// Label_List is a list of Label.
type Label_List = capnp.StructList[Label]

// NewLabel creates a new list of Label.
func NewLabel_List(s *capnp.Segment, sz int32) (Label_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[Label](l), err
}

// Label_Future is a wrapper for a Label promised by a client call.
type Label_Future struct{ *capnp.Future }

func (f Label_Future) Struct() (Label, error) {
	p, err := f.Future.Ptr()
	return Label(p.Struct()), err
}

type Sample capnp.Struct

// Sample_TypeID is the unique identifier for the type Sample.
const Sample_TypeID = 0xef49df6cfa8875de

func NewSample(s *capnp.Segment) (Sample, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Sample(st), err
}

func NewRootSample(s *capnp.Segment) (Sample, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Sample(st), err
}

func ReadRootSample(msg *capnp.Message) (Sample, error) {
	root, err := msg.Root()
	return Sample(root.Struct()), err
}

func (s Sample) String() string {
	str, _ := text.Marshal(0xef49df6cfa8875de, capnp.Struct(s))
	return str
}

func (s Sample) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Sample) DecodeFromPtr(p capnp.Ptr) Sample {
	return Sample(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Sample) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Sample) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Sample) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Sample) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Sample) Timestamp() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s Sample) SetTimestamp(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s Sample) Value() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Sample) SetValue(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

// Sample_List is a list of Sample.
type Sample_List = capnp.StructList[Sample]

// NewSample creates a new list of Sample.
func NewSample_List(s *capnp.Segment, sz int32) (Sample_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[Sample](l), err
}

// Sample_Future is a wrapper for a Sample promised by a client call.
type Sample_Future struct{ *capnp.Future }

func (f Sample_Future) Struct() (Sample, error) {
	p, err := f.Future.Ptr()
	return Sample(p.Struct()), err
}

type BucketSpan capnp.Struct

// BucketSpan_TypeID is the unique identifier for the type BucketSpan.
const BucketSpan_TypeID = 0x983649d193295eae

func NewBucketSpan(s *capnp.Segment) (BucketSpan, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return BucketSpan(st), err
}

func NewRootBucketSpan(s *capnp.Segment) (BucketSpan, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return BucketSpan(st), err
}

func ReadRootBucketSpan(msg *capnp.Message) (BucketSpan, error) {
	root, err := msg.Root()
	return BucketSpan(root.Struct()), err
}

func (s BucketSpan) String() string {
	str, _ := text.Marshal(0x983649d193295eae, capnp.Struct(s))
	return str
}

func (s BucketSpan) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (BucketSpan) DecodeFromPtr(p capnp.Ptr) BucketSpan {
	return BucketSpan(capnp.Struct{}.DecodeFromPtr(p))
}

func (s BucketSpan) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s BucketSpan) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s BucketSpan) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s BucketSpan) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s BucketSpan) Offset() int32 {
	return int32(capnp.Struct(s).Uint32(0))
}

func (s BucketSpan) SetOffset(v int32) {
	capnp.Struct(s).SetUint32(0, uint32(v))
}

func (s BucketSpan) Length() uint32 {
	return capnp.Struct(s).Uint32(4)
}

func (s BucketSpan) SetLength(v uint32) {
	capnp.Struct(s).SetUint32(4, v)
}

// BucketSpan_List is a list of BucketSpan.
type BucketSpan_List = capnp.StructList[BucketSpan]

// NewBucketSpan creates a new list of BucketSpan.
func NewBucketSpan_List(s *capnp.Segment, sz int32) (BucketSpan_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[BucketSpan](l), err
}

// BucketSpan_Future is a wrapper for a BucketSpan promised by a client call.
type BucketSpan_Future struct{ *capnp.Future }

func (f BucketSpan_Future) Struct() (BucketSpan, error) {
	p, err := f.Future.Ptr()
	return BucketSpan(p.Struct()), err
}

type Histogram capnp.Struct
type Histogram_count Histogram
type Histogram_zeroCount Histogram
type Histogram_count_Which uint16

const (
	Histogram_count_Which_countInt   Histogram_count_Which = 0
	Histogram_count_Which_countFloat Histogram_count_Which = 1
)

func (w Histogram_count_Which) String() string {
	const s = "countIntcountFloat"
	switch w {
	case Histogram_count_Which_countInt:
		return s[0:8]
	case Histogram_count_Which_countFloat:
		return s[8:18]

	}
	return "Histogram_count_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

type Histogram_zeroCount_Which uint16

const (
	Histogram_zeroCount_Which_zeroCountInt   Histogram_zeroCount_Which = 0
	Histogram_zeroCount_Which_zeroCountFloat Histogram_zeroCount_Which = 1
)

func (w Histogram_zeroCount_Which) String() string {
	const s = "zeroCountIntzeroCountFloat"
	switch w {
	case Histogram_zeroCount_Which_zeroCountInt:
		return s[0:12]
	case Histogram_zeroCount_Which_zeroCountFloat:
		return s[12:26]

	}
	return "Histogram_zeroCount_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Histogram_TypeID is the unique identifier for the type Histogram.
const Histogram_TypeID = 0xc4dd3c458256382a

func NewHistogram(s *capnp.Segment) (Histogram, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 56, PointerCount: 6})
	return Histogram(st), err
}

func NewRootHistogram(s *capnp.Segment) (Histogram, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 56, PointerCount: 6})
	return Histogram(st), err
}

func ReadRootHistogram(msg *capnp.Message) (Histogram, error) {
	root, err := msg.Root()
	return Histogram(root.Struct()), err
}

func (s Histogram) String() string {
	str, _ := text.Marshal(0xc4dd3c458256382a, capnp.Struct(s))
	return str
}

func (s Histogram) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Histogram) DecodeFromPtr(p capnp.Ptr) Histogram {
	return Histogram(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Histogram) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Histogram) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Histogram) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Histogram) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Histogram) Count() Histogram_count { return Histogram_count(s) }

func (s Histogram_count) Which() Histogram_count_Which {
	return Histogram_count_Which(capnp.Struct(s).Uint16(8))
}
func (s Histogram_count) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Histogram_count) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Histogram_count) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Histogram_count) CountInt() uint64 {
	if capnp.Struct(s).Uint16(8) != 0 {
		panic("Which() != countInt")
	}
	return capnp.Struct(s).Uint64(0)
}

func (s Histogram_count) SetCountInt(v uint64) {
	capnp.Struct(s).SetUint16(8, 0)
	capnp.Struct(s).SetUint64(0, v)
}

func (s Histogram_count) CountFloat() float64 {
	if capnp.Struct(s).Uint16(8) != 1 {
		panic("Which() != countFloat")
	}
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Histogram_count) SetCountFloat(v float64) {
	capnp.Struct(s).SetUint16(8, 1)
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Histogram) Sum() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s Histogram) SetSum(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

func (s Histogram) Schema() int32 {
	return int32(capnp.Struct(s).Uint32(12))
}

func (s Histogram) SetSchema(v int32) {
	capnp.Struct(s).SetUint32(12, uint32(v))
}

func (s Histogram) ZeroThreshold() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(24))
}

func (s Histogram) SetZeroThreshold(v float64) {
	capnp.Struct(s).SetUint64(24, math.Float64bits(v))
}

func (s Histogram) ZeroCount() Histogram_zeroCount { return Histogram_zeroCount(s) }

func (s Histogram_zeroCount) Which() Histogram_zeroCount_Which {
	return Histogram_zeroCount_Which(capnp.Struct(s).Uint16(10))
}
func (s Histogram_zeroCount) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Histogram_zeroCount) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Histogram_zeroCount) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Histogram_zeroCount) ZeroCountInt() uint64 {
	if capnp.Struct(s).Uint16(10) != 0 {
		panic("Which() != zeroCountInt")
	}
	return capnp.Struct(s).Uint64(32)
}

func (s Histogram_zeroCount) SetZeroCountInt(v uint64) {
	capnp.Struct(s).SetUint16(10, 0)
	capnp.Struct(s).SetUint64(32, v)
}

func (s Histogram_zeroCount) ZeroCountFloat() float64 {
	if capnp.Struct(s).Uint16(10) != 1 {
		panic("Which() != zeroCountFloat")
	}
	return math.Float64frombits(capnp.Struct(s).Uint64(32))
}

func (s Histogram_zeroCount) SetZeroCountFloat(v float64) {
	capnp.Struct(s).SetUint16(10, 1)
	capnp.Struct(s).SetUint64(32, math.Float64bits(v))
}

func (s Histogram) NegativeSpans() (BucketSpan_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return BucketSpan_List(p.List()), err
}

func (s Histogram) HasNegativeSpans() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Histogram) SetNegativeSpans(v BucketSpan_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewNegativeSpans sets the negativeSpans field to a newly
// allocated BucketSpan_List, preferring placement in s's segment.
func (s Histogram) NewNegativeSpans(n int32) (BucketSpan_List, error) {
	l, err := NewBucketSpan_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return BucketSpan_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Histogram) NegativeDeltas() (capnp.Int64List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.Int64List(p.List()), err
}

func (s Histogram) HasNegativeDeltas() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Histogram) SetNegativeDeltas(v capnp.Int64List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewNegativeDeltas sets the negativeDeltas field to a newly
// allocated capnp.Int64List, preferring placement in s's segment.
func (s Histogram) NewNegativeDeltas(n int32) (capnp.Int64List, error) {
	l, err := capnp.NewInt64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Int64List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s Histogram) NegativeCounts() (capnp.Float64List, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return capnp.Float64List(p.List()), err
}

func (s Histogram) HasNegativeCounts() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Histogram) SetNegativeCounts(v capnp.Float64List) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewNegativeCounts sets the negativeCounts field to a newly
// allocated capnp.Float64List, preferring placement in s's segment.
func (s Histogram) NewNegativeCounts(n int32) (capnp.Float64List, error) {
	l, err := capnp.NewFloat64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Float64List{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}
func (s Histogram) PositiveSpans() (BucketSpan_List, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return BucketSpan_List(p.List()), err
}

func (s Histogram) HasPositiveSpans() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Histogram) SetPositiveSpans(v BucketSpan_List) error {
	return capnp.Struct(s).SetPtr(3, v.ToPtr())
}

// NewPositiveSpans sets the positiveSpans field to a newly
// allocated BucketSpan_List, preferring placement in s's segment.
func (s Histogram) NewPositiveSpans(n int32) (BucketSpan_List, error) {
	l, err := NewBucketSpan_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return BucketSpan_List{}, err
	}
	err = capnp.Struct(s).SetPtr(3, l.ToPtr())
	return l, err
}
func (s Histogram) PositiveDeltas() (capnp.Int64List, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return capnp.Int64List(p.List()), err
}

func (s Histogram) HasPositiveDeltas() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s Histogram) SetPositiveDeltas(v capnp.Int64List) error {
	return capnp.Struct(s).SetPtr(4, v.ToPtr())
}

// NewPositiveDeltas sets the positiveDeltas field to a newly
// allocated capnp.Int64List, preferring placement in s's segment.
func (s Histogram) NewPositiveDeltas(n int32) (capnp.Int64List, error) {
	l, err := capnp.NewInt64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Int64List{}, err
	}
	err = capnp.Struct(s).SetPtr(4, l.ToPtr())
	return l, err
}
func (s Histogram) PositiveCounts() (capnp.Float64List, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return capnp.Float64List(p.List()), err
}

func (s Histogram) HasPositiveCounts() bool {
	return capnp.Struct(s).HasPtr(5)
}

func (s Histogram) SetPositiveCounts(v capnp.Float64List) error {
	return capnp.Struct(s).SetPtr(5, v.ToPtr())
}

// NewPositiveCounts sets the positiveCounts field to a newly
// allocated capnp.Float64List, preferring placement in s's segment.
func (s Histogram) NewPositiveCounts(n int32) (capnp.Float64List, error) {
	l, err := capnp.NewFloat64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Float64List{}, err
	}
	err = capnp.Struct(s).SetPtr(5, l.ToPtr())
	return l, err
}
func (s Histogram) ResetHint() Histogram_ResetHint {
	return Histogram_ResetHint(capnp.Struct(s).Uint16(40))
}

func (s Histogram) SetResetHint(v Histogram_ResetHint) {
	capnp.Struct(s).SetUint16(40, uint16(v))
}

func (s Histogram) Timestamp() int64 {
	return int64(capnp.Struct(s).Uint64(48))
}

func (s Histogram) SetTimestamp(v int64) {
	capnp.Struct(s).SetUint64(48, uint64(v))
}

// Histogram_List is a list of Histogram.
type Histogram_List = capnp.StructList[Histogram]

// NewHistogram creates a new list of Histogram.
func NewHistogram_List(s *capnp.Segment, sz int32) (Histogram_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 56, PointerCount: 6}, sz)
	return capnp.StructList[Histogram](l), err
}

// Histogram_Future is a wrapper for a Histogram promised by a client call.
type Histogram_Future struct{ *capnp.Future }

func (f Histogram_Future) Struct() (Histogram, error) {
	p, err := f.Future.Ptr()
	return Histogram(p.Struct()), err
}
func (p Histogram_Future) Count() Histogram_count_Future { return Histogram_count_Future{p.Future} }

// Histogram_count_Future is a wrapper for a Histogram_count promised by a client call.
type Histogram_count_Future struct{ *capnp.Future }

func (f Histogram_count_Future) Struct() (Histogram_count, error) {
	p, err := f.Future.Ptr()
	return Histogram_count(p.Struct()), err
}
func (p Histogram_Future) ZeroCount() Histogram_zeroCount_Future {
	return Histogram_zeroCount_Future{p.Future}
}

// Histogram_zeroCount_Future is a wrapper for a Histogram_zeroCount promised by a client call.
type Histogram_zeroCount_Future struct{ *capnp.Future }

func (f Histogram_zeroCount_Future) Struct() (Histogram_zeroCount, error) {
	p, err := f.Future.Ptr()
	return Histogram_zeroCount(p.Struct()), err
}

type Histogram_ResetHint uint16

// Histogram_ResetHint_TypeID is the unique identifier for the type Histogram_ResetHint.
const Histogram_ResetHint_TypeID = 0xd5b0cec646441eb0

// Values of Histogram_ResetHint.
const (
	Histogram_ResetHint_unknown Histogram_ResetHint = 0
	Histogram_ResetHint_yes     Histogram_ResetHint = 1
	Histogram_ResetHint_no      Histogram_ResetHint = 2
	Histogram_ResetHint_gauge   Histogram_ResetHint = 3
)

// String returns the enum's constant name.
func (c Histogram_ResetHint) String() string {
	switch c {
	case Histogram_ResetHint_unknown:
		return "unknown"
	case Histogram_ResetHint_yes:
		return "yes"
	case Histogram_ResetHint_no:
		return "no"
	case Histogram_ResetHint_gauge:
		return "gauge"

	default:
		return ""
	}
}

// Histogram_ResetHintFromString returns the enum value with a name,
// or the zero value if there's no such value.
func Histogram_ResetHintFromString(c string) Histogram_ResetHint {
	switch c {
	case "unknown":
		return Histogram_ResetHint_unknown
	case "yes":
		return Histogram_ResetHint_yes
	case "no":
		return Histogram_ResetHint_no
	case "gauge":
		return Histogram_ResetHint_gauge

	default:
		return 0
	}
}

type Histogram_ResetHint_List = capnp.EnumList[Histogram_ResetHint]

func NewHistogram_ResetHint_List(s *capnp.Segment, sz int32) (Histogram_ResetHint_List, error) {
	return capnp.NewEnumList[Histogram_ResetHint](s, sz)
}

type Exemplar capnp.Struct

// Exemplar_TypeID is the unique identifier for the type Exemplar.
const Exemplar_TypeID = 0xbd820120399954be

func NewExemplar(s *capnp.Segment) (Exemplar, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return Exemplar(st), err
}

func NewRootExemplar(s *capnp.Segment) (Exemplar, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return Exemplar(st), err
}

func ReadRootExemplar(msg *capnp.Message) (Exemplar, error) {
	root, err := msg.Root()
	return Exemplar(root.Struct()), err
}

func (s Exemplar) String() string {
	str, _ := text.Marshal(0xbd820120399954be, capnp.Struct(s))
	return str
}

func (s Exemplar) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Exemplar) DecodeFromPtr(p capnp.Ptr) Exemplar {
	return Exemplar(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Exemplar) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Exemplar) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Exemplar) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Exemplar) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Exemplar) Labels() (Label_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Label_List(p.List()), err
}

func (s Exemplar) HasLabels() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Exemplar) SetLabels(v Label_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLabels sets the labels field to a newly
// allocated Label_List, preferring placement in s's segment.
func (s Exemplar) NewLabels(n int32) (Label_List, error) {
	l, err := NewLabel_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Label_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Exemplar) Value() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Exemplar) SetValue(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Exemplar) Timestamp() int64 {
	return int64(capnp.Struct(s).Uint64(8))
}

func (s Exemplar) SetTimestamp(v int64) {
	capnp.Struct(s).SetUint64(8, uint64(v))
}

// Exemplar_List is a list of Exemplar.
type Exemplar_List = capnp.StructList[Exemplar]

// NewExemplar creates a new list of Exemplar.
func NewExemplar_List(s *capnp.Segment, sz int32) (Exemplar_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1}, sz)
	return capnp.StructList[Exemplar](l), err
}

// Exemplar_Future is a wrapper for a Exemplar promised by a client call.
type Exemplar_Future struct{ *capnp.Future }

func (f Exemplar_Future) Struct() (Exemplar, error) {
	p, err := f.Future.Ptr()
	return Exemplar(p.Struct()), err
}

type TimeSeries capnp.Struct

// TimeSeries_TypeID is the unique identifier for the type TimeSeries.
const TimeSeries_TypeID = 0xb438c10228b97446

func NewTimeSeries(s *capnp.Segment) (TimeSeries, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4})
	return TimeSeries(st), err
}

func NewRootTimeSeries(s *capnp.Segment) (TimeSeries, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4})
	return TimeSeries(st), err
}

func ReadRootTimeSeries(msg *capnp.Message) (TimeSeries, error) {
	root, err := msg.Root()
	return TimeSeries(root.Struct()), err
}

func (s TimeSeries) String() string {
	str, _ := text.Marshal(0xb438c10228b97446, capnp.Struct(s))
	return str
}

func (s TimeSeries) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (TimeSeries) DecodeFromPtr(p capnp.Ptr) TimeSeries {
	return TimeSeries(capnp.Struct{}.DecodeFromPtr(p))
}

func (s TimeSeries) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s TimeSeries) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s TimeSeries) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s TimeSeries) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s TimeSeries) Labels() (Label_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Label_List(p.List()), err
}

func (s TimeSeries) HasLabels() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s TimeSeries) SetLabels(v Label_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLabels sets the labels field to a newly
// allocated Label_List, preferring placement in s's segment.
func (s TimeSeries) NewLabels(n int32) (Label_List, error) {
	l, err := NewLabel_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Label_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s TimeSeries) Samples() (Sample_List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Sample_List(p.List()), err
}

func (s TimeSeries) HasSamples() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s TimeSeries) SetSamples(v Sample_List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewSamples sets the samples field to a newly
// allocated Sample_List, preferring placement in s's segment.
func (s TimeSeries) NewSamples(n int32) (Sample_List, error) {
	l, err := NewSample_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Sample_List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s TimeSeries) Histograms() (Histogram_List, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return Histogram_List(p.List()), err
}

func (s TimeSeries) HasHistograms() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s TimeSeries) SetHistograms(v Histogram_List) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewHistograms sets the histograms field to a newly
// allocated Histogram_List, preferring placement in s's segment.
func (s TimeSeries) NewHistograms(n int32) (Histogram_List, error) {
	l, err := NewHistogram_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Histogram_List{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}
func (s TimeSeries) Exemplars() (Exemplar_List, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return Exemplar_List(p.List()), err
}

func (s TimeSeries) HasExemplars() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s TimeSeries) SetExemplars(v Exemplar_List) error {
	return capnp.Struct(s).SetPtr(3, v.ToPtr())
}

// NewExemplars sets the exemplars field to a newly
// allocated Exemplar_List, preferring placement in s's segment.
func (s TimeSeries) NewExemplars(n int32) (Exemplar_List, error) {
	l, err := NewExemplar_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Exemplar_List{}, err
	}
	err = capnp.Struct(s).SetPtr(3, l.ToPtr())
	return l, err
}

// TimeSeries_List is a list of TimeSeries.
type TimeSeries_List = capnp.StructList[TimeSeries]

// NewTimeSeries creates a new list of TimeSeries.
func NewTimeSeries_List(s *capnp.Segment, sz int32) (TimeSeries_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4}, sz)
	return capnp.StructList[TimeSeries](l), err
}

// TimeSeries_Future is a wrapper for a TimeSeries promised by a client call.
type TimeSeries_Future struct{ *capnp.Future }

func (f TimeSeries_Future) Struct() (TimeSeries, error) {
	p, err := f.Future.Ptr()
	return TimeSeries(p.Struct()), err
}

type WriteRequest capnp.Struct

// WriteRequest_TypeID is the unique identifier for the type WriteRequest.
const WriteRequest_TypeID = 0xeb3bcb770c8eb6be

func NewWriteRequest(s *capnp.Segment) (WriteRequest, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return WriteRequest(st), err
}

func NewRootWriteRequest(s *capnp.Segment) (WriteRequest, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return WriteRequest(st), err
}

func ReadRootWriteRequest(msg *capnp.Message) (WriteRequest, error) {
	root, err := msg.Root()
	return WriteRequest(root.Struct()), err
}

func (s WriteRequest) String() string {
	str, _ := text.Marshal(0xeb3bcb770c8eb6be, capnp.Struct(s))
	return str
}

func (s WriteRequest) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (WriteRequest) DecodeFromPtr(p capnp.Ptr) WriteRequest {
	return WriteRequest(capnp.Struct{}.DecodeFromPtr(p))
}

func (s WriteRequest) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s WriteRequest) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s WriteRequest) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s WriteRequest) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s WriteRequest) Symbols() (Symbols, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Symbols(p.Struct()), err
}

func (s WriteRequest) HasSymbols() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s WriteRequest) SetSymbols(v Symbols) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewSymbols sets the symbols field to a newly
// allocated Symbols struct, preferring placement in s's segment.
func (s WriteRequest) NewSymbols() (Symbols, error) {
	ss, err := NewSymbols(capnp.Struct(s).Segment())
	if err != nil {
		return Symbols{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s WriteRequest) TimeSeries() (TimeSeries_List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return TimeSeries_List(p.List()), err
}

func (s WriteRequest) HasTimeSeries() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s WriteRequest) SetTimeSeries(v TimeSeries_List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewTimeSeries sets the timeSeries field to a newly
// allocated TimeSeries_List, preferring placement in s's segment.
func (s WriteRequest) NewTimeSeries(n int32) (TimeSeries_List, error) {
	l, err := NewTimeSeries_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return TimeSeries_List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s WriteRequest) Tenant() (string, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.Text(), err
}

func (s WriteRequest) HasTenant() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s WriteRequest) TenantBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.TextBytes(), err
}

func (s WriteRequest) SetTenant(v string) error {
	return capnp.Struct(s).SetText(2, v)
}

// WriteRequest_List is a list of WriteRequest.
type WriteRequest_List = capnp.StructList[WriteRequest]

// NewWriteRequest creates a new list of WriteRequest.
func NewWriteRequest_List(s *capnp.Segment, sz int32) (WriteRequest_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return capnp.StructList[WriteRequest](l), err
}

// WriteRequest_Future is a wrapper for a WriteRequest promised by a client call.
type WriteRequest_Future struct{ *capnp.Future }

func (f WriteRequest_Future) Struct() (WriteRequest, error) {
	p, err := f.Future.Ptr()
	return WriteRequest(p.Struct()), err
}
func (p WriteRequest_Future) Symbols() Symbols_Future {
	return Symbols_Future{Future: p.Future.Field(0, nil)}
}

type WriteError uint16

// WriteError_TypeID is the unique identifier for the type WriteError.
const WriteError_TypeID = 0xe67be4164a39ea55

// Values of WriteError.
const (
	WriteError_none            WriteError = 0
	WriteError_unavailable     WriteError = 1
	WriteError_alreadyExists   WriteError = 2
	WriteError_invalidArgument WriteError = 3
	WriteError_internal        WriteError = 4
)

// String returns the enum's constant name.
func (c WriteError) String() string {
	switch c {
	case WriteError_none:
		return "none"
	case WriteError_unavailable:
		return "unavailable"
	case WriteError_alreadyExists:
		return "alreadyExists"
	case WriteError_invalidArgument:
		return "invalidArgument"
	case WriteError_internal:
		return "internal"

	default:
		return ""
	}
}

// WriteErrorFromString returns the enum value with a name,
// or the zero value if there's no such value.
func WriteErrorFromString(c string) WriteError {
	switch c {
	case "none":
		return WriteError_none
	case "unavailable":
		return WriteError_unavailable
	case "alreadyExists":
		return WriteError_alreadyExists
	case "invalidArgument":
		return WriteError_invalidArgument
	case "internal":
		return WriteError_internal

	default:
		return 0
	}
}

type WriteError_List = capnp.EnumList[WriteError]

func NewWriteError_List(s *capnp.Segment, sz int32) (WriteError_List, error) {
	return capnp.NewEnumList[WriteError](s, sz)
}

type Writer capnp.Client

// Writer_TypeID is the unique identifier for the type Writer.
const Writer_TypeID = 0xcc20b9c332c83b91

func (c Writer) Write(ctx context.Context, params func(Writer_write_Params) error) (Writer_write_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xcc20b9c332c83b91,
			MethodID:      0,
			InterfaceName: "pkg/receive/writecapnp/write_request.capnp:Writer",
			MethodName:    "write",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Writer_write_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Writer_write_Results_Future{Future: ans.Future()}, release

}

func (c Writer) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Writer) String() string {
	return "Writer(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Writer) AddRef() Writer {
	return Writer(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Writer) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Writer) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Writer) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Writer) DecodeFromPtr(p capnp.Ptr) Writer {
	return Writer(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Writer) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Writer) IsSame(other Writer) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Writer) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Writer) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Writer_Server is a Writer with a local implementation.
type Writer_Server interface {
	Write(context.Context, Writer_write) error
}

// Writer_NewServer creates a new Server from an implementation of Writer_Server.
func Writer_NewServer(s Writer_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Writer_Methods(nil, s), s, c)
}

// Writer_ServerToClient creates a new Client from an implementation of Writer_Server.
// The caller is responsible for calling Release on the returned Client.
func Writer_ServerToClient(s Writer_Server) Writer {
	return Writer(capnp.NewClient(Writer_NewServer(s)))
}

// Writer_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Writer_Methods(methods []server.Method, s Writer_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xcc20b9c332c83b91,
			MethodID:      0,
			InterfaceName: "pkg/receive/writecapnp/write_request.capnp:Writer",
			MethodName:    "write",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Write(ctx, Writer_write{call})
		},
	})

	return methods
}

// Writer_write holds the state for a server call to Writer.write.
// See server.Call for documentation.
type Writer_write struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Writer_write) Args() Writer_write_Params {
	return Writer_write_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Writer_write) AllocResults() (Writer_write_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Writer_write_Results(r), err
}

// Writer_List is a list of Writer.
type Writer_List = capnp.CapList[Writer]

// NewWriter_List creates a new list of Writer.
func NewWriter_List(s *capnp.Segment, sz int32) (Writer_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Writer](l), err
}

type Writer_write_Params capnp.Struct

// Writer_write_Params_TypeID is the unique identifier for the type Writer_write_Params.
const Writer_write_Params_TypeID = 0x90d5073324ecc34b

func NewWriter_write_Params(s *capnp.Segment) (Writer_write_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Writer_write_Params(st), err
}

func NewRootWriter_write_Params(s *capnp.Segment) (Writer_write_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Writer_write_Params(st), err
}

func ReadRootWriter_write_Params(msg *capnp.Message) (Writer_write_Params, error) {
	root, err := msg.Root()
	return Writer_write_Params(root.Struct()), err
}

func (s Writer_write_Params) String() string {
	str, _ := text.Marshal(0x90d5073324ecc34b, capnp.Struct(s))
	return str
}

func (s Writer_write_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Writer_write_Params) DecodeFromPtr(p capnp.Ptr) Writer_write_Params {
	return Writer_write_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Writer_write_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Writer_write_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Writer_write_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Writer_write_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Writer_write_Params) Wr() (WriteRequest, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return WriteRequest(p.Struct()), err
}

func (s Writer_write_Params) HasWr() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Writer_write_Params) SetWr(v WriteRequest) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewWr sets the wr field to a newly
// allocated WriteRequest struct, preferring placement in s's segment.
func (s Writer_write_Params) NewWr() (WriteRequest, error) {
	ss, err := NewWriteRequest(capnp.Struct(s).Segment())
	if err != nil {
		return WriteRequest{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Writer_write_Params_List is a list of Writer_write_Params.
type Writer_write_Params_List = capnp.StructList[Writer_write_Params]

// NewWriter_write_Params creates a new list of Writer_write_Params.
func NewWriter_write_Params_List(s *capnp.Segment, sz int32) (Writer_write_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Writer_write_Params](l), err
}

// Writer_write_Params_Future is a wrapper for a Writer_write_Params promised by a client call.
type Writer_write_Params_Future struct{ *capnp.Future }

func (f Writer_write_Params_Future) Struct() (Writer_write_Params, error) {
	p, err := f.Future.Ptr()
	return Writer_write_Params(p.Struct()), err
}
func (p Writer_write_Params_Future) Wr() WriteRequest_Future {
	return WriteRequest_Future{Future: p.Future.Field(0, nil)}
}

type Writer_write_Results capnp.Struct

// Writer_write_Results_TypeID is the unique identifier for the type Writer_write_Results.
const Writer_write_Results_TypeID = 0x87f6d2196d414cf4

func NewWriter_write_Results(s *capnp.Segment) (Writer_write_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Writer_write_Results(st), err
}

func NewRootWriter_write_Results(s *capnp.Segment) (Writer_write_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Writer_write_Results(st), err
}

func ReadRootWriter_write_Results(msg *capnp.Message) (Writer_write_Results, error) {
	root, err := msg.Root()
	return Writer_write_Results(root.Struct()), err
}

func (s Writer_write_Results) String() string {
	str, _ := text.Marshal(0x87f6d2196d414cf4, capnp.Struct(s))
	return str
}

func (s Writer_write_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Writer_write_Results) DecodeFromPtr(p capnp.Ptr) Writer_write_Results {
	return Writer_write_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Writer_write_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Writer_write_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Writer_write_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Writer_write_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Writer_write_Results) Error() WriteError {
	return WriteError(capnp.Struct(s).Uint16(0))
}

func (s Writer_write_Results) SetError(v WriteError) {
	capnp.Struct(s).SetUint16(0, uint16(v))
}

// Writer_write_Results_List is a list of Writer_write_Results.
type Writer_write_Results_List = capnp.StructList[Writer_write_Results]

// NewWriter_write_Results creates a new list of Writer_write_Results.
func NewWriter_write_Results_List(s *capnp.Segment, sz int32) (Writer_write_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[Writer_write_Results](l), err
}

// Writer_write_Results_Future is a wrapper for a Writer_write_Results promised by a client call.
type Writer_write_Results_Future struct{ *capnp.Future }

func (f Writer_write_Results_Future) Struct() (Writer_write_Results, error) {
	p, err := f.Future.Ptr()
	return Writer_write_Results(p.Struct()), err
}

const schema_85d3acc39d94e0f8 = "x\xda\xa4Vml\x1cW\x15\xbd\xe7\xbd\x99\x1d\xdb\xbb" +
	"\x8e=\x9aUQ*`\xdb*HuL\xd2\xc4NP" +
	"\x92\x16m\x1c\xe2\x10\xa7F\xf2\xec&\xd0\xa0\x14:\xb1" +
	"_\xed%\xb3\xb3\xdb\x99Y;6\xaa\x0c\x91P\x13T" +
	">\x1a\x88DAH\x0d\x14$\xbe\xab\xf0\xa1Fj\x91" +
	" \x08\xa8\xf8P\x0bT\x02D)\x95*\x90 \x80\x90" +
	"\x10B\x91\xc8\xa0\xfbv=;XFd\xc3?\xfb\xcc" +
	"\xd9{\xde=\xef\xbe{\xef\x8ekr\xbf\xb1s\xf0#" +
	"9\x12\xee\xb4\x99K\xfe>=Q\xdf\xfc\xb3\x7f<B" +
	"\xee\x18@dXD\xe3\xdb\xa4\x10\x04gB\x96\x09\xc9" +
	"\xbdW\xaen\x19\xb7^\xfc(\xd9c 2\xc1\x04O" +
	"^\x03\xc1ii\xc2W\xdf5\xf2\xb1\x17\xa6\xde\xf4\x09" +
	"rG\x81\xe4\x9f\xbf\xfb\xf8\xa7\xaf|\xf9\xe7\x1fhG" +
	"\xba /\xc1\xf9\x8a\xb4\x88\x9c/\xc8%B\xf2\xc8\xe5" +
	"\xbd\xb7\\x\xfe\x81\xcf\x92\xbb\x1bV\xb2u\xcf\xdb\xcf" +
	"L\xde\xf3\xd2\xf7\xe8X\xce\x82\x801n\x1a\xbf\xe6\xc0" +
	"\x9b\x0d\xe6\xae<}\xfd\xea\xe7_Y\xfe\x12\xd9\xa3\x99" +
	"\xb8\xa6\xe0\xc0\x0f\x1b\x9f\x84s\x815\x9c\xc74y\xd3" +
	"\xae\xe5O\xbd\xefb\xfc\xf5\x0d\x03\x9b\xe3\xff2\xf4\x89" +
	"m\x93\xb9\x87\xe2\xcbw\x8a\xef\xec\xf9\xc6\xba\xc0\xfa\xc4" +
	"-\xf3\x12\x9c\x0f\x99\x1c\xf8\x9c\xf9\x07B\xf2\xed\xa3\x8f" +
	"\xef\xbd\x0dg\x9e\xe5\xf4D\x86\xad\x8d\xf8\\\xee3p" +
	"\x9e\xcd1\xfbr\xeek\x84\xae\xb0;\x0a+\xc3f\xca" +
	"\xb8\xb2\xbe\x08\xe7a\xeb5D\xe3\xe7\xac\x97\x05!y" +
	"\xec\xee\x1f\x8e]\xb9|\xdb\x8f\xc9\x1e\x95]6a\xfc" +
	"\xb9\x81\xf3p^\x19\xe0\xc0/\x0d\xbc\xd51\xf3\x16Q" +
	"\xf2\xd4\xeb\x0f\x1e\xfa\xfeO\x9fz\x91\xec\xdd\xa2\xabD" +
	"\x18\xff\xf3\xc058\xfd\xccq\xcc\xfc<!9\xf6\xc7" +
	"\xbdGny\xf5\xbd\xbf'{T\xfcG\xdc\x91\xfc%" +
	"8\x13\x9a\xf9\xe6\xfc*\xa7\xf7\xad\x0f\x17\x96~t\xf7" +
	"\x9f\xd6y\xc1W6\xfe\xfe\xfcw\xe1<\xae\xc9\x17\xf2" +
	"\x9c\xddo[g\xaf\xf9/O\xfdu\x9d\x17\xda\xb8\x89" +
	"\xc2y8\xc7\x0bL>V`\x97\xc7\xee\xb5\xad\xbf\xfc" +
	"\xe0\xfc\xdf6\xaa\x8bo\x16>\x08\xe7'\x9a\xfc\\a" +
	"\x89\xb6%\xcdS\xf3w\x85jVY\xb5Eu\xd7R" +
	"X\x8b\xd5\xac\xd7\x0c\x9a\xed?\xdf\x1d\xaa\x87Z*\x8a" +
	"\xb7kl\xdf;\x18\x0b\xb7\xebO[**j\xf9q" +
	"D\xae!\x0d\"\x03D\xf6\xe0\x18\x91\xdb'\xe1\x16\x05" +
	"J*\x0c\x1b!\x86\xba\x8e\x100DH\x05s\xbd\x0a" +
	"\x96g\xbc\xd0\xabGY\xbd[\xbbzr)\xc4p\xd7" +
	"T\x02\x863b\xe6\x0d\x88\x1dh\xcd\x9eR\xa5\xb8\xda" +
	"\xf4\x82\x19\xc0\xedKeF\xf6\x11\xb9[$\xdc\x1d\x02" +
	"6P\xe4\xe7joc\xf0N\x09w\x97@\xb9\xf1\xe0" +
	"\x83\x91\x8aa\x90\x80A(\xfb*\x98\x8f\x17\xd0G\x02" +
	"}=f|\xb8\x16\xc5\x8d\xf9\xd0\xabo\x9fm\xb4d" +
	"\x10\xf31\x0aI\xd2>\xc7\x91\xae\xe4 \xae'\xed\x83" +
	"\xec|'\x91\xbbC\xc2\xbdG \x99m\xb4\x82x*" +
	"\x88\x89\x08\xfd$\xd0O\x1d\xec\x90\xdf \xe9\xc5\xc8\x93" +
	"@\xbeGc\xaa\xcb\xf5\x93\x0d\xe9G\xeb\\\xd9\xba\x91" +
	"+\x07:G<(04\xe7\xc5\x1e\x06I`\x90\xb0" +
	"\xda\xb6(\xc2&\xc2\x8c\x84\xf6f\xd3M{\xb3\xa2\xc2" +
	"r\xe3-\x9c\x17\x1f\xe8\xb5Ib\x14a\xf2\x99\xde\xd3" +
	"u\xe8u\xb8\xcep\x8e-Z\xc9X\xb4\xa2B\xfdS" +
	"\x1ab\xa3R\x97R\xb8\xcc^\xdd\xa4SGkuU" +
	"-\xa9\xb0\xa6\xb4Y\xc3\xa9Y\x1eW\xcb\x09\x09\xf7t" +
	"\xc6\xac\x16\x9b\xd5\x94p\x1f\x15\xb0\x85(B\x10\xd9\xe7" +
	"\xf8:\xcfJ\xb8O\x0a\xd8R\x16!\x89\xec\x8b\x15\"" +
	"\xf7\x09\x09\xf7\x19\x81\xb2\xef\x9dT~j\xe4p\xf7\xb9" +
	"\x13\x18\\\x8d\xbcz\xd3W\x19B\xda<\xda\x84d\xa1" +
	"\xe3#\xc9z\x86\x95ik\x9a\xa5N\xabz\xd3\xf7B" +
	"B\x86\x94\xf6\xe4\x0e\xa9\x17s&9\xa0\xe5{![" +
	"SH\xad\x99dk\xf6K\xb8'\x04\xd6\x9c9\xce\x8d" +
	"\xe4\xa8\x84\xfb\x00;\x83\xb63\xf7W:\x1e.\xfco" +
	"\x13J\x8b\x9e\xdfR\xe9\x1d\xc6\xb5\xba\x8ab\xafNh" +
	"\xc2$\x01\xb3\xc7\xa3\xeb\xca\x1b\xe2\xd2s\x0d 3\x0e" +
	"PI**R\xf1\xe1Z@\x88\xdd]\x9c\x152\xc3" +
	"\xd6\xb9\x1fc$l\xb4/\xd7\x99\xc4\x1dD\xd5\xfd\x90" +
	"\xa8N\x83Sk\xdf\xaf3\x85}D\xd5\x83\x8c\xcf\xa0" +
	"s\xef\x06\x91\xf36\x84D\xd5i\xc6\xef\x83\x00X<" +
	"\x9d\xb7\xce1T8\x97\"\x0fDgBSu\xe8\x13" +
	"\x1c\"\x87\"\xfa\x88\x9c\xe3X!\xaa\xde\xc7x\xcc\xb8" +
	"%\x8a\xe8'r\x1e\xd2x\x93\xf1G\x19\xef\x93E\x0c" +
	"\xf0\xec\xd5q\xce2\xfe$\xe3\xfdF\x11y\"\xe7\xa2" +
	"\xe6?\xc1\xf83\x8c\x0f\x98E\x14x\xfaj\xfci\xc6" +
	"\x7f\xc1x\xbeX\xc4 \x91\xf3\x02*D\xd5\xe7\x19\xff" +
	"\x0d\xe3\x85\\\x11\x9b\x88\x9c_i\xfc\x97\x8c\xbf\x0a\x81" +
	"\x92\xeeNV\xd4\xaa\xaf]V9\x9a]Puo\xad" +
	"\x99\xea\x87yt!TT\x8a\x16\x1a\xfe\\z\xa7\xe9" +
	"\x83E\x9c\x04j\xde\x8bk\x8b\x8aJ\xdc\xbd3e\x91" +
	"\xaeH\x9dzM\x89\xe5\x83\xca\x8f\xbd\x94iv\xdaQ" +
	"\xf7\xbb\xee.\xe9\xf7\xfcZ\xbbjD\xb5\x1b\x12J\x89" +
	"\xffE\xa8\xfb}c\xa1\xb0[U\x18\xea\x16\\g\x86" +
	"\xfe\xbf\xf5\xac\xe7*\xf4C4\xa4I\x94\xee\x9aX\xdb" +
	"Jm\x9b\xeb\xd6\xb4J\xfa\xe7\xfb1\x83\x9b\xed\xd5\x15" +
	"\x15\x95u*\xb1n\x89\xfa)\x8f\x1c\xe0L\xec\xdb\xef" +
	" \x82\xb07\xdfJ\x04\xc9\x8a\xb4\xda\x0aN\x05\x8d\xa5" +
	"\xc0ZV\x91\x0c\x1a\xa5y\xaf5\xafzO\xad4\xc9" +
	"\xcb\x07\xeb\xb5[\xc7\xee\xadZo\xdbI\xad7\x12j" +
	"\xbd7\x9c!\x82a\xdf~\x84h(h\x04*i\x05" +
	"\xde\xa2W\xf3=\xb2N\xfa*\xf1\xfcPys\xcb\x93" +
	"T:]\x8b\xe2(\xa9\x05\x8b\x9e_\x9b\x9b\x10\xe1|" +
	"\xab\xae\x82\x98jA\xac\xc2\xc0\xf3\x89z\xdfi*m" +
	"\x88\xd6\xb5\xc2\x03\x9dV8\x9d\x99\x12S<\x10\x0eK" +
	"\xb8s\x99)\x91\xce\x93\x05\x81\xd5\x88\xe7\xb3\x1fa\xb8" +
	"\xbb\xb8w\xd6\x1f\xae\x93\xaa\x0ak$\xb3\xf3 \xdd\xc2" +
	"\xdb\xb5Z\x8eU\xe0\x051\x0a$P\xe8u5\xe0Y" +
	"\x03\xb5n3\xa8t\xa7p\x9a\xc6Nn\xe9o\x94p" +
	"\xf7\x88\x0d\xebw]\xc7\xee\xe5\x10\xd3<\x0b\x88nd" +
	"=\x19\xeb\x9el(\xf0\xeajmG\xeb\xa8w\xfe\xfb" +
	"w\x00\x00\x00\xff\xff9\x1a\xaea"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_85d3acc39d94e0f8,
		Nodes: []uint64{
			0x87f6d2196d414cf4,
			0x90d5073324ecc34b,
			0x983649d193295eae,
			0xa360d0951639b987,
			0xab79e1a6ecfeb87a,
			0xb374a1809b79340e,
			0xb438c10228b97446,
			0xbd820120399954be,
			0xc4dd3c458256382a,
			0xcc20b9c332c83b91,
			0xd5b0cec646441eb0,
			0xe67be4164a39ea55,
			0xeb3bcb770c8eb6be,
			0xef49df6cfa8875de,
			0xf192c7ee07114b32,
		},
		Compressed: true,
	})
}
