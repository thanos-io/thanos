// Copyright (c) The Thanos Authors.
// Licensed under the Apache License 2.0.

// Code generated by capnpc-go. DO NOT EDIT.

package writecapnp

import (
	context "context"
	math "math"
	strconv "strconv"

	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	fc "capnproto.org/go/capnp/v3/flowcontrol"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
)

type Symbols capnp.Struct

// Symbols_TypeID is the unique identifier for the type Symbols.
const Symbols_TypeID = 0xab79e1a6ecfeb87a

func NewSymbols(s *capnp.Segment) (Symbols, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Symbols(st), err
}

func NewRootSymbols(s *capnp.Segment) (Symbols, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Symbols(st), err
}

func ReadRootSymbols(msg *capnp.Message) (Symbols, error) {
	root, err := msg.Root()
	return Symbols(root.Struct()), err
}

func (s Symbols) String() string {
	str, _ := text.Marshal(0xab79e1a6ecfeb87a, capnp.Struct(s))
	return str
}

func (s Symbols) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Symbols) DecodeFromPtr(p capnp.Ptr) Symbols {
	return Symbols(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Symbols) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Symbols) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Symbols) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Symbols) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Symbols) Data() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Symbols) HasData() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Symbols) SetData(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

func (s Symbols) Offsets() (capnp.UInt32List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.UInt32List(p.List()), err
}

func (s Symbols) HasOffsets() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Symbols) SetOffsets(v capnp.UInt32List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewOffsets sets the offsets field to a newly
// allocated capnp.UInt32List, preferring placement in s's segment.
func (s Symbols) NewOffsets(n int32) (capnp.UInt32List, error) {
	l, err := capnp.NewUInt32List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.UInt32List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}

// Symbols_List is a list of Symbols.
type Symbols_List = capnp.StructList[Symbols]

// NewSymbols creates a new list of Symbols.
func NewSymbols_List(s *capnp.Segment, sz int32) (Symbols_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Symbols](l), err
}

// Symbols_Future is a wrapper for a Symbols promised by a client call.
type Symbols_Future struct{ *capnp.Future }

func (f Symbols_Future) Struct() (Symbols, error) {
	p, err := f.Future.Ptr()
	return Symbols(p.Struct()), err
}

type Label capnp.Struct

// Label_TypeID is the unique identifier for the type Label.
const Label_TypeID = 0xf192c7ee07114b32

func NewLabel(s *capnp.Segment) (Label, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Label(st), err
}

func NewRootLabel(s *capnp.Segment) (Label, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Label(st), err
}

func ReadRootLabel(msg *capnp.Message) (Label, error) {
	root, err := msg.Root()
	return Label(root.Struct()), err
}

func (s Label) String() string {
	str, _ := text.Marshal(0xf192c7ee07114b32, capnp.Struct(s))
	return str
}

func (s Label) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Label) DecodeFromPtr(p capnp.Ptr) Label {
	return Label(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Label) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Label) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Label) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Label) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Label) Name() uint32 {
	return capnp.Struct(s).Uint32(0)
}

func (s Label) SetName(v uint32) {
	capnp.Struct(s).SetUint32(0, v)
}

func (s Label) Value() uint32 {
	return capnp.Struct(s).Uint32(4)
}

func (s Label) SetValue(v uint32) {
	capnp.Struct(s).SetUint32(4, v)
}

// Label_List is a list of Label.
type Label_List = capnp.StructList[Label]

// NewLabel creates a new list of Label.
func NewLabel_List(s *capnp.Segment, sz int32) (Label_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[Label](l), err
}

// Label_Future is a wrapper for a Label promised by a client call.
type Label_Future struct{ *capnp.Future }

func (f Label_Future) Struct() (Label, error) {
	p, err := f.Future.Ptr()
	return Label(p.Struct()), err
}

type Sample capnp.Struct

// Sample_TypeID is the unique identifier for the type Sample.
const Sample_TypeID = 0xef49df6cfa8875de

func NewSample(s *capnp.Segment) (Sample, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Sample(st), err
}

func NewRootSample(s *capnp.Segment) (Sample, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Sample(st), err
}

func ReadRootSample(msg *capnp.Message) (Sample, error) {
	root, err := msg.Root()
	return Sample(root.Struct()), err
}

func (s Sample) String() string {
	str, _ := text.Marshal(0xef49df6cfa8875de, capnp.Struct(s))
	return str
}

func (s Sample) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Sample) DecodeFromPtr(p capnp.Ptr) Sample {
	return Sample(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Sample) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Sample) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Sample) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Sample) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Sample) Timestamp() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s Sample) SetTimestamp(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s Sample) Value() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Sample) SetValue(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

// Sample_List is a list of Sample.
type Sample_List = capnp.StructList[Sample]

// NewSample creates a new list of Sample.
func NewSample_List(s *capnp.Segment, sz int32) (Sample_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[Sample](l), err
}

// Sample_Future is a wrapper for a Sample promised by a client call.
type Sample_Future struct{ *capnp.Future }

func (f Sample_Future) Struct() (Sample, error) {
	p, err := f.Future.Ptr()
	return Sample(p.Struct()), err
}

type BucketSpan capnp.Struct

// BucketSpan_TypeID is the unique identifier for the type BucketSpan.
const BucketSpan_TypeID = 0x983649d193295eae

func NewBucketSpan(s *capnp.Segment) (BucketSpan, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return BucketSpan(st), err
}

func NewRootBucketSpan(s *capnp.Segment) (BucketSpan, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return BucketSpan(st), err
}

func ReadRootBucketSpan(msg *capnp.Message) (BucketSpan, error) {
	root, err := msg.Root()
	return BucketSpan(root.Struct()), err
}

func (s BucketSpan) String() string {
	str, _ := text.Marshal(0x983649d193295eae, capnp.Struct(s))
	return str
}

func (s BucketSpan) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (BucketSpan) DecodeFromPtr(p capnp.Ptr) BucketSpan {
	return BucketSpan(capnp.Struct{}.DecodeFromPtr(p))
}

func (s BucketSpan) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s BucketSpan) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s BucketSpan) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s BucketSpan) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s BucketSpan) Offset() int32 {
	return int32(capnp.Struct(s).Uint32(0))
}

func (s BucketSpan) SetOffset(v int32) {
	capnp.Struct(s).SetUint32(0, uint32(v))
}

func (s BucketSpan) Length() uint32 {
	return capnp.Struct(s).Uint32(4)
}

func (s BucketSpan) SetLength(v uint32) {
	capnp.Struct(s).SetUint32(4, v)
}

// BucketSpan_List is a list of BucketSpan.
type BucketSpan_List = capnp.StructList[BucketSpan]

// NewBucketSpan creates a new list of BucketSpan.
func NewBucketSpan_List(s *capnp.Segment, sz int32) (BucketSpan_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[BucketSpan](l), err
}

// BucketSpan_Future is a wrapper for a BucketSpan promised by a client call.
type BucketSpan_Future struct{ *capnp.Future }

func (f BucketSpan_Future) Struct() (BucketSpan, error) {
	p, err := f.Future.Ptr()
	return BucketSpan(p.Struct()), err
}

type Histogram capnp.Struct
type Histogram_count Histogram
type Histogram_zeroCount Histogram
type Histogram_count_Which uint16

const (
	Histogram_count_Which_countInt   Histogram_count_Which = 0
	Histogram_count_Which_countFloat Histogram_count_Which = 1
)

func (w Histogram_count_Which) String() string {
	const s = "countIntcountFloat"
	switch w {
	case Histogram_count_Which_countInt:
		return s[0:8]
	case Histogram_count_Which_countFloat:
		return s[8:18]

	}
	return "Histogram_count_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

type Histogram_zeroCount_Which uint16

const (
	Histogram_zeroCount_Which_zeroCountInt   Histogram_zeroCount_Which = 0
	Histogram_zeroCount_Which_zeroCountFloat Histogram_zeroCount_Which = 1
)

func (w Histogram_zeroCount_Which) String() string {
	const s = "zeroCountIntzeroCountFloat"
	switch w {
	case Histogram_zeroCount_Which_zeroCountInt:
		return s[0:12]
	case Histogram_zeroCount_Which_zeroCountFloat:
		return s[12:26]

	}
	return "Histogram_zeroCount_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Histogram_TypeID is the unique identifier for the type Histogram.
const Histogram_TypeID = 0xc4dd3c458256382a

func NewHistogram(s *capnp.Segment) (Histogram, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 56, PointerCount: 6})
	return Histogram(st), err
}

func NewRootHistogram(s *capnp.Segment) (Histogram, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 56, PointerCount: 6})
	return Histogram(st), err
}

func ReadRootHistogram(msg *capnp.Message) (Histogram, error) {
	root, err := msg.Root()
	return Histogram(root.Struct()), err
}

func (s Histogram) String() string {
	str, _ := text.Marshal(0xc4dd3c458256382a, capnp.Struct(s))
	return str
}

func (s Histogram) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Histogram) DecodeFromPtr(p capnp.Ptr) Histogram {
	return Histogram(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Histogram) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Histogram) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Histogram) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Histogram) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Histogram) Count() Histogram_count { return Histogram_count(s) }

func (s Histogram_count) Which() Histogram_count_Which {
	return Histogram_count_Which(capnp.Struct(s).Uint16(8))
}
func (s Histogram_count) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Histogram_count) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Histogram_count) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Histogram_count) CountInt() uint64 {
	if capnp.Struct(s).Uint16(8) != 0 {
		panic("Which() != countInt")
	}
	return capnp.Struct(s).Uint64(0)
}

func (s Histogram_count) SetCountInt(v uint64) {
	capnp.Struct(s).SetUint16(8, 0)
	capnp.Struct(s).SetUint64(0, v)
}

func (s Histogram_count) CountFloat() float64 {
	if capnp.Struct(s).Uint16(8) != 1 {
		panic("Which() != countFloat")
	}
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Histogram_count) SetCountFloat(v float64) {
	capnp.Struct(s).SetUint16(8, 1)
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Histogram) Sum() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s Histogram) SetSum(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

func (s Histogram) Schema() int32 {
	return int32(capnp.Struct(s).Uint32(12))
}

func (s Histogram) SetSchema(v int32) {
	capnp.Struct(s).SetUint32(12, uint32(v))
}

func (s Histogram) ZeroThreshold() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(24))
}

func (s Histogram) SetZeroThreshold(v float64) {
	capnp.Struct(s).SetUint64(24, math.Float64bits(v))
}

func (s Histogram) ZeroCount() Histogram_zeroCount { return Histogram_zeroCount(s) }

func (s Histogram_zeroCount) Which() Histogram_zeroCount_Which {
	return Histogram_zeroCount_Which(capnp.Struct(s).Uint16(10))
}
func (s Histogram_zeroCount) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Histogram_zeroCount) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Histogram_zeroCount) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Histogram_zeroCount) ZeroCountInt() uint64 {
	if capnp.Struct(s).Uint16(10) != 0 {
		panic("Which() != zeroCountInt")
	}
	return capnp.Struct(s).Uint64(32)
}

func (s Histogram_zeroCount) SetZeroCountInt(v uint64) {
	capnp.Struct(s).SetUint16(10, 0)
	capnp.Struct(s).SetUint64(32, v)
}

func (s Histogram_zeroCount) ZeroCountFloat() float64 {
	if capnp.Struct(s).Uint16(10) != 1 {
		panic("Which() != zeroCountFloat")
	}
	return math.Float64frombits(capnp.Struct(s).Uint64(32))
}

func (s Histogram_zeroCount) SetZeroCountFloat(v float64) {
	capnp.Struct(s).SetUint16(10, 1)
	capnp.Struct(s).SetUint64(32, math.Float64bits(v))
}

func (s Histogram) NegativeSpans() (BucketSpan_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return BucketSpan_List(p.List()), err
}

func (s Histogram) HasNegativeSpans() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Histogram) SetNegativeSpans(v BucketSpan_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewNegativeSpans sets the negativeSpans field to a newly
// allocated BucketSpan_List, preferring placement in s's segment.
func (s Histogram) NewNegativeSpans(n int32) (BucketSpan_List, error) {
	l, err := NewBucketSpan_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return BucketSpan_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Histogram) NegativeDeltas() (capnp.Int64List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.Int64List(p.List()), err
}

func (s Histogram) HasNegativeDeltas() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Histogram) SetNegativeDeltas(v capnp.Int64List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewNegativeDeltas sets the negativeDeltas field to a newly
// allocated capnp.Int64List, preferring placement in s's segment.
func (s Histogram) NewNegativeDeltas(n int32) (capnp.Int64List, error) {
	l, err := capnp.NewInt64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Int64List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s Histogram) NegativeCounts() (capnp.Float64List, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return capnp.Float64List(p.List()), err
}

func (s Histogram) HasNegativeCounts() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Histogram) SetNegativeCounts(v capnp.Float64List) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewNegativeCounts sets the negativeCounts field to a newly
// allocated capnp.Float64List, preferring placement in s's segment.
func (s Histogram) NewNegativeCounts(n int32) (capnp.Float64List, error) {
	l, err := capnp.NewFloat64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Float64List{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}
func (s Histogram) PositiveSpans() (BucketSpan_List, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return BucketSpan_List(p.List()), err
}

func (s Histogram) HasPositiveSpans() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Histogram) SetPositiveSpans(v BucketSpan_List) error {
	return capnp.Struct(s).SetPtr(3, v.ToPtr())
}

// NewPositiveSpans sets the positiveSpans field to a newly
// allocated BucketSpan_List, preferring placement in s's segment.
func (s Histogram) NewPositiveSpans(n int32) (BucketSpan_List, error) {
	l, err := NewBucketSpan_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return BucketSpan_List{}, err
	}
	err = capnp.Struct(s).SetPtr(3, l.ToPtr())
	return l, err
}
func (s Histogram) PositiveDeltas() (capnp.Int64List, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return capnp.Int64List(p.List()), err
}

func (s Histogram) HasPositiveDeltas() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s Histogram) SetPositiveDeltas(v capnp.Int64List) error {
	return capnp.Struct(s).SetPtr(4, v.ToPtr())
}

// NewPositiveDeltas sets the positiveDeltas field to a newly
// allocated capnp.Int64List, preferring placement in s's segment.
func (s Histogram) NewPositiveDeltas(n int32) (capnp.Int64List, error) {
	l, err := capnp.NewInt64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Int64List{}, err
	}
	err = capnp.Struct(s).SetPtr(4, l.ToPtr())
	return l, err
}
func (s Histogram) PositiveCounts() (capnp.Float64List, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return capnp.Float64List(p.List()), err
}

func (s Histogram) HasPositiveCounts() bool {
	return capnp.Struct(s).HasPtr(5)
}

func (s Histogram) SetPositiveCounts(v capnp.Float64List) error {
	return capnp.Struct(s).SetPtr(5, v.ToPtr())
}

// NewPositiveCounts sets the positiveCounts field to a newly
// allocated capnp.Float64List, preferring placement in s's segment.
func (s Histogram) NewPositiveCounts(n int32) (capnp.Float64List, error) {
	l, err := capnp.NewFloat64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Float64List{}, err
	}
	err = capnp.Struct(s).SetPtr(5, l.ToPtr())
	return l, err
}
func (s Histogram) ResetHint() Histogram_ResetHint {
	return Histogram_ResetHint(capnp.Struct(s).Uint16(40))
}

func (s Histogram) SetResetHint(v Histogram_ResetHint) {
	capnp.Struct(s).SetUint16(40, uint16(v))
}

func (s Histogram) Timestamp() int64 {
	return int64(capnp.Struct(s).Uint64(48))
}

func (s Histogram) SetTimestamp(v int64) {
	capnp.Struct(s).SetUint64(48, uint64(v))
}

// Histogram_List is a list of Histogram.
type Histogram_List = capnp.StructList[Histogram]

// NewHistogram creates a new list of Histogram.
func NewHistogram_List(s *capnp.Segment, sz int32) (Histogram_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 56, PointerCount: 6}, sz)
	return capnp.StructList[Histogram](l), err
}

// Histogram_Future is a wrapper for a Histogram promised by a client call.
type Histogram_Future struct{ *capnp.Future }

func (f Histogram_Future) Struct() (Histogram, error) {
	p, err := f.Future.Ptr()
	return Histogram(p.Struct()), err
}
func (p Histogram_Future) Count() Histogram_count_Future { return Histogram_count_Future{p.Future} }

// Histogram_count_Future is a wrapper for a Histogram_count promised by a client call.
type Histogram_count_Future struct{ *capnp.Future }

func (f Histogram_count_Future) Struct() (Histogram_count, error) {
	p, err := f.Future.Ptr()
	return Histogram_count(p.Struct()), err
}
func (p Histogram_Future) ZeroCount() Histogram_zeroCount_Future {
	return Histogram_zeroCount_Future{p.Future}
}

// Histogram_zeroCount_Future is a wrapper for a Histogram_zeroCount promised by a client call.
type Histogram_zeroCount_Future struct{ *capnp.Future }

func (f Histogram_zeroCount_Future) Struct() (Histogram_zeroCount, error) {
	p, err := f.Future.Ptr()
	return Histogram_zeroCount(p.Struct()), err
}

type Histogram_ResetHint uint16

// Histogram_ResetHint_TypeID is the unique identifier for the type Histogram_ResetHint.
const Histogram_ResetHint_TypeID = 0xd5b0cec646441eb0

// Values of Histogram_ResetHint.
const (
	Histogram_ResetHint_unknown Histogram_ResetHint = 0
	Histogram_ResetHint_yes     Histogram_ResetHint = 1
	Histogram_ResetHint_no      Histogram_ResetHint = 2
	Histogram_ResetHint_gauge   Histogram_ResetHint = 3
)

// String returns the enum's constant name.
func (c Histogram_ResetHint) String() string {
	switch c {
	case Histogram_ResetHint_unknown:
		return "unknown"
	case Histogram_ResetHint_yes:
		return "yes"
	case Histogram_ResetHint_no:
		return "no"
	case Histogram_ResetHint_gauge:
		return "gauge"

	default:
		return ""
	}
}

// Histogram_ResetHintFromString returns the enum value with a name,
// or the zero value if there's no such value.
func Histogram_ResetHintFromString(c string) Histogram_ResetHint {
	switch c {
	case "unknown":
		return Histogram_ResetHint_unknown
	case "yes":
		return Histogram_ResetHint_yes
	case "no":
		return Histogram_ResetHint_no
	case "gauge":
		return Histogram_ResetHint_gauge

	default:
		return 0
	}
}

type Histogram_ResetHint_List = capnp.EnumList[Histogram_ResetHint]

func NewHistogram_ResetHint_List(s *capnp.Segment, sz int32) (Histogram_ResetHint_List, error) {
	return capnp.NewEnumList[Histogram_ResetHint](s, sz)
}

type Exemplar capnp.Struct

// Exemplar_TypeID is the unique identifier for the type Exemplar.
const Exemplar_TypeID = 0xbd820120399954be

func NewExemplar(s *capnp.Segment) (Exemplar, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return Exemplar(st), err
}

func NewRootExemplar(s *capnp.Segment) (Exemplar, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return Exemplar(st), err
}

func ReadRootExemplar(msg *capnp.Message) (Exemplar, error) {
	root, err := msg.Root()
	return Exemplar(root.Struct()), err
}

func (s Exemplar) String() string {
	str, _ := text.Marshal(0xbd820120399954be, capnp.Struct(s))
	return str
}

func (s Exemplar) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Exemplar) DecodeFromPtr(p capnp.Ptr) Exemplar {
	return Exemplar(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Exemplar) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Exemplar) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Exemplar) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Exemplar) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Exemplar) Labels() (Label_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Label_List(p.List()), err
}

func (s Exemplar) HasLabels() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Exemplar) SetLabels(v Label_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLabels sets the labels field to a newly
// allocated Label_List, preferring placement in s's segment.
func (s Exemplar) NewLabels(n int32) (Label_List, error) {
	l, err := NewLabel_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Label_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Exemplar) Value() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Exemplar) SetValue(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Exemplar) Timestamp() int64 {
	return int64(capnp.Struct(s).Uint64(8))
}

func (s Exemplar) SetTimestamp(v int64) {
	capnp.Struct(s).SetUint64(8, uint64(v))
}

// Exemplar_List is a list of Exemplar.
type Exemplar_List = capnp.StructList[Exemplar]

// NewExemplar creates a new list of Exemplar.
func NewExemplar_List(s *capnp.Segment, sz int32) (Exemplar_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1}, sz)
	return capnp.StructList[Exemplar](l), err
}

// Exemplar_Future is a wrapper for a Exemplar promised by a client call.
type Exemplar_Future struct{ *capnp.Future }

func (f Exemplar_Future) Struct() (Exemplar, error) {
	p, err := f.Future.Ptr()
	return Exemplar(p.Struct()), err
}

type TimeSeries capnp.Struct

// TimeSeries_TypeID is the unique identifier for the type TimeSeries.
const TimeSeries_TypeID = 0xb438c10228b97446

func NewTimeSeries(s *capnp.Segment) (TimeSeries, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4})
	return TimeSeries(st), err
}

func NewRootTimeSeries(s *capnp.Segment) (TimeSeries, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4})
	return TimeSeries(st), err
}

func ReadRootTimeSeries(msg *capnp.Message) (TimeSeries, error) {
	root, err := msg.Root()
	return TimeSeries(root.Struct()), err
}

func (s TimeSeries) String() string {
	str, _ := text.Marshal(0xb438c10228b97446, capnp.Struct(s))
	return str
}

func (s TimeSeries) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (TimeSeries) DecodeFromPtr(p capnp.Ptr) TimeSeries {
	return TimeSeries(capnp.Struct{}.DecodeFromPtr(p))
}

func (s TimeSeries) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s TimeSeries) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s TimeSeries) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s TimeSeries) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s TimeSeries) Labels() (Label_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Label_List(p.List()), err
}

func (s TimeSeries) HasLabels() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s TimeSeries) SetLabels(v Label_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLabels sets the labels field to a newly
// allocated Label_List, preferring placement in s's segment.
func (s TimeSeries) NewLabels(n int32) (Label_List, error) {
	l, err := NewLabel_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Label_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s TimeSeries) Samples() (Sample_List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Sample_List(p.List()), err
}

func (s TimeSeries) HasSamples() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s TimeSeries) SetSamples(v Sample_List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewSamples sets the samples field to a newly
// allocated Sample_List, preferring placement in s's segment.
func (s TimeSeries) NewSamples(n int32) (Sample_List, error) {
	l, err := NewSample_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Sample_List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s TimeSeries) Histograms() (Histogram_List, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return Histogram_List(p.List()), err
}

func (s TimeSeries) HasHistograms() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s TimeSeries) SetHistograms(v Histogram_List) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewHistograms sets the histograms field to a newly
// allocated Histogram_List, preferring placement in s's segment.
func (s TimeSeries) NewHistograms(n int32) (Histogram_List, error) {
	l, err := NewHistogram_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Histogram_List{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}
func (s TimeSeries) Exemplars() (Exemplar_List, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return Exemplar_List(p.List()), err
}

func (s TimeSeries) HasExemplars() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s TimeSeries) SetExemplars(v Exemplar_List) error {
	return capnp.Struct(s).SetPtr(3, v.ToPtr())
}

// NewExemplars sets the exemplars field to a newly
// allocated Exemplar_List, preferring placement in s's segment.
func (s TimeSeries) NewExemplars(n int32) (Exemplar_List, error) {
	l, err := NewExemplar_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Exemplar_List{}, err
	}
	err = capnp.Struct(s).SetPtr(3, l.ToPtr())
	return l, err
}

// TimeSeries_List is a list of TimeSeries.
type TimeSeries_List = capnp.StructList[TimeSeries]

// NewTimeSeries creates a new list of TimeSeries.
func NewTimeSeries_List(s *capnp.Segment, sz int32) (TimeSeries_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4}, sz)
	return capnp.StructList[TimeSeries](l), err
}

// TimeSeries_Future is a wrapper for a TimeSeries promised by a client call.
type TimeSeries_Future struct{ *capnp.Future }

func (f TimeSeries_Future) Struct() (TimeSeries, error) {
	p, err := f.Future.Ptr()
	return TimeSeries(p.Struct()), err
}

type WriteRequest capnp.Struct

// WriteRequest_TypeID is the unique identifier for the type WriteRequest.
const WriteRequest_TypeID = 0xeb3bcb770c8eb6be

func NewWriteRequest(s *capnp.Segment) (WriteRequest, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return WriteRequest(st), err
}

func NewRootWriteRequest(s *capnp.Segment) (WriteRequest, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return WriteRequest(st), err
}

func ReadRootWriteRequest(msg *capnp.Message) (WriteRequest, error) {
	root, err := msg.Root()
	return WriteRequest(root.Struct()), err
}

func (s WriteRequest) String() string {
	str, _ := text.Marshal(0xeb3bcb770c8eb6be, capnp.Struct(s))
	return str
}

func (s WriteRequest) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (WriteRequest) DecodeFromPtr(p capnp.Ptr) WriteRequest {
	return WriteRequest(capnp.Struct{}.DecodeFromPtr(p))
}

func (s WriteRequest) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s WriteRequest) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s WriteRequest) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s WriteRequest) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s WriteRequest) Symbols() (Symbols, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Symbols(p.Struct()), err
}

func (s WriteRequest) HasSymbols() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s WriteRequest) SetSymbols(v Symbols) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewSymbols sets the symbols field to a newly
// allocated Symbols struct, preferring placement in s's segment.
func (s WriteRequest) NewSymbols() (Symbols, error) {
	ss, err := NewSymbols(capnp.Struct(s).Segment())
	if err != nil {
		return Symbols{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s WriteRequest) TimeSeries() (TimeSeries_List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return TimeSeries_List(p.List()), err
}

func (s WriteRequest) HasTimeSeries() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s WriteRequest) SetTimeSeries(v TimeSeries_List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewTimeSeries sets the timeSeries field to a newly
// allocated TimeSeries_List, preferring placement in s's segment.
func (s WriteRequest) NewTimeSeries(n int32) (TimeSeries_List, error) {
	l, err := NewTimeSeries_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return TimeSeries_List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s WriteRequest) Tenant() (string, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.Text(), err
}

func (s WriteRequest) HasTenant() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s WriteRequest) TenantBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.TextBytes(), err
}

func (s WriteRequest) SetTenant(v string) error {
	return capnp.Struct(s).SetText(2, v)
}

// WriteRequest_List is a list of WriteRequest.
type WriteRequest_List = capnp.StructList[WriteRequest]

// NewWriteRequest creates a new list of WriteRequest.
func NewWriteRequest_List(s *capnp.Segment, sz int32) (WriteRequest_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return capnp.StructList[WriteRequest](l), err
}

// WriteRequest_Future is a wrapper for a WriteRequest promised by a client call.
type WriteRequest_Future struct{ *capnp.Future }

func (f WriteRequest_Future) Struct() (WriteRequest, error) {
	p, err := f.Future.Ptr()
	return WriteRequest(p.Struct()), err
}
func (p WriteRequest_Future) Symbols() Symbols_Future {
	return Symbols_Future{Future: p.Future.Field(0, nil)}
}

type WriteError uint16

// WriteError_TypeID is the unique identifier for the type WriteError.
const WriteError_TypeID = 0xe67be4164a39ea55

// Values of WriteError.
const (
	WriteError_none            WriteError = 0
	WriteError_unavailable     WriteError = 1
	WriteError_alreadyExists   WriteError = 2
	WriteError_invalidArgument WriteError = 3
	WriteError_internal        WriteError = 4
)

// String returns the enum's constant name.
func (c WriteError) String() string {
	switch c {
	case WriteError_none:
		return "none"
	case WriteError_unavailable:
		return "unavailable"
	case WriteError_alreadyExists:
		return "alreadyExists"
	case WriteError_invalidArgument:
		return "invalidArgument"
	case WriteError_internal:
		return "internal"

	default:
		return ""
	}
}

// WriteErrorFromString returns the enum value with a name,
// or the zero value if there's no such value.
func WriteErrorFromString(c string) WriteError {
	switch c {
	case "none":
		return WriteError_none
	case "unavailable":
		return WriteError_unavailable
	case "alreadyExists":
		return WriteError_alreadyExists
	case "invalidArgument":
		return WriteError_invalidArgument
	case "internal":
		return WriteError_internal

	default:
		return 0
	}
}

type WriteError_List = capnp.EnumList[WriteError]

func NewWriteError_List(s *capnp.Segment, sz int32) (WriteError_List, error) {
	return capnp.NewEnumList[WriteError](s, sz)
}

type Writer capnp.Client

// Writer_TypeID is the unique identifier for the type Writer.
const Writer_TypeID = 0xcc20b9c332c83b91

func (c Writer) Write(ctx context.Context, params func(Writer_write_Params) error) (Writer_write_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xcc20b9c332c83b91,
			MethodID:      0,
			InterfaceName: "pkg/receive/writecapnp/write_request.capnp:Writer",
			MethodName:    "write",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Writer_write_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Writer_write_Results_Future{Future: ans.Future()}, release

}

func (c Writer) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Writer) String() string {
	return "Writer(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Writer) AddRef() Writer {
	return Writer(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Writer) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Writer) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Writer) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Writer) DecodeFromPtr(p capnp.Ptr) Writer {
	return Writer(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Writer) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Writer) IsSame(other Writer) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Writer) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Writer) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Writer_Server is a Writer with a local implementation.
type Writer_Server interface {
	Write(context.Context, Writer_write) error
}

// Writer_NewServer creates a new Server from an implementation of Writer_Server.
func Writer_NewServer(s Writer_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Writer_Methods(nil, s), s, c)
}

// Writer_ServerToClient creates a new Client from an implementation of Writer_Server.
// The caller is responsible for calling Release on the returned Client.
func Writer_ServerToClient(s Writer_Server) Writer {
	return Writer(capnp.NewClient(Writer_NewServer(s)))
}

// Writer_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Writer_Methods(methods []server.Method, s Writer_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xcc20b9c332c83b91,
			MethodID:      0,
			InterfaceName: "pkg/receive/writecapnp/write_request.capnp:Writer",
			MethodName:    "write",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Write(ctx, Writer_write{call})
		},
	})

	return methods
}

// Writer_write holds the state for a server call to Writer.write.
// See server.Call for documentation.
type Writer_write struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Writer_write) Args() Writer_write_Params {
	return Writer_write_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Writer_write) AllocResults() (Writer_write_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Writer_write_Results(r), err
}

// Writer_List is a list of Writer.
type Writer_List = capnp.CapList[Writer]

// NewWriter_List creates a new list of Writer.
func NewWriter_List(s *capnp.Segment, sz int32) (Writer_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Writer](l), err
}

type Writer_write_Params capnp.Struct

// Writer_write_Params_TypeID is the unique identifier for the type Writer_write_Params.
const Writer_write_Params_TypeID = 0x90d5073324ecc34b

func NewWriter_write_Params(s *capnp.Segment) (Writer_write_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Writer_write_Params(st), err
}

func NewRootWriter_write_Params(s *capnp.Segment) (Writer_write_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Writer_write_Params(st), err
}

func ReadRootWriter_write_Params(msg *capnp.Message) (Writer_write_Params, error) {
	root, err := msg.Root()
	return Writer_write_Params(root.Struct()), err
}

func (s Writer_write_Params) String() string {
	str, _ := text.Marshal(0x90d5073324ecc34b, capnp.Struct(s))
	return str
}

func (s Writer_write_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Writer_write_Params) DecodeFromPtr(p capnp.Ptr) Writer_write_Params {
	return Writer_write_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Writer_write_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Writer_write_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Writer_write_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Writer_write_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Writer_write_Params) Wr() (WriteRequest, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return WriteRequest(p.Struct()), err
}

func (s Writer_write_Params) HasWr() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Writer_write_Params) SetWr(v WriteRequest) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewWr sets the wr field to a newly
// allocated WriteRequest struct, preferring placement in s's segment.
func (s Writer_write_Params) NewWr() (WriteRequest, error) {
	ss, err := NewWriteRequest(capnp.Struct(s).Segment())
	if err != nil {
		return WriteRequest{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Writer_write_Params_List is a list of Writer_write_Params.
type Writer_write_Params_List = capnp.StructList[Writer_write_Params]

// NewWriter_write_Params creates a new list of Writer_write_Params.
func NewWriter_write_Params_List(s *capnp.Segment, sz int32) (Writer_write_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Writer_write_Params](l), err
}

// Writer_write_Params_Future is a wrapper for a Writer_write_Params promised by a client call.
type Writer_write_Params_Future struct{ *capnp.Future }

func (f Writer_write_Params_Future) Struct() (Writer_write_Params, error) {
	p, err := f.Future.Ptr()
	return Writer_write_Params(p.Struct()), err
}
func (p Writer_write_Params_Future) Wr() WriteRequest_Future {
	return WriteRequest_Future{Future: p.Future.Field(0, nil)}
}

type Writer_write_Results capnp.Struct

// Writer_write_Results_TypeID is the unique identifier for the type Writer_write_Results.
const Writer_write_Results_TypeID = 0x87f6d2196d414cf4

func NewWriter_write_Results(s *capnp.Segment) (Writer_write_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Writer_write_Results(st), err
}

func NewRootWriter_write_Results(s *capnp.Segment) (Writer_write_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Writer_write_Results(st), err
}

func ReadRootWriter_write_Results(msg *capnp.Message) (Writer_write_Results, error) {
	root, err := msg.Root()
	return Writer_write_Results(root.Struct()), err
}

func (s Writer_write_Results) String() string {
	str, _ := text.Marshal(0x87f6d2196d414cf4, capnp.Struct(s))
	return str
}

func (s Writer_write_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Writer_write_Results) DecodeFromPtr(p capnp.Ptr) Writer_write_Results {
	return Writer_write_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Writer_write_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Writer_write_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Writer_write_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Writer_write_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Writer_write_Results) Error() WriteError {
	return WriteError(capnp.Struct(s).Uint16(0))
}

func (s Writer_write_Results) SetError(v WriteError) {
	capnp.Struct(s).SetUint16(0, uint16(v))
}

func (s Writer_write_Results) ExtraErrorContext() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Writer_write_Results) HasExtraErrorContext() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Writer_write_Results) ExtraErrorContextBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Writer_write_Results) SetExtraErrorContext(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// Writer_write_Results_List is a list of Writer_write_Results.
type Writer_write_Results_List = capnp.StructList[Writer_write_Results]

// NewWriter_write_Results creates a new list of Writer_write_Results.
func NewWriter_write_Results_List(s *capnp.Segment, sz int32) (Writer_write_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[Writer_write_Results](l), err
}

// Writer_write_Results_Future is a wrapper for a Writer_write_Results promised by a client call.
type Writer_write_Results_Future struct{ *capnp.Future }

func (f Writer_write_Results_Future) Struct() (Writer_write_Results, error) {
	p, err := f.Future.Ptr()
	return Writer_write_Results(p.Struct()), err
}

const schema_85d3acc39d94e0f8 = "x\xda\xa4V}\x88\x1cg\x19\x7f~\xef;\xbbs\xe9" +
	"\xee\xe6n\x98\xa5\xd2\xa2nSRhr&M\xee\x12" +
	"I\xd2\xc2\xe6\xd2\\\xcc\xa5W\xb8\xd9M\xb4\x95D;" +
	"\xb9{{\xb7fvv;3{_\xfeq\x1a\x08M" +
	"\xa5\xf8\x11\x15\xacRh\xb4\x0a~\xa0%\x8a\xf4\xa0\x0a" +
	"1~\x81V\x1a5`\xc4Z\x85\xa2\xa8U)\x88h" +
	"\xc0\x8c<\xef\xee\xcd\x8c\xe7\x89\xb9\xf4\xbf\xdd\xdf\xfc\xe6" +
	"\xf9\xf8=\xcf<\xcf\xb3\xa3`\xec7v\x96>\x92'" +
	"\xe1\x8c\xe7\xf2\xf1\xdf\xc6G\x9a\xb7\xfd\xf4\xef\x8f\x933" +
	"\x04\x10\xe5`\x12\x0do\x93B\x10\xec\x119G\x88\x1f" +
	"\xb8\xf4\xda\xe6a\xf3\xcaG\xc9\x1aJ\x08\x9f\x97\xd7@" +
	"\xb0\x97e\x95\x10\x7f\xf5=[>~y\xec\xed\x9f\"" +
	"g\x10\x88\xff\xf1\x9bO<}\xe9+?;C\x06\x13" +
	"\xaf\xca\x0b\xb0_\x97&\x91\xfdgm\xed\xf1\xe5\xbd\xb7" +
	"~\xf2\xa5G>G\xcen\x98\xf1\xd6=\xef<=z" +
	"\xdf\xcb\xdf\xa5cy\x13\x02\xc6\xf0\x98\xf1K6|\xc2" +
	"`\xee\xe2\xf3\xd7_\xfb\xc2o\x17\xbeL\xd6`\xc6n" +
	"N\xb0\xe1\x8b\xc6\xa7a_e\x1f\xf6\x15M\xde\xb8k" +
	"\xe13\x1f8\x1f}}M\xc3\xb9\xe1\x91\x9c\x8e\xf8X" +
	"\x8e\xb9\x87\xa2\xe5\xbb\xc5\xc5=\xdfXeXG\xbc\x9c" +
	"\xbb\x00\xfbr\x8e\x0d\xbf\x98\xfb=!\xfe\xf6\xd1\xa7\xf6" +
	"\xde\x81\xd3\xdf\xe2\xf4D\x86\xad\x85\xf8C\xfe\xb3\xb0a" +
	"2\xfb_\xf9\xaf\x11R\xc7\xce \xcc\x0c;\xcf\xec/" +
	"\x9a_\x82}\xd1|\x13\xd1\xf0\x8b\xe6+\x82\x10\x7f\xec" +
	"\xde\x1f\x0e]Z\xbe\xe3\xc7d\x0d\xca\x94M\x18.\x15" +
	"\xce\xc1\xbe\xab\xc0\x867\x15\xdea\x8f\xf1\xaf\xf8\xb9\xb7" +
	"\x1e<\xf4\xfd\x9f<w\x85\xac\xdd\"\xf5D\x18\xdeY" +
	"\xb8\x06\xfbA\xcd\x1e+L\x13\xe2c\x7f\xdc{\xe4\xd6" +
	"W\xdf\xff;\xb2\x06\xc5\x7f\xd8m\x16.\xc0>\xa3\x99" +
	"\x1f,,qz\xdf\xfcpq\xeeG\xf7\xfei\x95\x16" +
	"\\\xb2\xe1\xef\x15\xbe\x03\xfbeM\xbeZ\xe0\xec~\xdd" +
	"9{\xcd{e\xec\xaf\xab\xb4\xd0\xc2\x9d)\x9e\x83\xfd" +
	"t\x91\xc9O\x15Y\xe5\xa1\x07,\xf3/?8\xf7\xfa" +
	"Z}\xf1\xcf\xe2\x87`[%&\x97Js\xb4-n" +
	"\x9f\x9a\xbe'P\x93\xcal\xcc\xaa{\xe6\x82F\xa4&" +
	"\xdd\xb6\xdf\xee\xfe|o\xa0\x1e\xeb\xa80\xda\xae\xb1}" +
	"\xefb,\xd8\xae\x1fm\xae\xa9\xb0\xe3E!9}\xd2" +
	" 2@dm\x19\"r6K8;\x04\x802\xf7" +
	"\xb5\xb5\xed\x1c\x91\xb3C\xc2\xb9O\xa0\xa2\x82\xa0\x15\xa0" +
	"?U\x89\x80~B\xac\xe6\xa3\xc0\x1d\x0d\x02\xb4\x82\xfb" +
	"[~\xa4\xe6\x11\xa1H\x02EB\x12`~\xbd\x01V" +
	"'\xdc\xc0m\x86\x8e\x91\xc4W\xba\x9d8\\8e\x01" +
	"9\x17` -\x02\x01\x03\x19g\xb9\x1bpv\xa03" +
	"yJU\xa2z\xdb\xf5'\x80\xac\x0c\xfbR\x19\xacD" +
	"\x07\x06\xef\x96pv\x09T[\x8f>\x1a\xaa\x08\x06\x09" +
	"\x18\x84\xaa\xa7\xfc\xe9h\x06}$\xd0\xb7\xce\x8c\x0f7" +
	"\xc2\xa85\x1d\xb8\xcd\xed\x93\xad\x8e\xf4#\x0e\xa3\x18\xc7" +
	"\xdd8\x8e\xa4.K\xb8\x1ew\x03\xd9\xf9\xee\xb4 \xf1" +
	"d\xab\xe3Gc~DD\xd8@\x02\x1b\xa8\x87\x1d\xf2" +
	"Z$\xdd\x08\x05\x12(\xacS\x98\xfaB\xf3dKz" +
	"\xe1*U\xb6\xae\xa5\xca\x81^\x88\x07\x05\xfa\xa7\xdc\xc8" +
	"E\x89\x04J\x84\xa5\xaeD!6\x12&$\xb46\x1b" +
	"oZ\x9bE\x15T[\xf7s^\x1c\xd0\x9b\xe3\xd8(" +
	"#\xc71\xbd/U\xe8-\xb8\xcep\x9e%Z\xccH" +
	"\xb4\xa8\x02\xfd*\xf5\xb3P\x89J\x09\\e\xadnR" +
	"\xa9\xa3\x8d\xa6\xaaWT\xd0PZ\xac\x81D,\x97\xbb" +
	"\xe5\xb8\x843\x9f\x11\xab\xc3b\xb5%\x9c'\x05,!" +
	"\xca\x10D\xd6\x13\\\xce\xb3\x12\xce\xb3\x02\x96\x94eH" +
	"\"\xeb|\x8d\xc8yF\xc2yA\xa0\xea\xb9'\x95\x97" +
	"\x089\x90\x8e\x07\x02\x83K\xa1\xdbl{*CH\x86" +
	"M\x97\x10\xcf\xf4t$\xd9\xcc\xb02cP\xb3\xd4\xbc" +
	"j\xb6=7 dH\xc9\x0c\xef\x91\xd6#\xce(\x1b" +
	"4=7`i\x8a\x894\xa3,\xcd~\x09\xe7x:" +
	"d\x1e\xe6\xc1sT\xc2y\x84\x95AW\x99\x13\xb5\x9e" +
	"\x863\xff_\x84\xca\xac\xebuTR\xc3\xa8\xd1Ta" +
	"\xe46\x09m\xe4H \xb7\xce\xd0u\xe7\xf5s\xeb9" +
	"\x06\x90Y\x1f\xa8\xc55\x15\xaa\xe8p\xc3'D\xce." +
	"\xce\x0a\x99\xe5l\x9f\xc0\x10\x09\x0b\xdd\xe2\xda\xa3\xb8\x93" +
	"\xa8\xbe\x1f\x12\xf5qpj\xdd\xfa\xdac\xd8GT?" +
	"\xc8\xf8\x04zu7\x88\xec\x07\x11\x10\xd5\xc7\x19\x7f\x08" +
	"\x02`\xe7\xc9~\xb6\x8f\xa1\xc6\xb9\x94y\x81\xda#\x9a" +
	"\xaaM\x1fg\x13y\x94\xd1Gd?\x8cE\xa2\xfaC" +
	"\x8cG\x8c\x9b\xa2\x8c\x0dD\xf6c\x1ao3\xfe$\xe3" +
	"}\xb2\x8c[\x88\xec'\xb4\x9d\xb3\x8c?\xcb\xf8\x06\xa3" +
	"\x8c\x02\x91}^\xf3\x9fa\xfc\x05\xc6o\xc9\x95Q$" +
	"\xb2\x975\xfe<\xe3?g\xbcP.\xa3Dd_F" +
	"\x8d\xa8\xfe\x12\xe3\xbfb\xbc\x98/c#\xef?\x8d\xff" +
	"\x82\xf1W!P\xd1\xd3\xc9\x0c;\xcd\x95bU\xc3\xc9" +
	"\x19\xd5tW\x86\xa9\xfe0\x8f\xce\x04\x8a*\xe1L\xcb" +
	"\x9bJj\x9a|\xb0\x88b_M\xbbQcVQ\x85" +
	"\xa7w\xa6-\x92\x93\xaa\xd7\xaf\x09\xb1zPy\x91\x9b" +
	"0s\xbdq\x94>\xd7\xd3%y^X\x19W\xad\xb0" +
	"qC\x8e\x12\xe2\xffp\x94>_\xdbQ\x90v\x15\xfa" +
	"\xd3\x86\xeb\xed\xd77\xda\xcfz\xafB\x7f\x88\x86\xcc\x11" +
	"%\xb7)V\xceX\xcb\xe2\xbe\xcd\x99\x15\xfd\xfa~L" +
	"\xe0fguM\x85U\x9dJ\xa4G\xa2\xfe\x94\xb7\x1c" +
	"\xe0L\xacMw\x12AX\xb7\xddN\x04\xc9\x1ei\xa9" +
	"\xe3\x9f\xf2[s\xbe\xb9\xa0B\xe9\xb7*\xd3ngZ" +
	"\xad?\xb5\xca(\x1f&\xec\xaf;:vo\xd5\xfe\xb6" +
	"\x9d\xd4\xfe\xb6\x04\xda\xdf]\xa7\x89`X\x9b\x8e\x10\xf5" +
	"\xfb-_\xc5\x1d\xdf\x9du\x1b\x9eK\xe6IO\xc5\xae" +
	"\x17(wja\x94*\xf3\x8d0\x0a\xe3\x86?\xebz" +
	"\x8d\xa9\x11\x11Lw\x9a\xca\x8f\xa8\xe1G*\xf0]\x8f" +
	"h\xfd7M\xad\x0b\xd1\xaaQx\xa07\x0a\xc73[" +
	"b\x8c\x17\xc2a\x09g*\xb3%\x92}2#\xb0\x14" +
	"\xf2~\xf6B\x0c\xa4\x87~\xef\xfc\xe1>\xa9\xab\xa0A" +
	"2\xbb\x0f\x92\xab\xbd\xdb\xab\xd5H\xf9\xae\xff\xdf\x07\xda" +
	"\x0d\x9d\x06\xbck\xa0V]\x06\xb5t\x0b'i\xec\xe4" +
	"\x91\xfe6\x09g\x8fX\xb3\x7fWM\xec\xf5\x041\xce" +
	"\xbb\x80\xe8F\xce\x93\xa14\xb2~\xdfm\xaa\x95\x1b\xad" +
	"\xe7\xbd\xf7\xef\xdf\x01\x00\x00\xff\xff\xd0c\xba\xdb"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_85d3acc39d94e0f8,
		Nodes: []uint64{
			0x87f6d2196d414cf4,
			0x90d5073324ecc34b,
			0x983649d193295eae,
			0xa360d0951639b987,
			0xab79e1a6ecfeb87a,
			0xb374a1809b79340e,
			0xb438c10228b97446,
			0xbd820120399954be,
			0xc4dd3c458256382a,
			0xcc20b9c332c83b91,
			0xd5b0cec646441eb0,
			0xe67be4164a39ea55,
			0xeb3bcb770c8eb6be,
			0xef49df6cfa8875de,
			0xf192c7ee07114b32,
		},
		Compressed: true,
	})
}
