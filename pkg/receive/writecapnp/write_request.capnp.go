// Copyright (c) The Thanos Authors.
// Licensed under the Apache License 2.0.

// Code generated by capnpc-go. DO NOT EDIT.

package writecapnp

import (
	context "context"
	math "math"
	strconv "strconv"

	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	fc "capnproto.org/go/capnp/v3/flowcontrol"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
)

type Symbols capnp.Struct

// Symbols_TypeID is the unique identifier for the type Symbols.
const Symbols_TypeID = 0xab79e1a6ecfeb87a

func NewSymbols(s *capnp.Segment) (Symbols, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Symbols(st), err
}

func NewRootSymbols(s *capnp.Segment) (Symbols, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Symbols(st), err
}

func ReadRootSymbols(msg *capnp.Message) (Symbols, error) {
	root, err := msg.Root()
	return Symbols(root.Struct()), err
}

func (s Symbols) String() string {
	str, _ := text.Marshal(0xab79e1a6ecfeb87a, capnp.Struct(s))
	return str
}

func (s Symbols) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Symbols) DecodeFromPtr(p capnp.Ptr) Symbols {
	return Symbols(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Symbols) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Symbols) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Symbols) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Symbols) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Symbols) Data() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Symbols) HasData() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Symbols) SetData(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

func (s Symbols) Offsets() (capnp.UInt32List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.UInt32List(p.List()), err
}

func (s Symbols) HasOffsets() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Symbols) SetOffsets(v capnp.UInt32List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewOffsets sets the offsets field to a newly
// allocated capnp.UInt32List, preferring placement in s's segment.
func (s Symbols) NewOffsets(n int32) (capnp.UInt32List, error) {
	l, err := capnp.NewUInt32List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.UInt32List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}

// Symbols_List is a list of Symbols.
type Symbols_List = capnp.StructList[Symbols]

// NewSymbols creates a new list of Symbols.
func NewSymbols_List(s *capnp.Segment, sz int32) (Symbols_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Symbols](l), err
}

// Symbols_Future is a wrapper for a Symbols promised by a client call.
type Symbols_Future struct{ *capnp.Future }

func (f Symbols_Future) Struct() (Symbols, error) {
	p, err := f.Future.Ptr()
	return Symbols(p.Struct()), err
}

type Label capnp.Struct

// Label_TypeID is the unique identifier for the type Label.
const Label_TypeID = 0xf192c7ee07114b32

func NewLabel(s *capnp.Segment) (Label, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Label(st), err
}

func NewRootLabel(s *capnp.Segment) (Label, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Label(st), err
}

func ReadRootLabel(msg *capnp.Message) (Label, error) {
	root, err := msg.Root()
	return Label(root.Struct()), err
}

func (s Label) String() string {
	str, _ := text.Marshal(0xf192c7ee07114b32, capnp.Struct(s))
	return str
}

func (s Label) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Label) DecodeFromPtr(p capnp.Ptr) Label {
	return Label(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Label) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Label) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Label) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Label) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Label) Name() uint32 {
	return capnp.Struct(s).Uint32(0)
}

func (s Label) SetName(v uint32) {
	capnp.Struct(s).SetUint32(0, v)
}

func (s Label) Value() uint32 {
	return capnp.Struct(s).Uint32(4)
}

func (s Label) SetValue(v uint32) {
	capnp.Struct(s).SetUint32(4, v)
}

// Label_List is a list of Label.
type Label_List = capnp.StructList[Label]

// NewLabel creates a new list of Label.
func NewLabel_List(s *capnp.Segment, sz int32) (Label_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[Label](l), err
}

// Label_Future is a wrapper for a Label promised by a client call.
type Label_Future struct{ *capnp.Future }

func (f Label_Future) Struct() (Label, error) {
	p, err := f.Future.Ptr()
	return Label(p.Struct()), err
}

type Sample capnp.Struct

// Sample_TypeID is the unique identifier for the type Sample.
const Sample_TypeID = 0xef49df6cfa8875de

func NewSample(s *capnp.Segment) (Sample, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Sample(st), err
}

func NewRootSample(s *capnp.Segment) (Sample, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return Sample(st), err
}

func ReadRootSample(msg *capnp.Message) (Sample, error) {
	root, err := msg.Root()
	return Sample(root.Struct()), err
}

func (s Sample) String() string {
	str, _ := text.Marshal(0xef49df6cfa8875de, capnp.Struct(s))
	return str
}

func (s Sample) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Sample) DecodeFromPtr(p capnp.Ptr) Sample {
	return Sample(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Sample) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Sample) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Sample) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Sample) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Sample) Timestamp() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s Sample) SetTimestamp(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s Sample) Value() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Sample) SetValue(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

// Sample_List is a list of Sample.
type Sample_List = capnp.StructList[Sample]

// NewSample creates a new list of Sample.
func NewSample_List(s *capnp.Segment, sz int32) (Sample_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[Sample](l), err
}

// Sample_Future is a wrapper for a Sample promised by a client call.
type Sample_Future struct{ *capnp.Future }

func (f Sample_Future) Struct() (Sample, error) {
	p, err := f.Future.Ptr()
	return Sample(p.Struct()), err
}

type BucketSpan capnp.Struct

// BucketSpan_TypeID is the unique identifier for the type BucketSpan.
const BucketSpan_TypeID = 0x983649d193295eae

func NewBucketSpan(s *capnp.Segment) (BucketSpan, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return BucketSpan(st), err
}

func NewRootBucketSpan(s *capnp.Segment) (BucketSpan, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return BucketSpan(st), err
}

func ReadRootBucketSpan(msg *capnp.Message) (BucketSpan, error) {
	root, err := msg.Root()
	return BucketSpan(root.Struct()), err
}

func (s BucketSpan) String() string {
	str, _ := text.Marshal(0x983649d193295eae, capnp.Struct(s))
	return str
}

func (s BucketSpan) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (BucketSpan) DecodeFromPtr(p capnp.Ptr) BucketSpan {
	return BucketSpan(capnp.Struct{}.DecodeFromPtr(p))
}

func (s BucketSpan) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s BucketSpan) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s BucketSpan) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s BucketSpan) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s BucketSpan) Offset() int32 {
	return int32(capnp.Struct(s).Uint32(0))
}

func (s BucketSpan) SetOffset(v int32) {
	capnp.Struct(s).SetUint32(0, uint32(v))
}

func (s BucketSpan) Length() uint32 {
	return capnp.Struct(s).Uint32(4)
}

func (s BucketSpan) SetLength(v uint32) {
	capnp.Struct(s).SetUint32(4, v)
}

// BucketSpan_List is a list of BucketSpan.
type BucketSpan_List = capnp.StructList[BucketSpan]

// NewBucketSpan creates a new list of BucketSpan.
func NewBucketSpan_List(s *capnp.Segment, sz int32) (BucketSpan_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[BucketSpan](l), err
}

// BucketSpan_Future is a wrapper for a BucketSpan promised by a client call.
type BucketSpan_Future struct{ *capnp.Future }

func (f BucketSpan_Future) Struct() (BucketSpan, error) {
	p, err := f.Future.Ptr()
	return BucketSpan(p.Struct()), err
}

type Histogram capnp.Struct
type Histogram_count Histogram
type Histogram_zeroCount Histogram
type Histogram_count_Which uint16

const (
	Histogram_count_Which_countInt   Histogram_count_Which = 0
	Histogram_count_Which_countFloat Histogram_count_Which = 1
)

func (w Histogram_count_Which) String() string {
	const s = "countIntcountFloat"
	switch w {
	case Histogram_count_Which_countInt:
		return s[0:8]
	case Histogram_count_Which_countFloat:
		return s[8:18]

	}
	return "Histogram_count_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

type Histogram_zeroCount_Which uint16

const (
	Histogram_zeroCount_Which_zeroCountInt   Histogram_zeroCount_Which = 0
	Histogram_zeroCount_Which_zeroCountFloat Histogram_zeroCount_Which = 1
)

func (w Histogram_zeroCount_Which) String() string {
	const s = "zeroCountIntzeroCountFloat"
	switch w {
	case Histogram_zeroCount_Which_zeroCountInt:
		return s[0:12]
	case Histogram_zeroCount_Which_zeroCountFloat:
		return s[12:26]

	}
	return "Histogram_zeroCount_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Histogram_TypeID is the unique identifier for the type Histogram.
const Histogram_TypeID = 0xc4dd3c458256382a

func NewHistogram(s *capnp.Segment) (Histogram, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 56, PointerCount: 6})
	return Histogram(st), err
}

func NewRootHistogram(s *capnp.Segment) (Histogram, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 56, PointerCount: 6})
	return Histogram(st), err
}

func ReadRootHistogram(msg *capnp.Message) (Histogram, error) {
	root, err := msg.Root()
	return Histogram(root.Struct()), err
}

func (s Histogram) String() string {
	str, _ := text.Marshal(0xc4dd3c458256382a, capnp.Struct(s))
	return str
}

func (s Histogram) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Histogram) DecodeFromPtr(p capnp.Ptr) Histogram {
	return Histogram(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Histogram) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Histogram) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Histogram) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Histogram) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Histogram) Count() Histogram_count { return Histogram_count(s) }

func (s Histogram_count) Which() Histogram_count_Which {
	return Histogram_count_Which(capnp.Struct(s).Uint16(8))
}
func (s Histogram_count) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Histogram_count) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Histogram_count) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Histogram_count) CountInt() uint64 {
	if capnp.Struct(s).Uint16(8) != 0 {
		panic("Which() != countInt")
	}
	return capnp.Struct(s).Uint64(0)
}

func (s Histogram_count) SetCountInt(v uint64) {
	capnp.Struct(s).SetUint16(8, 0)
	capnp.Struct(s).SetUint64(0, v)
}

func (s Histogram_count) CountFloat() float64 {
	if capnp.Struct(s).Uint16(8) != 1 {
		panic("Which() != countFloat")
	}
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Histogram_count) SetCountFloat(v float64) {
	capnp.Struct(s).SetUint16(8, 1)
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Histogram) Sum() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s Histogram) SetSum(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

func (s Histogram) Schema() int32 {
	return int32(capnp.Struct(s).Uint32(12))
}

func (s Histogram) SetSchema(v int32) {
	capnp.Struct(s).SetUint32(12, uint32(v))
}

func (s Histogram) ZeroThreshold() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(24))
}

func (s Histogram) SetZeroThreshold(v float64) {
	capnp.Struct(s).SetUint64(24, math.Float64bits(v))
}

func (s Histogram) ZeroCount() Histogram_zeroCount { return Histogram_zeroCount(s) }

func (s Histogram_zeroCount) Which() Histogram_zeroCount_Which {
	return Histogram_zeroCount_Which(capnp.Struct(s).Uint16(10))
}
func (s Histogram_zeroCount) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Histogram_zeroCount) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Histogram_zeroCount) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Histogram_zeroCount) ZeroCountInt() uint64 {
	if capnp.Struct(s).Uint16(10) != 0 {
		panic("Which() != zeroCountInt")
	}
	return capnp.Struct(s).Uint64(32)
}

func (s Histogram_zeroCount) SetZeroCountInt(v uint64) {
	capnp.Struct(s).SetUint16(10, 0)
	capnp.Struct(s).SetUint64(32, v)
}

func (s Histogram_zeroCount) ZeroCountFloat() float64 {
	if capnp.Struct(s).Uint16(10) != 1 {
		panic("Which() != zeroCountFloat")
	}
	return math.Float64frombits(capnp.Struct(s).Uint64(32))
}

func (s Histogram_zeroCount) SetZeroCountFloat(v float64) {
	capnp.Struct(s).SetUint16(10, 1)
	capnp.Struct(s).SetUint64(32, math.Float64bits(v))
}

func (s Histogram) NegativeSpans() (BucketSpan_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return BucketSpan_List(p.List()), err
}

func (s Histogram) HasNegativeSpans() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Histogram) SetNegativeSpans(v BucketSpan_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewNegativeSpans sets the negativeSpans field to a newly
// allocated BucketSpan_List, preferring placement in s's segment.
func (s Histogram) NewNegativeSpans(n int32) (BucketSpan_List, error) {
	l, err := NewBucketSpan_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return BucketSpan_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Histogram) NegativeDeltas() (capnp.Int64List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.Int64List(p.List()), err
}

func (s Histogram) HasNegativeDeltas() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Histogram) SetNegativeDeltas(v capnp.Int64List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewNegativeDeltas sets the negativeDeltas field to a newly
// allocated capnp.Int64List, preferring placement in s's segment.
func (s Histogram) NewNegativeDeltas(n int32) (capnp.Int64List, error) {
	l, err := capnp.NewInt64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Int64List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s Histogram) NegativeCounts() (capnp.Float64List, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return capnp.Float64List(p.List()), err
}

func (s Histogram) HasNegativeCounts() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Histogram) SetNegativeCounts(v capnp.Float64List) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewNegativeCounts sets the negativeCounts field to a newly
// allocated capnp.Float64List, preferring placement in s's segment.
func (s Histogram) NewNegativeCounts(n int32) (capnp.Float64List, error) {
	l, err := capnp.NewFloat64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Float64List{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}
func (s Histogram) PositiveSpans() (BucketSpan_List, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return BucketSpan_List(p.List()), err
}

func (s Histogram) HasPositiveSpans() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Histogram) SetPositiveSpans(v BucketSpan_List) error {
	return capnp.Struct(s).SetPtr(3, v.ToPtr())
}

// NewPositiveSpans sets the positiveSpans field to a newly
// allocated BucketSpan_List, preferring placement in s's segment.
func (s Histogram) NewPositiveSpans(n int32) (BucketSpan_List, error) {
	l, err := NewBucketSpan_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return BucketSpan_List{}, err
	}
	err = capnp.Struct(s).SetPtr(3, l.ToPtr())
	return l, err
}
func (s Histogram) PositiveDeltas() (capnp.Int64List, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return capnp.Int64List(p.List()), err
}

func (s Histogram) HasPositiveDeltas() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s Histogram) SetPositiveDeltas(v capnp.Int64List) error {
	return capnp.Struct(s).SetPtr(4, v.ToPtr())
}

// NewPositiveDeltas sets the positiveDeltas field to a newly
// allocated capnp.Int64List, preferring placement in s's segment.
func (s Histogram) NewPositiveDeltas(n int32) (capnp.Int64List, error) {
	l, err := capnp.NewInt64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Int64List{}, err
	}
	err = capnp.Struct(s).SetPtr(4, l.ToPtr())
	return l, err
}
func (s Histogram) PositiveCounts() (capnp.Float64List, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return capnp.Float64List(p.List()), err
}

func (s Histogram) HasPositiveCounts() bool {
	return capnp.Struct(s).HasPtr(5)
}

func (s Histogram) SetPositiveCounts(v capnp.Float64List) error {
	return capnp.Struct(s).SetPtr(5, v.ToPtr())
}

// NewPositiveCounts sets the positiveCounts field to a newly
// allocated capnp.Float64List, preferring placement in s's segment.
func (s Histogram) NewPositiveCounts(n int32) (capnp.Float64List, error) {
	l, err := capnp.NewFloat64List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.Float64List{}, err
	}
	err = capnp.Struct(s).SetPtr(5, l.ToPtr())
	return l, err
}
func (s Histogram) ResetHint() Histogram_ResetHint {
	return Histogram_ResetHint(capnp.Struct(s).Uint16(40))
}

func (s Histogram) SetResetHint(v Histogram_ResetHint) {
	capnp.Struct(s).SetUint16(40, uint16(v))
}

func (s Histogram) Timestamp() int64 {
	return int64(capnp.Struct(s).Uint64(48))
}

func (s Histogram) SetTimestamp(v int64) {
	capnp.Struct(s).SetUint64(48, uint64(v))
}

// Histogram_List is a list of Histogram.
type Histogram_List = capnp.StructList[Histogram]

// NewHistogram creates a new list of Histogram.
func NewHistogram_List(s *capnp.Segment, sz int32) (Histogram_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 56, PointerCount: 6}, sz)
	return capnp.StructList[Histogram](l), err
}

// Histogram_Future is a wrapper for a Histogram promised by a client call.
type Histogram_Future struct{ *capnp.Future }

func (f Histogram_Future) Struct() (Histogram, error) {
	p, err := f.Future.Ptr()
	return Histogram(p.Struct()), err
}
func (p Histogram_Future) Count() Histogram_count_Future { return Histogram_count_Future{p.Future} }

// Histogram_count_Future is a wrapper for a Histogram_count promised by a client call.
type Histogram_count_Future struct{ *capnp.Future }

func (f Histogram_count_Future) Struct() (Histogram_count, error) {
	p, err := f.Future.Ptr()
	return Histogram_count(p.Struct()), err
}
func (p Histogram_Future) ZeroCount() Histogram_zeroCount_Future {
	return Histogram_zeroCount_Future{p.Future}
}

// Histogram_zeroCount_Future is a wrapper for a Histogram_zeroCount promised by a client call.
type Histogram_zeroCount_Future struct{ *capnp.Future }

func (f Histogram_zeroCount_Future) Struct() (Histogram_zeroCount, error) {
	p, err := f.Future.Ptr()
	return Histogram_zeroCount(p.Struct()), err
}

type Histogram_ResetHint uint16

// Histogram_ResetHint_TypeID is the unique identifier for the type Histogram_ResetHint.
const Histogram_ResetHint_TypeID = 0xd5b0cec646441eb0

// Values of Histogram_ResetHint.
const (
	Histogram_ResetHint_unknown Histogram_ResetHint = 0
	Histogram_ResetHint_yes     Histogram_ResetHint = 1
	Histogram_ResetHint_no      Histogram_ResetHint = 2
	Histogram_ResetHint_gauge   Histogram_ResetHint = 3
)

// String returns the enum's constant name.
func (c Histogram_ResetHint) String() string {
	switch c {
	case Histogram_ResetHint_unknown:
		return "unknown"
	case Histogram_ResetHint_yes:
		return "yes"
	case Histogram_ResetHint_no:
		return "no"
	case Histogram_ResetHint_gauge:
		return "gauge"

	default:
		return ""
	}
}

// Histogram_ResetHintFromString returns the enum value with a name,
// or the zero value if there's no such value.
func Histogram_ResetHintFromString(c string) Histogram_ResetHint {
	switch c {
	case "unknown":
		return Histogram_ResetHint_unknown
	case "yes":
		return Histogram_ResetHint_yes
	case "no":
		return Histogram_ResetHint_no
	case "gauge":
		return Histogram_ResetHint_gauge

	default:
		return 0
	}
}

type Histogram_ResetHint_List = capnp.EnumList[Histogram_ResetHint]

func NewHistogram_ResetHint_List(s *capnp.Segment, sz int32) (Histogram_ResetHint_List, error) {
	return capnp.NewEnumList[Histogram_ResetHint](s, sz)
}

type Exemplar capnp.Struct

// Exemplar_TypeID is the unique identifier for the type Exemplar.
const Exemplar_TypeID = 0xbd820120399954be

func NewExemplar(s *capnp.Segment) (Exemplar, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return Exemplar(st), err
}

func NewRootExemplar(s *capnp.Segment) (Exemplar, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return Exemplar(st), err
}

func ReadRootExemplar(msg *capnp.Message) (Exemplar, error) {
	root, err := msg.Root()
	return Exemplar(root.Struct()), err
}

func (s Exemplar) String() string {
	str, _ := text.Marshal(0xbd820120399954be, capnp.Struct(s))
	return str
}

func (s Exemplar) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Exemplar) DecodeFromPtr(p capnp.Ptr) Exemplar {
	return Exemplar(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Exemplar) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Exemplar) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Exemplar) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Exemplar) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Exemplar) Labels() (Label_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Label_List(p.List()), err
}

func (s Exemplar) HasLabels() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Exemplar) SetLabels(v Label_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLabels sets the labels field to a newly
// allocated Label_List, preferring placement in s's segment.
func (s Exemplar) NewLabels(n int32) (Label_List, error) {
	l, err := NewLabel_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Label_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Exemplar) Value() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Exemplar) SetValue(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Exemplar) Timestamp() int64 {
	return int64(capnp.Struct(s).Uint64(8))
}

func (s Exemplar) SetTimestamp(v int64) {
	capnp.Struct(s).SetUint64(8, uint64(v))
}

// Exemplar_List is a list of Exemplar.
type Exemplar_List = capnp.StructList[Exemplar]

// NewExemplar creates a new list of Exemplar.
func NewExemplar_List(s *capnp.Segment, sz int32) (Exemplar_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1}, sz)
	return capnp.StructList[Exemplar](l), err
}

// Exemplar_Future is a wrapper for a Exemplar promised by a client call.
type Exemplar_Future struct{ *capnp.Future }

func (f Exemplar_Future) Struct() (Exemplar, error) {
	p, err := f.Future.Ptr()
	return Exemplar(p.Struct()), err
}

type TimeSeries capnp.Struct

// TimeSeries_TypeID is the unique identifier for the type TimeSeries.
const TimeSeries_TypeID = 0xb438c10228b97446

func NewTimeSeries(s *capnp.Segment) (TimeSeries, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4})
	return TimeSeries(st), err
}

func NewRootTimeSeries(s *capnp.Segment) (TimeSeries, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4})
	return TimeSeries(st), err
}

func ReadRootTimeSeries(msg *capnp.Message) (TimeSeries, error) {
	root, err := msg.Root()
	return TimeSeries(root.Struct()), err
}

func (s TimeSeries) String() string {
	str, _ := text.Marshal(0xb438c10228b97446, capnp.Struct(s))
	return str
}

func (s TimeSeries) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (TimeSeries) DecodeFromPtr(p capnp.Ptr) TimeSeries {
	return TimeSeries(capnp.Struct{}.DecodeFromPtr(p))
}

func (s TimeSeries) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s TimeSeries) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s TimeSeries) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s TimeSeries) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s TimeSeries) Labels() (Label_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Label_List(p.List()), err
}

func (s TimeSeries) HasLabels() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s TimeSeries) SetLabels(v Label_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLabels sets the labels field to a newly
// allocated Label_List, preferring placement in s's segment.
func (s TimeSeries) NewLabels(n int32) (Label_List, error) {
	l, err := NewLabel_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Label_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s TimeSeries) Samples() (Sample_List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Sample_List(p.List()), err
}

func (s TimeSeries) HasSamples() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s TimeSeries) SetSamples(v Sample_List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewSamples sets the samples field to a newly
// allocated Sample_List, preferring placement in s's segment.
func (s TimeSeries) NewSamples(n int32) (Sample_List, error) {
	l, err := NewSample_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Sample_List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s TimeSeries) Histograms() (Histogram_List, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return Histogram_List(p.List()), err
}

func (s TimeSeries) HasHistograms() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s TimeSeries) SetHistograms(v Histogram_List) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewHistograms sets the histograms field to a newly
// allocated Histogram_List, preferring placement in s's segment.
func (s TimeSeries) NewHistograms(n int32) (Histogram_List, error) {
	l, err := NewHistogram_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Histogram_List{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}
func (s TimeSeries) Exemplars() (Exemplar_List, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return Exemplar_List(p.List()), err
}

func (s TimeSeries) HasExemplars() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s TimeSeries) SetExemplars(v Exemplar_List) error {
	return capnp.Struct(s).SetPtr(3, v.ToPtr())
}

// NewExemplars sets the exemplars field to a newly
// allocated Exemplar_List, preferring placement in s's segment.
func (s TimeSeries) NewExemplars(n int32) (Exemplar_List, error) {
	l, err := NewExemplar_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Exemplar_List{}, err
	}
	err = capnp.Struct(s).SetPtr(3, l.ToPtr())
	return l, err
}

// TimeSeries_List is a list of TimeSeries.
type TimeSeries_List = capnp.StructList[TimeSeries]

// NewTimeSeries creates a new list of TimeSeries.
func NewTimeSeries_List(s *capnp.Segment, sz int32) (TimeSeries_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4}, sz)
	return capnp.StructList[TimeSeries](l), err
}

// TimeSeries_Future is a wrapper for a TimeSeries promised by a client call.
type TimeSeries_Future struct{ *capnp.Future }

func (f TimeSeries_Future) Struct() (TimeSeries, error) {
	p, err := f.Future.Ptr()
	return TimeSeries(p.Struct()), err
}

type TimeSeriesTenantTuple capnp.Struct

// TimeSeriesTenantTuple_TypeID is the unique identifier for the type TimeSeriesTenantTuple.
const TimeSeriesTenantTuple_TypeID = 0xd5af58206073be1f

func NewTimeSeriesTenantTuple(s *capnp.Segment) (TimeSeriesTenantTuple, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return TimeSeriesTenantTuple(st), err
}

func NewRootTimeSeriesTenantTuple(s *capnp.Segment) (TimeSeriesTenantTuple, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return TimeSeriesTenantTuple(st), err
}

func ReadRootTimeSeriesTenantTuple(msg *capnp.Message) (TimeSeriesTenantTuple, error) {
	root, err := msg.Root()
	return TimeSeriesTenantTuple(root.Struct()), err
}

func (s TimeSeriesTenantTuple) String() string {
	str, _ := text.Marshal(0xd5af58206073be1f, capnp.Struct(s))
	return str
}

func (s TimeSeriesTenantTuple) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (TimeSeriesTenantTuple) DecodeFromPtr(p capnp.Ptr) TimeSeriesTenantTuple {
	return TimeSeriesTenantTuple(capnp.Struct{}.DecodeFromPtr(p))
}

func (s TimeSeriesTenantTuple) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s TimeSeriesTenantTuple) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s TimeSeriesTenantTuple) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s TimeSeriesTenantTuple) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s TimeSeriesTenantTuple) Symbols() (Symbols, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Symbols(p.Struct()), err
}

func (s TimeSeriesTenantTuple) HasSymbols() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s TimeSeriesTenantTuple) SetSymbols(v Symbols) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewSymbols sets the symbols field to a newly
// allocated Symbols struct, preferring placement in s's segment.
func (s TimeSeriesTenantTuple) NewSymbols() (Symbols, error) {
	ss, err := NewSymbols(capnp.Struct(s).Segment())
	if err != nil {
		return Symbols{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s TimeSeriesTenantTuple) TimeSeries() (TimeSeries_List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return TimeSeries_List(p.List()), err
}

func (s TimeSeriesTenantTuple) HasTimeSeries() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s TimeSeriesTenantTuple) SetTimeSeries(v TimeSeries_List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewTimeSeries sets the timeSeries field to a newly
// allocated TimeSeries_List, preferring placement in s's segment.
func (s TimeSeriesTenantTuple) NewTimeSeries(n int32) (TimeSeries_List, error) {
	l, err := NewTimeSeries_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return TimeSeries_List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s TimeSeriesTenantTuple) Tenant() (string, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.Text(), err
}

func (s TimeSeriesTenantTuple) HasTenant() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s TimeSeriesTenantTuple) TenantBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.TextBytes(), err
}

func (s TimeSeriesTenantTuple) SetTenant(v string) error {
	return capnp.Struct(s).SetText(2, v)
}

// TimeSeriesTenantTuple_List is a list of TimeSeriesTenantTuple.
type TimeSeriesTenantTuple_List = capnp.StructList[TimeSeriesTenantTuple]

// NewTimeSeriesTenantTuple creates a new list of TimeSeriesTenantTuple.
func NewTimeSeriesTenantTuple_List(s *capnp.Segment, sz int32) (TimeSeriesTenantTuple_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return capnp.StructList[TimeSeriesTenantTuple](l), err
}

// TimeSeriesTenantTuple_Future is a wrapper for a TimeSeriesTenantTuple promised by a client call.
type TimeSeriesTenantTuple_Future struct{ *capnp.Future }

func (f TimeSeriesTenantTuple_Future) Struct() (TimeSeriesTenantTuple, error) {
	p, err := f.Future.Ptr()
	return TimeSeriesTenantTuple(p.Struct()), err
}
func (p TimeSeriesTenantTuple_Future) Symbols() Symbols_Future {
	return Symbols_Future{Future: p.Future.Field(0, nil)}
}

type WriteRequest capnp.Struct

// WriteRequest_TypeID is the unique identifier for the type WriteRequest.
const WriteRequest_TypeID = 0xeb3bcb770c8eb6be

func NewWriteRequest(s *capnp.Segment) (WriteRequest, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4})
	return WriteRequest(st), err
}

func NewRootWriteRequest(s *capnp.Segment) (WriteRequest, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4})
	return WriteRequest(st), err
}

func ReadRootWriteRequest(msg *capnp.Message) (WriteRequest, error) {
	root, err := msg.Root()
	return WriteRequest(root.Struct()), err
}

func (s WriteRequest) String() string {
	str, _ := text.Marshal(0xeb3bcb770c8eb6be, capnp.Struct(s))
	return str
}

func (s WriteRequest) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (WriteRequest) DecodeFromPtr(p capnp.Ptr) WriteRequest {
	return WriteRequest(capnp.Struct{}.DecodeFromPtr(p))
}

func (s WriteRequest) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s WriteRequest) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s WriteRequest) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s WriteRequest) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s WriteRequest) Symbols() (Symbols, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Symbols(p.Struct()), err
}

func (s WriteRequest) HasSymbols() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s WriteRequest) SetSymbols(v Symbols) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewSymbols sets the symbols field to a newly
// allocated Symbols struct, preferring placement in s's segment.
func (s WriteRequest) NewSymbols() (Symbols, error) {
	ss, err := NewSymbols(capnp.Struct(s).Segment())
	if err != nil {
		return Symbols{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s WriteRequest) TimeSeries() (TimeSeries_List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return TimeSeries_List(p.List()), err
}

func (s WriteRequest) HasTimeSeries() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s WriteRequest) SetTimeSeries(v TimeSeries_List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewTimeSeries sets the timeSeries field to a newly
// allocated TimeSeries_List, preferring placement in s's segment.
func (s WriteRequest) NewTimeSeries(n int32) (TimeSeries_List, error) {
	l, err := NewTimeSeries_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return TimeSeries_List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s WriteRequest) Tenant() (string, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.Text(), err
}

func (s WriteRequest) HasTenant() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s WriteRequest) TenantBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.TextBytes(), err
}

func (s WriteRequest) SetTenant(v string) error {
	return capnp.Struct(s).SetText(2, v)
}

func (s WriteRequest) Data() (TimeSeriesTenantTuple_List, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return TimeSeriesTenantTuple_List(p.List()), err
}

func (s WriteRequest) HasData() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s WriteRequest) SetData(v TimeSeriesTenantTuple_List) error {
	return capnp.Struct(s).SetPtr(3, v.ToPtr())
}

// NewData sets the data field to a newly
// allocated TimeSeriesTenantTuple_List, preferring placement in s's segment.
func (s WriteRequest) NewData(n int32) (TimeSeriesTenantTuple_List, error) {
	l, err := NewTimeSeriesTenantTuple_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return TimeSeriesTenantTuple_List{}, err
	}
	err = capnp.Struct(s).SetPtr(3, l.ToPtr())
	return l, err
}

// WriteRequest_List is a list of WriteRequest.
type WriteRequest_List = capnp.StructList[WriteRequest]

// NewWriteRequest creates a new list of WriteRequest.
func NewWriteRequest_List(s *capnp.Segment, sz int32) (WriteRequest_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4}, sz)
	return capnp.StructList[WriteRequest](l), err
}

// WriteRequest_Future is a wrapper for a WriteRequest promised by a client call.
type WriteRequest_Future struct{ *capnp.Future }

func (f WriteRequest_Future) Struct() (WriteRequest, error) {
	p, err := f.Future.Ptr()
	return WriteRequest(p.Struct()), err
}
func (p WriteRequest_Future) Symbols() Symbols_Future {
	return Symbols_Future{Future: p.Future.Field(0, nil)}
}

type WriteError uint16

// WriteError_TypeID is the unique identifier for the type WriteError.
const WriteError_TypeID = 0xe67be4164a39ea55

// Values of WriteError.
const (
	WriteError_none            WriteError = 0
	WriteError_unavailable     WriteError = 1
	WriteError_alreadyExists   WriteError = 2
	WriteError_invalidArgument WriteError = 3
	WriteError_internal        WriteError = 4
)

// String returns the enum's constant name.
func (c WriteError) String() string {
	switch c {
	case WriteError_none:
		return "none"
	case WriteError_unavailable:
		return "unavailable"
	case WriteError_alreadyExists:
		return "alreadyExists"
	case WriteError_invalidArgument:
		return "invalidArgument"
	case WriteError_internal:
		return "internal"

	default:
		return ""
	}
}

// WriteErrorFromString returns the enum value with a name,
// or the zero value if there's no such value.
func WriteErrorFromString(c string) WriteError {
	switch c {
	case "none":
		return WriteError_none
	case "unavailable":
		return WriteError_unavailable
	case "alreadyExists":
		return WriteError_alreadyExists
	case "invalidArgument":
		return WriteError_invalidArgument
	case "internal":
		return WriteError_internal

	default:
		return 0
	}
}

type WriteError_List = capnp.EnumList[WriteError]

func NewWriteError_List(s *capnp.Segment, sz int32) (WriteError_List, error) {
	return capnp.NewEnumList[WriteError](s, sz)
}

type Writer capnp.Client

// Writer_TypeID is the unique identifier for the type Writer.
const Writer_TypeID = 0xcc20b9c332c83b91

func (c Writer) Write(ctx context.Context, params func(Writer_write_Params) error) (Writer_write_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xcc20b9c332c83b91,
			MethodID:      0,
			InterfaceName: "pkg/receive/writecapnp/write_request.capnp:Writer",
			MethodName:    "write",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Writer_write_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Writer_write_Results_Future{Future: ans.Future()}, release

}

func (c Writer) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Writer) String() string {
	return "Writer(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Writer) AddRef() Writer {
	return Writer(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Writer) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Writer) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Writer) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Writer) DecodeFromPtr(p capnp.Ptr) Writer {
	return Writer(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Writer) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Writer) IsSame(other Writer) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Writer) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Writer) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Writer_Server is a Writer with a local implementation.
type Writer_Server interface {
	Write(context.Context, Writer_write) error
}

// Writer_NewServer creates a new Server from an implementation of Writer_Server.
func Writer_NewServer(s Writer_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Writer_Methods(nil, s), s, c)
}

// Writer_ServerToClient creates a new Client from an implementation of Writer_Server.
// The caller is responsible for calling Release on the returned Client.
func Writer_ServerToClient(s Writer_Server) Writer {
	return Writer(capnp.NewClient(Writer_NewServer(s)))
}

// Writer_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Writer_Methods(methods []server.Method, s Writer_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xcc20b9c332c83b91,
			MethodID:      0,
			InterfaceName: "pkg/receive/writecapnp/write_request.capnp:Writer",
			MethodName:    "write",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Write(ctx, Writer_write{call})
		},
	})

	return methods
}

// Writer_write holds the state for a server call to Writer.write.
// See server.Call for documentation.
type Writer_write struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Writer_write) Args() Writer_write_Params {
	return Writer_write_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Writer_write) AllocResults() (Writer_write_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Writer_write_Results(r), err
}

// Writer_List is a list of Writer.
type Writer_List = capnp.CapList[Writer]

// NewWriter_List creates a new list of Writer.
func NewWriter_List(s *capnp.Segment, sz int32) (Writer_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Writer](l), err
}

type Writer_write_Params capnp.Struct

// Writer_write_Params_TypeID is the unique identifier for the type Writer_write_Params.
const Writer_write_Params_TypeID = 0x90d5073324ecc34b

func NewWriter_write_Params(s *capnp.Segment) (Writer_write_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Writer_write_Params(st), err
}

func NewRootWriter_write_Params(s *capnp.Segment) (Writer_write_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Writer_write_Params(st), err
}

func ReadRootWriter_write_Params(msg *capnp.Message) (Writer_write_Params, error) {
	root, err := msg.Root()
	return Writer_write_Params(root.Struct()), err
}

func (s Writer_write_Params) String() string {
	str, _ := text.Marshal(0x90d5073324ecc34b, capnp.Struct(s))
	return str
}

func (s Writer_write_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Writer_write_Params) DecodeFromPtr(p capnp.Ptr) Writer_write_Params {
	return Writer_write_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Writer_write_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Writer_write_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Writer_write_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Writer_write_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Writer_write_Params) Wr() (WriteRequest, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return WriteRequest(p.Struct()), err
}

func (s Writer_write_Params) HasWr() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Writer_write_Params) SetWr(v WriteRequest) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewWr sets the wr field to a newly
// allocated WriteRequest struct, preferring placement in s's segment.
func (s Writer_write_Params) NewWr() (WriteRequest, error) {
	ss, err := NewWriteRequest(capnp.Struct(s).Segment())
	if err != nil {
		return WriteRequest{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Writer_write_Params_List is a list of Writer_write_Params.
type Writer_write_Params_List = capnp.StructList[Writer_write_Params]

// NewWriter_write_Params creates a new list of Writer_write_Params.
func NewWriter_write_Params_List(s *capnp.Segment, sz int32) (Writer_write_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Writer_write_Params](l), err
}

// Writer_write_Params_Future is a wrapper for a Writer_write_Params promised by a client call.
type Writer_write_Params_Future struct{ *capnp.Future }

func (f Writer_write_Params_Future) Struct() (Writer_write_Params, error) {
	p, err := f.Future.Ptr()
	return Writer_write_Params(p.Struct()), err
}
func (p Writer_write_Params_Future) Wr() WriteRequest_Future {
	return WriteRequest_Future{Future: p.Future.Field(0, nil)}
}

type Writer_write_Results capnp.Struct

// Writer_write_Results_TypeID is the unique identifier for the type Writer_write_Results.
const Writer_write_Results_TypeID = 0x87f6d2196d414cf4

func NewWriter_write_Results(s *capnp.Segment) (Writer_write_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Writer_write_Results(st), err
}

func NewRootWriter_write_Results(s *capnp.Segment) (Writer_write_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Writer_write_Results(st), err
}

func ReadRootWriter_write_Results(msg *capnp.Message) (Writer_write_Results, error) {
	root, err := msg.Root()
	return Writer_write_Results(root.Struct()), err
}

func (s Writer_write_Results) String() string {
	str, _ := text.Marshal(0x87f6d2196d414cf4, capnp.Struct(s))
	return str
}

func (s Writer_write_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Writer_write_Results) DecodeFromPtr(p capnp.Ptr) Writer_write_Results {
	return Writer_write_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Writer_write_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Writer_write_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Writer_write_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Writer_write_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Writer_write_Results) Error() WriteError {
	return WriteError(capnp.Struct(s).Uint16(0))
}

func (s Writer_write_Results) SetError(v WriteError) {
	capnp.Struct(s).SetUint16(0, uint16(v))
}

// Writer_write_Results_List is a list of Writer_write_Results.
type Writer_write_Results_List = capnp.StructList[Writer_write_Results]

// NewWriter_write_Results creates a new list of Writer_write_Results.
func NewWriter_write_Results_List(s *capnp.Segment, sz int32) (Writer_write_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[Writer_write_Results](l), err
}

// Writer_write_Results_Future is a wrapper for a Writer_write_Results promised by a client call.
type Writer_write_Results_Future struct{ *capnp.Future }

func (f Writer_write_Results_Future) Struct() (Writer_write_Results, error) {
	p, err := f.Future.Ptr()
	return Writer_write_Results(p.Struct()), err
}

const schema_85d3acc39d94e0f8 = "x\xda\xacWq\x88\x1cg\x15\x7f\xbf\xef\x9b\xdd\xbdd" +
	"w\xefn\x98\xa5\x92b\xdd\xb4D\xe8\xe5L\x9a\xbb\xcb" +
	"I\x92V69s1\x97\x9ep\xb3{\xd1DR\xcd" +
	"\xe4\xee\xeb\xdd\x9a\xd9\xd9\xed\xcc\xec]\xeeT\xae\x0dJ" +
	"Si\xc5F\x0b\xad\"\xf4\xb4\x08U\xb1%Z\xe9A" +
	"[\x88\x11\x15\x14i\xd4\x80\x15\xb5\x16\xaaE-\x8a`" +
	"E\x03f\xe4}\xbb7;\x1e'\xedE\xff\xbb\xfc\xe6" +
	"\xb7\xef\xf7\xbe\xdf\xfb\xbe\xf7^v\x1d5\xf6\x1b\x03\xf9" +
	"\xd7\xd2$\xec\x89T:\xfa\xdb\xf8\x81\xda\x96\x9f\xfe\xfd" +
	"~\xb2\x07\x01\"#C4t\\\x0aA\xb0j\xb2D" +
	"\x88\xee\xbc\xf4\xfa\xb6\xa1\xcc\x95\xcf\x929\x08\xa2\x14\x98" +
	"\xf0\x90\xbc\x0a\x82\xb5\xac\x09\xdf\xfcp\xdf\xe7.\x8f\xbd" +
	"\xfbQ\xb2\xfb\x81\xe8\x1f\xbf\xfd\xfc\x97.}\xe3g\x9f" +
	"jE\xba(/\xc0zIf\x88\xac+r\x9e\x10\xdd" +
	"\xbf\xb2\xf7\x86G^<\xf9\x15\xb2\x87\x91\x89\xb6\xef\xf9" +
	"\xc0\xd9\xd1;~\xfd=:\x9a\xce@\xc0\x18\x1a0~" +
	"\xc9\x81G\x0d\xe6.>{\xed\xf5\xaf\xbe\xb2\xf0u2" +
	"\xfb\x13qS\x82\x03?i|\x01\xd6E\xd6\xb0\x9e\xd7" +
	"\xe4\xee\xdd\x0b_\xbcw9\xfc\xd6\xba\x81SC})" +
	"\x9d\xf1{R\xcc=\x14\xae\xdc*.\xee\xf9\xf6\x9a\xc0" +
	":\xe3\xe5\xd4\x05X+)\x0e\xfcL\xea5B\xf4\xc2" +
	"\xe4c{\xb7\xe2\xec\xf3|<\x91`k#.\xa7\xbf" +
	"\x0c\xeb\x0fif\xff.\xfd\x14\xa1#l\xf7#\x93`" +
	"3e\xe8\xe1\xcc\xd7`=\x99y\x1b\xd1\xd03\x99\x97" +
	"\x05!z\xf8\xf6\x1f\x0e^Z\xd9\xfac2\xfbe\x87" +
	"M\x18zc\xf3yX\xf9,\x07\xde\x94}\x9f5\xc0" +
	"\x7fE\xc5\x17\x82\x93[\x8f=ueM\xdel\xef\xd0" +
	"\x96\xecfa\xed\xd5?\x18\xcer&O\xbf\xe3\xe0\xa1" +
	"\xef\xff\xe4\xe9+d\x0e\x8bNZ\x84\xa1W\xb2Wa" +
	"\xfdK3\xff\x99\x9d!DG\xff\xb8\xf7\xc8\x0d\xaf~" +
	"\xec\xf7d\xf6\x8b\xffH\xe2\xa6\xdc\x05X\xc39f\x0e" +
	"\xe4\x96\xd8\x8b\xef|&7\xff\xa3\xdb\xff\xb4\x9eq\xcd" +
	"\xdcwa=\xa4\xc9\x0f\xe4\xd8\xb8\xdf4\xcf]u_" +
	"\x1e\xfb\xcb\x1a\xe34\xf9\xbe\xfcyX\x8f\xe5\x99\xfcH" +
	"\x9eK2x\xa7\x99\xf9\xf3\x0f\xce\xffu\xbdK\xf4F" +
	"\xfe\xd3\xb0\xf2\xdd\xda\x8b\xeey\xda\x115N\xcf\xdc\xe6" +
	"\xab)\x95\xa9\xce\xa9\xdb\xe6\xfdj\xa8\xa6\x9c\x86\xd7h" +
	"\xfd\xf9\x11_\xdd\xd3TA\xb8Sc\xfb>\xc8\x98\xbf" +
	"S\x7f\xdaVVA\xd3\x0d\x03\xb2\x0di\x10\x19 2" +
	"\xf3\x83Dv\x97\x84]\x10(*\xdf\xaf\xfb\xe8\xe98" +
	"B@\x0f!\x16LoT\xb04\xe1\xf8N-H\xea" +
	"\xdd\xd8\xd1\x93\xf3>z;\xa6\x12\xd0\x9b\x10K\xbd\x05" +
	"\xb1\x91\xe6\xd4iU\x0c+\x0d\xc7\x9b\x00\xec\xaeX\xa6" +
	"o\x1f\x91\xbdM\xc2\xde%`\x02\x05~\xdb\xe6\x0e\x06" +
	"o\x95\xb0w\x0b\x94\xeaw\xdf\x1d\xa8\x10\x06\x09\x18\x84" +
	"\x92\xab\xbc\x99p\x16]$\xd0\xb5\xc1\x13\x1f\xae\x06a" +
	"}\xc6wj;\xa7\xeaM\xe9\x85\x9cF.\x8aZy" +
	"\x1c\xe9H\xe6q-j%2\xf0!\"{\x97\x84}" +
	"\x87@4Uoz\xe1\x98\x17\x12\x116\x91\xc0&j" +
	"c\x87\xdc:I'D\x96\x04\xb2\x1b4\xa6\xb2P;" +
	"U\x97n\xb0\xc6\x95\xed\xeb\xb92\xd2N\xf1\xa0@\xcf" +
	"\xb4\x13:\xc8\x93@\x9e\xb0\xd4\xb2(@7aBB" +
	"{\xd3}\xdd\xde,*\xbfT\x7f/\x9f\x8b\x13z{" +
	"\x14\x19\x05\xa48\xa7\x8fv\x1c\xba\x09\xd7\x18N\xb3E" +
	"\x8b\x09\x8b\x16\x95\xaf\x7fJ=lT\xecR\x0c\x97\xd8" +
	"\xab\xebtj\xb2ZS\x95\xa2\xf2\xabJ\x9b\xd5\x1b\x9b" +
	"\xe5\xf0m9!a\x9fI\x98\xd5d\xb3\x1a\x12\xf6\x83" +
	"\x02\xa6\x10\x05\x08\"\xf3\x01.\xe79\x09\xfb\x09\x01S" +
	"\xca\x02$\x91\xb9\\&\xb2\x1f\x97\xb0\x9f\x13(\xb9\xce" +
	")\xe5\xc6F\xf6v\x9e;\x81\xc1\xa5\xc0\xa95\\\x95" +
	" \xc4\xcd\xa3E\x88f\xdb>\x92\xac%X\x89\xb6\xa6" +
	"Y\xea\x8c\xaa5\\\xc7'$Hq\x03o\x936b" +
	"\xce(\x07\xcc\xb8\x8e\xcf\xd6\xe4bkF\xd9\x9a\xfd\x12" +
	"\xf6\x09\x81Ug\x8es#\x99\x94\xb0O\xb23h9" +
	"sW\xb9\xed\xe1\xec\x9b\x9bP\x9cs\xdc\xa6\x8ak\x18" +
	"Vk*\x08\x9d\x1a\xa1\x81\x14\x09\xa46\x98\xba\xbey" +
	"=|\xf5l\x03\xc9q\x80rTV\x81\x0a\x0fW=" +
	"Bh\xef\xe6S!1\x99\xad\xbb0H\xc2D\xab\xb8" +
	"\xd6(n!\xaa\xec\x87De\x1c|\xb4V}\xad1" +
	"\xec#\xaa\x1cd|\x02\xed\xba\x1bD\xd6\xfb\xe1\x13U" +
	"\xc6\x19?\x06\x01\xb0x<\x9c\xad\xa3(\xf3Y\x0a<" +
	"=\xad\x03\x9a\xaaC\x9f\xe0\x10i\x14\xd0Ed\x1d\xc7" +
	"\"Q\xe5\x18\xe3!\xe3\x19Q\xc0&\"\xeb\x1e\x8d7" +
	"\x18\x7f\x90\xf1.Y\xc0f\x9e7:\xce9\xc6\x9f`" +
	"|\x93Q@\x96\xc8Z\xd6\xfc\xc7\x19\x7f\x8e\xf1\xcd\xa9" +
	"\x02rD\xd6\x8a\xc6\x9fe\xfc\xe7\x8cg\x0b\x05\xe4\x89" +
	"\xac\xcb(\x13U^d\xfcW\x8c\xe7\xd2\x05t\x13Y" +
	"/i\xfc\x17\x8c\xbf\x0a\x81\xa2\xeeN\x99\xa0Y[-" +
	"V)\x98\x9aU5g\xb5\x99\xea\x8799\xeb+*" +
	"\x06\xb3uw:\xaei\xfc`\x11F\x9e\x9aq\xc2\xea" +
	"\x9c\xa2\"w\xef\xc4\xb5\x88\xf7\xa9\xf6}\x8d\x89\xa5\x83" +
	"\xca\x0d\x9d\x98\x99j\xb7\xa3\xcew\xdd]\xe2\xef\xd9\xd5" +
	"vU\x0f\xaaoI(&\xfe\x17\xa1\xce\xf7\xf5\x85\xfc" +
	"\xce\xadBO\xe7\xc2\xb5g\xe8\xffz\x9f\xf5\\\x85~" +
	"\x88\x86L\x11\xc5\x8b)VWX\xd3\xe4{\x9b\xca\x14" +
	"\xf5\xcf\xf7c\x02\xd8\xd0\xaa\xa0;\xa1n\x84\x93\xcas" +
	"\xbcp\xb2\xd9p\x15\xd1\x9a\xa7?\xd2~\xfa\xe3\x89\xae" +
	"8\xc6\x0d\xf0\xb0\x84=\x9d\xe8\x8aq\xff\x9c\x15X\x0a" +
	"x\x1e\xb9\x01z;[m{\xdc\x87mU\x92\xc9\xfe" +
	"\x17\xaf\xa8\xad\xda\x94B\x9d\x11r$\x90\xbb\xee\x11T" +
	"VAIW(\xd4\x9d^g\xd97\xc2\x12\xe6\xcd\xb7" +
	"\x10A\x98[n$\x82d#i\xa9\xe9\x9d\xf6\xea\xf3" +
	"^fA\x05\xd2\xab\x17g\x9c\xe6\x8c\xdax\xc5\x8a\xa3" +
	"\xbcS\xb1^\xcb\x95\xe1\xedZo\xc7)\xad\xd7\xe7k" +
	"\xbdw\x9e%\x82a\xde|\x84\xa8\xc7\xab{*jz" +
	"\xce\x9cSu\x1d\xca\x9crU\xe4\xb8\xber\xa6\x17F" +
	"\xa9x\xa6\x1a\x84AT\xf5\xe6\x1c\xb7:}@\xf83" +
	"\xcd\x9a\xf2B\xaaz\xa1\xf2=\xc7%\xda\xf8\xaaVn" +
	"A\xb4f\xf8\x8dt\x8a\x17\x97Yq\x99\xa7%\xec{" +
	"\x13e\xfe\x04\x97\xf9\x8c\x84\xfd\xc9\xc4\xf0\xbb\x8f\x17\x8d" +
	"\x8fK\xd8\x8f\xfe\xdfk\xdfZQbr\xfc\x7f\x82\xeb" +
	"\x98n\x15\x9e\xbaPkv\xa4rg\x1f\x89O>\xc0" +
	"\xc3\xed]\x12\xf6\x1e\xb1\xeeK^3\xbb6\x92\xc48" +
	"O\xc5\xd6+{\xb3Em\xb0\x93Y\x8f\xe7\xd4\xd4\xea" +
	"\xb6\xdaVo\xff\xeb\xdf\x01\x00\x00\xff\xff<\x8a\x01\xe9"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_85d3acc39d94e0f8,
		Nodes: []uint64{
			0x87f6d2196d414cf4,
			0x90d5073324ecc34b,
			0x983649d193295eae,
			0xa360d0951639b987,
			0xab79e1a6ecfeb87a,
			0xb374a1809b79340e,
			0xb438c10228b97446,
			0xbd820120399954be,
			0xc4dd3c458256382a,
			0xcc20b9c332c83b91,
			0xd5af58206073be1f,
			0xd5b0cec646441eb0,
			0xe67be4164a39ea55,
			0xeb3bcb770c8eb6be,
			0xef49df6cfa8875de,
			0xf192c7ee07114b32,
		},
		Compressed: true,
	})
}
