// Code generated by capnpc-go. DO NOT EDIT.

package storecapnp

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	fc "capnproto.org/go/capnp/v3/flowcontrol"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
	context "context"
	strconv "strconv"
)

type Symbols capnp.Struct

// Symbols_TypeID is the unique identifier for the type Symbols.
const Symbols_TypeID = 0xb47e1416c68683e2

func NewSymbols(s *capnp.Segment) (Symbols, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Symbols(st), err
}

func NewRootSymbols(s *capnp.Segment) (Symbols, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Symbols(st), err
}

func ReadRootSymbols(msg *capnp.Message) (Symbols, error) {
	root, err := msg.Root()
	return Symbols(root.Struct()), err
}

func (s Symbols) String() string {
	str, _ := text.Marshal(0xb47e1416c68683e2, capnp.Struct(s))
	return str
}

func (s Symbols) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Symbols) DecodeFromPtr(p capnp.Ptr) Symbols {
	return Symbols(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Symbols) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Symbols) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Symbols) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Symbols) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Symbols) Data() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Symbols) HasData() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Symbols) SetData(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

func (s Symbols) Offsets() (capnp.UInt32List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.UInt32List(p.List()), err
}

func (s Symbols) HasOffsets() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Symbols) SetOffsets(v capnp.UInt32List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewOffsets sets the offsets field to a newly
// allocated capnp.UInt32List, preferring placement in s's segment.
func (s Symbols) NewOffsets(n int32) (capnp.UInt32List, error) {
	l, err := capnp.NewUInt32List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.UInt32List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}

// Symbols_List is a list of Symbols.
type Symbols_List = capnp.StructList[Symbols]

// NewSymbols creates a new list of Symbols.
func NewSymbols_List(s *capnp.Segment, sz int32) (Symbols_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Symbols](l), err
}

// Symbols_Future is a wrapper for a Symbols promised by a client call.
type Symbols_Future struct{ *capnp.Future }

func (f Symbols_Future) Struct() (Symbols, error) {
	p, err := f.Future.Ptr()
	return Symbols(p.Struct()), err
}

type Label capnp.Struct

// Label_TypeID is the unique identifier for the type Label.
const Label_TypeID = 0xd01eedc119383e30

func NewLabel(s *capnp.Segment) (Label, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Label(st), err
}

func NewRootLabel(s *capnp.Segment) (Label, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Label(st), err
}

func ReadRootLabel(msg *capnp.Message) (Label, error) {
	root, err := msg.Root()
	return Label(root.Struct()), err
}

func (s Label) String() string {
	str, _ := text.Marshal(0xd01eedc119383e30, capnp.Struct(s))
	return str
}

func (s Label) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Label) DecodeFromPtr(p capnp.Ptr) Label {
	return Label(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Label) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Label) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Label) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Label) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Label) Name() uint32 {
	return capnp.Struct(s).Uint32(0)
}

func (s Label) SetName(v uint32) {
	capnp.Struct(s).SetUint32(0, v)
}

func (s Label) Value() uint32 {
	return capnp.Struct(s).Uint32(4)
}

func (s Label) SetValue(v uint32) {
	capnp.Struct(s).SetUint32(4, v)
}

// Label_List is a list of Label.
type Label_List = capnp.StructList[Label]

// NewLabel creates a new list of Label.
func NewLabel_List(s *capnp.Segment, sz int32) (Label_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[Label](l), err
}

// Label_Future is a wrapper for a Label promised by a client call.
type Label_Future struct{ *capnp.Future }

func (f Label_Future) Struct() (Label, error) {
	p, err := f.Future.Ptr()
	return Label(p.Struct()), err
}

type LabelMatcher capnp.Struct

// LabelMatcher_TypeID is the unique identifier for the type LabelMatcher.
const LabelMatcher_TypeID = 0x8ec03473c848ca76

func NewLabelMatcher(s *capnp.Segment) (LabelMatcher, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return LabelMatcher(st), err
}

func NewRootLabelMatcher(s *capnp.Segment) (LabelMatcher, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0})
	return LabelMatcher(st), err
}

func ReadRootLabelMatcher(msg *capnp.Message) (LabelMatcher, error) {
	root, err := msg.Root()
	return LabelMatcher(root.Struct()), err
}

func (s LabelMatcher) String() string {
	str, _ := text.Marshal(0x8ec03473c848ca76, capnp.Struct(s))
	return str
}

func (s LabelMatcher) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (LabelMatcher) DecodeFromPtr(p capnp.Ptr) LabelMatcher {
	return LabelMatcher(capnp.Struct{}.DecodeFromPtr(p))
}

func (s LabelMatcher) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s LabelMatcher) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s LabelMatcher) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s LabelMatcher) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s LabelMatcher) Type() LabelMatcher_Type {
	return LabelMatcher_Type(capnp.Struct(s).Uint16(0))
}

func (s LabelMatcher) SetType(v LabelMatcher_Type) {
	capnp.Struct(s).SetUint16(0, uint16(v))
}

func (s LabelMatcher) Name() uint32 {
	return capnp.Struct(s).Uint32(4)
}

func (s LabelMatcher) SetName(v uint32) {
	capnp.Struct(s).SetUint32(4, v)
}

func (s LabelMatcher) Value() uint32 {
	return capnp.Struct(s).Uint32(8)
}

func (s LabelMatcher) SetValue(v uint32) {
	capnp.Struct(s).SetUint32(8, v)
}

// LabelMatcher_List is a list of LabelMatcher.
type LabelMatcher_List = capnp.StructList[LabelMatcher]

// NewLabelMatcher creates a new list of LabelMatcher.
func NewLabelMatcher_List(s *capnp.Segment, sz int32) (LabelMatcher_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 0}, sz)
	return capnp.StructList[LabelMatcher](l), err
}

// LabelMatcher_Future is a wrapper for a LabelMatcher promised by a client call.
type LabelMatcher_Future struct{ *capnp.Future }

func (f LabelMatcher_Future) Struct() (LabelMatcher, error) {
	p, err := f.Future.Ptr()
	return LabelMatcher(p.Struct()), err
}

type LabelMatcher_Type uint16

// LabelMatcher_Type_TypeID is the unique identifier for the type LabelMatcher_Type.
const LabelMatcher_Type_TypeID = 0xdec5e5ac5f9fca83

// Values of LabelMatcher_Type.
const (
	LabelMatcher_Type_eq  LabelMatcher_Type = 0
	LabelMatcher_Type_neq LabelMatcher_Type = 1
	LabelMatcher_Type_re  LabelMatcher_Type = 2
	LabelMatcher_Type_nre LabelMatcher_Type = 3
)

// String returns the enum's constant name.
func (c LabelMatcher_Type) String() string {
	switch c {
	case LabelMatcher_Type_eq:
		return "eq"
	case LabelMatcher_Type_neq:
		return "neq"
	case LabelMatcher_Type_re:
		return "re"
	case LabelMatcher_Type_nre:
		return "nre"

	default:
		return ""
	}
}

// LabelMatcher_TypeFromString returns the enum value with a name,
// or the zero value if there's no such value.
func LabelMatcher_TypeFromString(c string) LabelMatcher_Type {
	switch c {
	case "eq":
		return LabelMatcher_Type_eq
	case "neq":
		return LabelMatcher_Type_neq
	case "re":
		return LabelMatcher_Type_re
	case "nre":
		return LabelMatcher_Type_nre

	default:
		return 0
	}
}

type LabelMatcher_Type_List = capnp.EnumList[LabelMatcher_Type]

func NewLabelMatcher_Type_List(s *capnp.Segment, sz int32) (LabelMatcher_Type_List, error) {
	return capnp.NewEnumList[LabelMatcher_Type](s, sz)
}

type ChunkEncoding uint16

// ChunkEncoding_TypeID is the unique identifier for the type ChunkEncoding.
const ChunkEncoding_TypeID = 0xa8584dda7c5a35f9

// Values of ChunkEncoding.
const (
	ChunkEncoding_xor            ChunkEncoding = 0
	ChunkEncoding_histogram      ChunkEncoding = 1
	ChunkEncoding_floatHistogram ChunkEncoding = 2
)

// String returns the enum's constant name.
func (c ChunkEncoding) String() string {
	switch c {
	case ChunkEncoding_xor:
		return "xor"
	case ChunkEncoding_histogram:
		return "histogram"
	case ChunkEncoding_floatHistogram:
		return "floatHistogram"

	default:
		return ""
	}
}

// ChunkEncodingFromString returns the enum value with a name,
// or the zero value if there's no such value.
func ChunkEncodingFromString(c string) ChunkEncoding {
	switch c {
	case "xor":
		return ChunkEncoding_xor
	case "histogram":
		return ChunkEncoding_histogram
	case "floatHistogram":
		return ChunkEncoding_floatHistogram

	default:
		return 0
	}
}

type ChunkEncoding_List = capnp.EnumList[ChunkEncoding]

func NewChunkEncoding_List(s *capnp.Segment, sz int32) (ChunkEncoding_List, error) {
	return capnp.NewEnumList[ChunkEncoding](s, sz)
}

type Chunk capnp.Struct

// Chunk_TypeID is the unique identifier for the type Chunk.
const Chunk_TypeID = 0x9a464c967b64ac1a

func NewChunk(s *capnp.Segment) (Chunk, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return Chunk(st), err
}

func NewRootChunk(s *capnp.Segment) (Chunk, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return Chunk(st), err
}

func ReadRootChunk(msg *capnp.Message) (Chunk, error) {
	root, err := msg.Root()
	return Chunk(root.Struct()), err
}

func (s Chunk) String() string {
	str, _ := text.Marshal(0x9a464c967b64ac1a, capnp.Struct(s))
	return str
}

func (s Chunk) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Chunk) DecodeFromPtr(p capnp.Ptr) Chunk {
	return Chunk(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Chunk) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Chunk) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Chunk) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Chunk) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Chunk) Type() ChunkEncoding {
	return ChunkEncoding(capnp.Struct(s).Uint16(0))
}

func (s Chunk) SetType(v ChunkEncoding) {
	capnp.Struct(s).SetUint16(0, uint16(v))
}

func (s Chunk) Data() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Chunk) HasData() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Chunk) SetData(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

func (s Chunk) Hash() uint64 {
	return capnp.Struct(s).Uint64(8)
}

func (s Chunk) SetHash(v uint64) {
	capnp.Struct(s).SetUint64(8, v)
}

// Chunk_List is a list of Chunk.
type Chunk_List = capnp.StructList[Chunk]

// NewChunk creates a new list of Chunk.
func NewChunk_List(s *capnp.Segment, sz int32) (Chunk_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1}, sz)
	return capnp.StructList[Chunk](l), err
}

// Chunk_Future is a wrapper for a Chunk promised by a client call.
type Chunk_Future struct{ *capnp.Future }

func (f Chunk_Future) Struct() (Chunk, error) {
	p, err := f.Future.Ptr()
	return Chunk(p.Struct()), err
}

type AggrChunk capnp.Struct

// AggrChunk_TypeID is the unique identifier for the type AggrChunk.
const AggrChunk_TypeID = 0x8069586561dd21e7

func NewAggrChunk(s *capnp.Segment) (AggrChunk, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 6})
	return AggrChunk(st), err
}

func NewRootAggrChunk(s *capnp.Segment) (AggrChunk, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 6})
	return AggrChunk(st), err
}

func ReadRootAggrChunk(msg *capnp.Message) (AggrChunk, error) {
	root, err := msg.Root()
	return AggrChunk(root.Struct()), err
}

func (s AggrChunk) String() string {
	str, _ := text.Marshal(0x8069586561dd21e7, capnp.Struct(s))
	return str
}

func (s AggrChunk) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (AggrChunk) DecodeFromPtr(p capnp.Ptr) AggrChunk {
	return AggrChunk(capnp.Struct{}.DecodeFromPtr(p))
}

func (s AggrChunk) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s AggrChunk) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s AggrChunk) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s AggrChunk) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s AggrChunk) MinTime() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s AggrChunk) SetMinTime(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s AggrChunk) MaxTime() int64 {
	return int64(capnp.Struct(s).Uint64(8))
}

func (s AggrChunk) SetMaxTime(v int64) {
	capnp.Struct(s).SetUint64(8, uint64(v))
}

func (s AggrChunk) Raw() (Chunk, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Chunk(p.Struct()), err
}

func (s AggrChunk) HasRaw() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s AggrChunk) SetRaw(v Chunk) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewRaw sets the raw field to a newly
// allocated Chunk struct, preferring placement in s's segment.
func (s AggrChunk) NewRaw() (Chunk, error) {
	ss, err := NewChunk(capnp.Struct(s).Segment())
	if err != nil {
		return Chunk{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s AggrChunk) Count() (Chunk, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Chunk(p.Struct()), err
}

func (s AggrChunk) HasCount() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s AggrChunk) SetCount(v Chunk) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewCount sets the count field to a newly
// allocated Chunk struct, preferring placement in s's segment.
func (s AggrChunk) NewCount() (Chunk, error) {
	ss, err := NewChunk(capnp.Struct(s).Segment())
	if err != nil {
		return Chunk{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s AggrChunk) Sum() (Chunk, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return Chunk(p.Struct()), err
}

func (s AggrChunk) HasSum() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s AggrChunk) SetSum(v Chunk) error {
	return capnp.Struct(s).SetPtr(2, capnp.Struct(v).ToPtr())
}

// NewSum sets the sum field to a newly
// allocated Chunk struct, preferring placement in s's segment.
func (s AggrChunk) NewSum() (Chunk, error) {
	ss, err := NewChunk(capnp.Struct(s).Segment())
	if err != nil {
		return Chunk{}, err
	}
	err = capnp.Struct(s).SetPtr(2, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s AggrChunk) Min() (Chunk, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return Chunk(p.Struct()), err
}

func (s AggrChunk) HasMin() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s AggrChunk) SetMin(v Chunk) error {
	return capnp.Struct(s).SetPtr(3, capnp.Struct(v).ToPtr())
}

// NewMin sets the min field to a newly
// allocated Chunk struct, preferring placement in s's segment.
func (s AggrChunk) NewMin() (Chunk, error) {
	ss, err := NewChunk(capnp.Struct(s).Segment())
	if err != nil {
		return Chunk{}, err
	}
	err = capnp.Struct(s).SetPtr(3, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s AggrChunk) Max() (Chunk, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return Chunk(p.Struct()), err
}

func (s AggrChunk) HasMax() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s AggrChunk) SetMax(v Chunk) error {
	return capnp.Struct(s).SetPtr(4, capnp.Struct(v).ToPtr())
}

// NewMax sets the max field to a newly
// allocated Chunk struct, preferring placement in s's segment.
func (s AggrChunk) NewMax() (Chunk, error) {
	ss, err := NewChunk(capnp.Struct(s).Segment())
	if err != nil {
		return Chunk{}, err
	}
	err = capnp.Struct(s).SetPtr(4, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s AggrChunk) Counter() (Chunk, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return Chunk(p.Struct()), err
}

func (s AggrChunk) HasCounter() bool {
	return capnp.Struct(s).HasPtr(5)
}

func (s AggrChunk) SetCounter(v Chunk) error {
	return capnp.Struct(s).SetPtr(5, capnp.Struct(v).ToPtr())
}

// NewCounter sets the counter field to a newly
// allocated Chunk struct, preferring placement in s's segment.
func (s AggrChunk) NewCounter() (Chunk, error) {
	ss, err := NewChunk(capnp.Struct(s).Segment())
	if err != nil {
		return Chunk{}, err
	}
	err = capnp.Struct(s).SetPtr(5, capnp.Struct(ss).ToPtr())
	return ss, err
}

// AggrChunk_List is a list of AggrChunk.
type AggrChunk_List = capnp.StructList[AggrChunk]

// NewAggrChunk creates a new list of AggrChunk.
func NewAggrChunk_List(s *capnp.Segment, sz int32) (AggrChunk_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 6}, sz)
	return capnp.StructList[AggrChunk](l), err
}

// AggrChunk_Future is a wrapper for a AggrChunk promised by a client call.
type AggrChunk_Future struct{ *capnp.Future }

func (f AggrChunk_Future) Struct() (AggrChunk, error) {
	p, err := f.Future.Ptr()
	return AggrChunk(p.Struct()), err
}
func (p AggrChunk_Future) Raw() Chunk_Future {
	return Chunk_Future{Future: p.Future.Field(0, nil)}
}
func (p AggrChunk_Future) Count() Chunk_Future {
	return Chunk_Future{Future: p.Future.Field(1, nil)}
}
func (p AggrChunk_Future) Sum() Chunk_Future {
	return Chunk_Future{Future: p.Future.Field(2, nil)}
}
func (p AggrChunk_Future) Min() Chunk_Future {
	return Chunk_Future{Future: p.Future.Field(3, nil)}
}
func (p AggrChunk_Future) Max() Chunk_Future {
	return Chunk_Future{Future: p.Future.Field(4, nil)}
}
func (p AggrChunk_Future) Counter() Chunk_Future {
	return Chunk_Future{Future: p.Future.Field(5, nil)}
}

type Series capnp.Struct

// Series_TypeID is the unique identifier for the type Series.
const Series_TypeID = 0xacd8f49e8b5621d0

func NewSeries(s *capnp.Segment) (Series, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Series(st), err
}

func NewRootSeries(s *capnp.Segment) (Series, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Series(st), err
}

func ReadRootSeries(msg *capnp.Message) (Series, error) {
	root, err := msg.Root()
	return Series(root.Struct()), err
}

func (s Series) String() string {
	str, _ := text.Marshal(0xacd8f49e8b5621d0, capnp.Struct(s))
	return str
}

func (s Series) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Series) DecodeFromPtr(p capnp.Ptr) Series {
	return Series(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Series) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Series) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Series) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Series) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Series) Labels() (Label_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Label_List(p.List()), err
}

func (s Series) HasLabels() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Series) SetLabels(v Label_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLabels sets the labels field to a newly
// allocated Label_List, preferring placement in s's segment.
func (s Series) NewLabels(n int32) (Label_List, error) {
	l, err := NewLabel_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Label_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Series) Chunks() (AggrChunk_List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return AggrChunk_List(p.List()), err
}

func (s Series) HasChunks() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Series) SetChunks(v AggrChunk_List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewChunks sets the chunks field to a newly
// allocated AggrChunk_List, preferring placement in s's segment.
func (s Series) NewChunks(n int32) (AggrChunk_List, error) {
	l, err := NewAggrChunk_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return AggrChunk_List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}

// Series_List is a list of Series.
type Series_List = capnp.StructList[Series]

// NewSeries creates a new list of Series.
func NewSeries_List(s *capnp.Segment, sz int32) (Series_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Series](l), err
}

// Series_Future is a wrapper for a Series promised by a client call.
type Series_Future struct{ *capnp.Future }

func (f Series_Future) Struct() (Series, error) {
	p, err := f.Future.Ptr()
	return Series(p.Struct()), err
}

type Aggr uint16

// Aggr_TypeID is the unique identifier for the type Aggr.
const Aggr_TypeID = 0x838d6d5e7a5c76c6

// Values of Aggr.
const (
	Aggr_raw     Aggr = 0
	Aggr_count   Aggr = 1
	Aggr_sum     Aggr = 2
	Aggr_min     Aggr = 3
	Aggr_max     Aggr = 4
	Aggr_counter Aggr = 5
)

// String returns the enum's constant name.
func (c Aggr) String() string {
	switch c {
	case Aggr_raw:
		return "raw"
	case Aggr_count:
		return "count"
	case Aggr_sum:
		return "sum"
	case Aggr_min:
		return "min"
	case Aggr_max:
		return "max"
	case Aggr_counter:
		return "counter"

	default:
		return ""
	}
}

// AggrFromString returns the enum value with a name,
// or the zero value if there's no such value.
func AggrFromString(c string) Aggr {
	switch c {
	case "raw":
		return Aggr_raw
	case "count":
		return Aggr_count
	case "sum":
		return Aggr_sum
	case "min":
		return Aggr_min
	case "max":
		return Aggr_max
	case "counter":
		return Aggr_counter

	default:
		return 0
	}
}

type Aggr_List = capnp.EnumList[Aggr]

func NewAggr_List(s *capnp.Segment, sz int32) (Aggr_List, error) {
	return capnp.NewEnumList[Aggr](s, sz)
}

type PartialResponseStrategy uint16

// PartialResponseStrategy_TypeID is the unique identifier for the type PartialResponseStrategy.
const PartialResponseStrategy_TypeID = 0x9e33ad031e312cec

// Values of PartialResponseStrategy.
const (
	PartialResponseStrategy_warn  PartialResponseStrategy = 0
	PartialResponseStrategy_abort PartialResponseStrategy = 1
)

// String returns the enum's constant name.
func (c PartialResponseStrategy) String() string {
	switch c {
	case PartialResponseStrategy_warn:
		return "warn"
	case PartialResponseStrategy_abort:
		return "abort"

	default:
		return ""
	}
}

// PartialResponseStrategyFromString returns the enum value with a name,
// or the zero value if there's no such value.
func PartialResponseStrategyFromString(c string) PartialResponseStrategy {
	switch c {
	case "warn":
		return PartialResponseStrategy_warn
	case "abort":
		return PartialResponseStrategy_abort

	default:
		return 0
	}
}

type PartialResponseStrategy_List = capnp.EnumList[PartialResponseStrategy]

func NewPartialResponseStrategy_List(s *capnp.Segment, sz int32) (PartialResponseStrategy_List, error) {
	return capnp.NewEnumList[PartialResponseStrategy](s, sz)
}

type Func capnp.Struct

// Func_TypeID is the unique identifier for the type Func.
const Func_TypeID = 0xbf2138ef51a531ed

func NewFunc(s *capnp.Segment) (Func, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Func(st), err
}

func NewRootFunc(s *capnp.Segment) (Func, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Func(st), err
}

func ReadRootFunc(msg *capnp.Message) (Func, error) {
	root, err := msg.Root()
	return Func(root.Struct()), err
}

func (s Func) String() string {
	str, _ := text.Marshal(0xbf2138ef51a531ed, capnp.Struct(s))
	return str
}

func (s Func) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Func) DecodeFromPtr(p capnp.Ptr) Func {
	return Func(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Func) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Func) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Func) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Func) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Func) Name() uint32 {
	return capnp.Struct(s).Uint32(0)
}

func (s Func) SetName(v uint32) {
	capnp.Struct(s).SetUint32(0, v)
}

// Func_List is a list of Func.
type Func_List = capnp.StructList[Func]

// NewFunc creates a new list of Func.
func NewFunc_List(s *capnp.Segment, sz int32) (Func_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[Func](l), err
}

// Func_Future is a wrapper for a Func promised by a client call.
type Func_Future struct{ *capnp.Future }

func (f Func_Future) Struct() (Func, error) {
	p, err := f.Future.Ptr()
	return Func(p.Struct()), err
}

type Grouping capnp.Struct

// Grouping_TypeID is the unique identifier for the type Grouping.
const Grouping_TypeID = 0xc09ab7398befb3c8

func NewGrouping(s *capnp.Segment) (Grouping, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Grouping(st), err
}

func NewRootGrouping(s *capnp.Segment) (Grouping, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Grouping(st), err
}

func ReadRootGrouping(msg *capnp.Message) (Grouping, error) {
	root, err := msg.Root()
	return Grouping(root.Struct()), err
}

func (s Grouping) String() string {
	str, _ := text.Marshal(0xc09ab7398befb3c8, capnp.Struct(s))
	return str
}

func (s Grouping) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Grouping) DecodeFromPtr(p capnp.Ptr) Grouping {
	return Grouping(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Grouping) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Grouping) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Grouping) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Grouping) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Grouping) By() bool {
	return capnp.Struct(s).Bit(0)
}

func (s Grouping) SetBy(v bool) {
	capnp.Struct(s).SetBit(0, v)
}

func (s Grouping) Labels() (capnp.UInt32List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.UInt32List(p.List()), err
}

func (s Grouping) HasLabels() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Grouping) SetLabels(v capnp.UInt32List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLabels sets the labels field to a newly
// allocated capnp.UInt32List, preferring placement in s's segment.
func (s Grouping) NewLabels(n int32) (capnp.UInt32List, error) {
	l, err := capnp.NewUInt32List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.UInt32List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// Grouping_List is a list of Grouping.
type Grouping_List = capnp.StructList[Grouping]

// NewGrouping creates a new list of Grouping.
func NewGrouping_List(s *capnp.Segment, sz int32) (Grouping_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[Grouping](l), err
}

// Grouping_Future is a wrapper for a Grouping promised by a client call.
type Grouping_Future struct{ *capnp.Future }

func (f Grouping_Future) Struct() (Grouping, error) {
	p, err := f.Future.Ptr()
	return Grouping(p.Struct()), err
}

type Range capnp.Struct

// Range_TypeID is the unique identifier for the type Range.
const Range_TypeID = 0x9ab8e8ff2c4c9f5e

func NewRange(s *capnp.Segment) (Range, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Range(st), err
}

func NewRootRange(s *capnp.Segment) (Range, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Range(st), err
}

func ReadRootRange(msg *capnp.Message) (Range, error) {
	root, err := msg.Root()
	return Range(root.Struct()), err
}

func (s Range) String() string {
	str, _ := text.Marshal(0x9ab8e8ff2c4c9f5e, capnp.Struct(s))
	return str
}

func (s Range) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Range) DecodeFromPtr(p capnp.Ptr) Range {
	return Range(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Range) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Range) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Range) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Range) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Range) Millis() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s Range) SetMillis(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

// Range_List is a list of Range.
type Range_List = capnp.StructList[Range]

// NewRange creates a new list of Range.
func NewRange_List(s *capnp.Segment, sz int32) (Range_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[Range](l), err
}

// Range_Future is a wrapper for a Range promised by a client call.
type Range_Future struct{ *capnp.Future }

func (f Range_Future) Struct() (Range, error) {
	p, err := f.Future.Ptr()
	return Range(p.Struct()), err
}

type QueryHints capnp.Struct

// QueryHints_TypeID is the unique identifier for the type QueryHints.
const QueryHints_TypeID = 0xa016f66a064a8e1e

func NewQueryHints(s *capnp.Segment) (QueryHints, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 3})
	return QueryHints(st), err
}

func NewRootQueryHints(s *capnp.Segment) (QueryHints, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 3})
	return QueryHints(st), err
}

func ReadRootQueryHints(msg *capnp.Message) (QueryHints, error) {
	root, err := msg.Root()
	return QueryHints(root.Struct()), err
}

func (s QueryHints) String() string {
	str, _ := text.Marshal(0xa016f66a064a8e1e, capnp.Struct(s))
	return str
}

func (s QueryHints) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (QueryHints) DecodeFromPtr(p capnp.Ptr) QueryHints {
	return QueryHints(capnp.Struct{}.DecodeFromPtr(p))
}

func (s QueryHints) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s QueryHints) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s QueryHints) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s QueryHints) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s QueryHints) StepMillis() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s QueryHints) SetStepMillis(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s QueryHints) Func() (Func, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Func(p.Struct()), err
}

func (s QueryHints) HasFunc() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s QueryHints) SetFunc(v Func) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewFunc sets the func field to a newly
// allocated Func struct, preferring placement in s's segment.
func (s QueryHints) NewFunc() (Func, error) {
	ss, err := NewFunc(capnp.Struct(s).Segment())
	if err != nil {
		return Func{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s QueryHints) Grouping() (Grouping, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Grouping(p.Struct()), err
}

func (s QueryHints) HasGrouping() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s QueryHints) SetGrouping(v Grouping) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewGrouping sets the grouping field to a newly
// allocated Grouping struct, preferring placement in s's segment.
func (s QueryHints) NewGrouping() (Grouping, error) {
	ss, err := NewGrouping(capnp.Struct(s).Segment())
	if err != nil {
		return Grouping{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s QueryHints) Range() (Range, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return Range(p.Struct()), err
}

func (s QueryHints) HasRange() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s QueryHints) SetRange(v Range) error {
	return capnp.Struct(s).SetPtr(2, capnp.Struct(v).ToPtr())
}

// NewRange sets the range field to a newly
// allocated Range struct, preferring placement in s's segment.
func (s QueryHints) NewRange() (Range, error) {
	ss, err := NewRange(capnp.Struct(s).Segment())
	if err != nil {
		return Range{}, err
	}
	err = capnp.Struct(s).SetPtr(2, capnp.Struct(ss).ToPtr())
	return ss, err
}

// QueryHints_List is a list of QueryHints.
type QueryHints_List = capnp.StructList[QueryHints]

// NewQueryHints creates a new list of QueryHints.
func NewQueryHints_List(s *capnp.Segment, sz int32) (QueryHints_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 3}, sz)
	return capnp.StructList[QueryHints](l), err
}

// QueryHints_Future is a wrapper for a QueryHints promised by a client call.
type QueryHints_Future struct{ *capnp.Future }

func (f QueryHints_Future) Struct() (QueryHints, error) {
	p, err := f.Future.Ptr()
	return QueryHints(p.Struct()), err
}
func (p QueryHints_Future) Func() Func_Future {
	return Func_Future{Future: p.Future.Field(0, nil)}
}
func (p QueryHints_Future) Grouping() Grouping_Future {
	return Grouping_Future{Future: p.Future.Field(1, nil)}
}
func (p QueryHints_Future) Range() Range_Future {
	return Range_Future{Future: p.Future.Field(2, nil)}
}

type ShardInfo capnp.Struct

// ShardInfo_TypeID is the unique identifier for the type ShardInfo.
const ShardInfo_TypeID = 0xe05cef4ec842bb22

func NewShardInfo(s *capnp.Segment) (ShardInfo, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1})
	return ShardInfo(st), err
}

func NewRootShardInfo(s *capnp.Segment) (ShardInfo, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1})
	return ShardInfo(st), err
}

func ReadRootShardInfo(msg *capnp.Message) (ShardInfo, error) {
	root, err := msg.Root()
	return ShardInfo(root.Struct()), err
}

func (s ShardInfo) String() string {
	str, _ := text.Marshal(0xe05cef4ec842bb22, capnp.Struct(s))
	return str
}

func (s ShardInfo) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (ShardInfo) DecodeFromPtr(p capnp.Ptr) ShardInfo {
	return ShardInfo(capnp.Struct{}.DecodeFromPtr(p))
}

func (s ShardInfo) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s ShardInfo) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s ShardInfo) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s ShardInfo) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s ShardInfo) ShardIndex() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s ShardInfo) SetShardIndex(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s ShardInfo) TotalShards() int64 {
	return int64(capnp.Struct(s).Uint64(8))
}

func (s ShardInfo) SetTotalShards(v int64) {
	capnp.Struct(s).SetUint64(8, uint64(v))
}

func (s ShardInfo) By() bool {
	return capnp.Struct(s).Bit(128)
}

func (s ShardInfo) SetBy(v bool) {
	capnp.Struct(s).SetBit(128, v)
}

func (s ShardInfo) Labels() (capnp.UInt32List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.UInt32List(p.List()), err
}

func (s ShardInfo) HasLabels() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s ShardInfo) SetLabels(v capnp.UInt32List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLabels sets the labels field to a newly
// allocated capnp.UInt32List, preferring placement in s's segment.
func (s ShardInfo) NewLabels(n int32) (capnp.UInt32List, error) {
	l, err := capnp.NewUInt32List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.UInt32List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// ShardInfo_List is a list of ShardInfo.
type ShardInfo_List = capnp.StructList[ShardInfo]

// NewShardInfo creates a new list of ShardInfo.
func NewShardInfo_List(s *capnp.Segment, sz int32) (ShardInfo_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1}, sz)
	return capnp.StructList[ShardInfo](l), err
}

// ShardInfo_Future is a wrapper for a ShardInfo promised by a client call.
type ShardInfo_Future struct{ *capnp.Future }

func (f ShardInfo_Future) Struct() (ShardInfo, error) {
	p, err := f.Future.Ptr()
	return ShardInfo(p.Struct()), err
}

type SeriesRequest capnp.Struct

// SeriesRequest_TypeID is the unique identifier for the type SeriesRequest.
const SeriesRequest_TypeID = 0x8b6579a662ac5c30

func NewSeriesRequest(s *capnp.Segment) (SeriesRequest, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 56, PointerCount: 7})
	return SeriesRequest(st), err
}

func NewRootSeriesRequest(s *capnp.Segment) (SeriesRequest, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 56, PointerCount: 7})
	return SeriesRequest(st), err
}

func ReadRootSeriesRequest(msg *capnp.Message) (SeriesRequest, error) {
	root, err := msg.Root()
	return SeriesRequest(root.Struct()), err
}

func (s SeriesRequest) String() string {
	str, _ := text.Marshal(0x8b6579a662ac5c30, capnp.Struct(s))
	return str
}

func (s SeriesRequest) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (SeriesRequest) DecodeFromPtr(p capnp.Ptr) SeriesRequest {
	return SeriesRequest(capnp.Struct{}.DecodeFromPtr(p))
}

func (s SeriesRequest) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s SeriesRequest) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s SeriesRequest) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s SeriesRequest) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s SeriesRequest) Symbols() (Symbols, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Symbols(p.Struct()), err
}

func (s SeriesRequest) HasSymbols() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s SeriesRequest) SetSymbols(v Symbols) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewSymbols sets the symbols field to a newly
// allocated Symbols struct, preferring placement in s's segment.
func (s SeriesRequest) NewSymbols() (Symbols, error) {
	ss, err := NewSymbols(capnp.Struct(s).Segment())
	if err != nil {
		return Symbols{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s SeriesRequest) MinTime() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s SeriesRequest) SetMinTime(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s SeriesRequest) MaxTime() int64 {
	return int64(capnp.Struct(s).Uint64(8))
}

func (s SeriesRequest) SetMaxTime(v int64) {
	capnp.Struct(s).SetUint64(8, uint64(v))
}

func (s SeriesRequest) Matchers() (LabelMatcher_List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return LabelMatcher_List(p.List()), err
}

func (s SeriesRequest) HasMatchers() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s SeriesRequest) SetMatchers(v LabelMatcher_List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewMatchers sets the matchers field to a newly
// allocated LabelMatcher_List, preferring placement in s's segment.
func (s SeriesRequest) NewMatchers(n int32) (LabelMatcher_List, error) {
	l, err := NewLabelMatcher_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return LabelMatcher_List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s SeriesRequest) MaxResolutionWindow() int64 {
	return int64(capnp.Struct(s).Uint64(16))
}

func (s SeriesRequest) SetMaxResolutionWindow(v int64) {
	capnp.Struct(s).SetUint64(16, uint64(v))
}

func (s SeriesRequest) Aggregates() (Aggr_List, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return Aggr_List(p.List()), err
}

func (s SeriesRequest) HasAggregates() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s SeriesRequest) SetAggregates(v Aggr_List) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewAggregates sets the aggregates field to a newly
// allocated Aggr_List, preferring placement in s's segment.
func (s SeriesRequest) NewAggregates(n int32) (Aggr_List, error) {
	l, err := NewAggr_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Aggr_List{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}
func (s SeriesRequest) PartialResponseDisabled() bool {
	return capnp.Struct(s).Bit(192)
}

func (s SeriesRequest) SetPartialResponseDisabled(v bool) {
	capnp.Struct(s).SetBit(192, v)
}

func (s SeriesRequest) PartialResponseStrategy() PartialResponseStrategy {
	return PartialResponseStrategy(capnp.Struct(s).Uint16(26))
}

func (s SeriesRequest) SetPartialResponseStrategy(v PartialResponseStrategy) {
	capnp.Struct(s).SetUint16(26, uint16(v))
}

func (s SeriesRequest) SkipChunks() bool {
	return capnp.Struct(s).Bit(193)
}

func (s SeriesRequest) SetSkipChunks(v bool) {
	capnp.Struct(s).SetBit(193, v)
}

func (s SeriesRequest) Hints() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return []byte(p.Data()), err
}

func (s SeriesRequest) HasHints() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s SeriesRequest) SetHints(v []byte) error {
	return capnp.Struct(s).SetData(3, v)
}

func (s SeriesRequest) Step() int64 {
	return int64(capnp.Struct(s).Uint64(32))
}

func (s SeriesRequest) SetStep(v int64) {
	capnp.Struct(s).SetUint64(32, uint64(v))
}

func (s SeriesRequest) Range() int64 {
	return int64(capnp.Struct(s).Uint64(40))
}

func (s SeriesRequest) SetRange(v int64) {
	capnp.Struct(s).SetUint64(40, uint64(v))
}

func (s SeriesRequest) QueryHints() (QueryHints, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return QueryHints(p.Struct()), err
}

func (s SeriesRequest) HasQueryHints() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s SeriesRequest) SetQueryHints(v QueryHints) error {
	return capnp.Struct(s).SetPtr(4, capnp.Struct(v).ToPtr())
}

// NewQueryHints sets the queryHints field to a newly
// allocated QueryHints struct, preferring placement in s's segment.
func (s SeriesRequest) NewQueryHints() (QueryHints, error) {
	ss, err := NewQueryHints(capnp.Struct(s).Segment())
	if err != nil {
		return QueryHints{}, err
	}
	err = capnp.Struct(s).SetPtr(4, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s SeriesRequest) ShardInfo() (ShardInfo, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return ShardInfo(p.Struct()), err
}

func (s SeriesRequest) HasShardInfo() bool {
	return capnp.Struct(s).HasPtr(5)
}

func (s SeriesRequest) SetShardInfo(v ShardInfo) error {
	return capnp.Struct(s).SetPtr(5, capnp.Struct(v).ToPtr())
}

// NewShardInfo sets the shardInfo field to a newly
// allocated ShardInfo struct, preferring placement in s's segment.
func (s SeriesRequest) NewShardInfo() (ShardInfo, error) {
	ss, err := NewShardInfo(capnp.Struct(s).Segment())
	if err != nil {
		return ShardInfo{}, err
	}
	err = capnp.Struct(s).SetPtr(5, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s SeriesRequest) WithoutReplicaLabels() (capnp.UInt32List, error) {
	p, err := capnp.Struct(s).Ptr(6)
	return capnp.UInt32List(p.List()), err
}

func (s SeriesRequest) HasWithoutReplicaLabels() bool {
	return capnp.Struct(s).HasPtr(6)
}

func (s SeriesRequest) SetWithoutReplicaLabels(v capnp.UInt32List) error {
	return capnp.Struct(s).SetPtr(6, v.ToPtr())
}

// NewWithoutReplicaLabels sets the withoutReplicaLabels field to a newly
// allocated capnp.UInt32List, preferring placement in s's segment.
func (s SeriesRequest) NewWithoutReplicaLabels(n int32) (capnp.UInt32List, error) {
	l, err := capnp.NewUInt32List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.UInt32List{}, err
	}
	err = capnp.Struct(s).SetPtr(6, l.ToPtr())
	return l, err
}
func (s SeriesRequest) Limit() int64 {
	return int64(capnp.Struct(s).Uint64(48))
}

func (s SeriesRequest) SetLimit(v int64) {
	capnp.Struct(s).SetUint64(48, uint64(v))
}

// SeriesRequest_List is a list of SeriesRequest.
type SeriesRequest_List = capnp.StructList[SeriesRequest]

// NewSeriesRequest creates a new list of SeriesRequest.
func NewSeriesRequest_List(s *capnp.Segment, sz int32) (SeriesRequest_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 56, PointerCount: 7}, sz)
	return capnp.StructList[SeriesRequest](l), err
}

// SeriesRequest_Future is a wrapper for a SeriesRequest promised by a client call.
type SeriesRequest_Future struct{ *capnp.Future }

func (f SeriesRequest_Future) Struct() (SeriesRequest, error) {
	p, err := f.Future.Ptr()
	return SeriesRequest(p.Struct()), err
}
func (p SeriesRequest_Future) Symbols() Symbols_Future {
	return Symbols_Future{Future: p.Future.Field(0, nil)}
}
func (p SeriesRequest_Future) QueryHints() QueryHints_Future {
	return QueryHints_Future{Future: p.Future.Field(4, nil)}
}
func (p SeriesRequest_Future) ShardInfo() ShardInfo_Future {
	return ShardInfo_Future{Future: p.Future.Field(5, nil)}
}

type SeriesResponse capnp.Struct
type SeriesResponse_Which uint16

const (
	SeriesResponse_Which_series  SeriesResponse_Which = 0
	SeriesResponse_Which_warning SeriesResponse_Which = 1
	SeriesResponse_Which_hints   SeriesResponse_Which = 2
)

func (w SeriesResponse_Which) String() string {
	const s = "serieswarninghints"
	switch w {
	case SeriesResponse_Which_series:
		return s[0:6]
	case SeriesResponse_Which_warning:
		return s[6:13]
	case SeriesResponse_Which_hints:
		return s[13:18]

	}
	return "SeriesResponse_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// SeriesResponse_TypeID is the unique identifier for the type SeriesResponse.
const SeriesResponse_TypeID = 0xd43c690b8c720958

func NewSeriesResponse(s *capnp.Segment) (SeriesResponse, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return SeriesResponse(st), err
}

func NewRootSeriesResponse(s *capnp.Segment) (SeriesResponse, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return SeriesResponse(st), err
}

func ReadRootSeriesResponse(msg *capnp.Message) (SeriesResponse, error) {
	root, err := msg.Root()
	return SeriesResponse(root.Struct()), err
}

func (s SeriesResponse) String() string {
	str, _ := text.Marshal(0xd43c690b8c720958, capnp.Struct(s))
	return str
}

func (s SeriesResponse) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (SeriesResponse) DecodeFromPtr(p capnp.Ptr) SeriesResponse {
	return SeriesResponse(capnp.Struct{}.DecodeFromPtr(p))
}

func (s SeriesResponse) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s SeriesResponse) Which() SeriesResponse_Which {
	return SeriesResponse_Which(capnp.Struct(s).Uint16(0))
}
func (s SeriesResponse) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s SeriesResponse) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s SeriesResponse) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s SeriesResponse) Symbols() (Symbols, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Symbols(p.Struct()), err
}

func (s SeriesResponse) HasSymbols() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s SeriesResponse) SetSymbols(v Symbols) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewSymbols sets the symbols field to a newly
// allocated Symbols struct, preferring placement in s's segment.
func (s SeriesResponse) NewSymbols() (Symbols, error) {
	ss, err := NewSymbols(capnp.Struct(s).Segment())
	if err != nil {
		return Symbols{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s SeriesResponse) Series() (Series, error) {
	if capnp.Struct(s).Uint16(0) != 0 {
		panic("Which() != series")
	}
	p, err := capnp.Struct(s).Ptr(1)
	return Series(p.Struct()), err
}

func (s SeriesResponse) HasSeries() bool {
	if capnp.Struct(s).Uint16(0) != 0 {
		return false
	}
	return capnp.Struct(s).HasPtr(1)
}

func (s SeriesResponse) SetSeries(v Series) error {
	capnp.Struct(s).SetUint16(0, 0)
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewSeries sets the series field to a newly
// allocated Series struct, preferring placement in s's segment.
func (s SeriesResponse) NewSeries() (Series, error) {
	capnp.Struct(s).SetUint16(0, 0)
	ss, err := NewSeries(capnp.Struct(s).Segment())
	if err != nil {
		return Series{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s SeriesResponse) Warning() (string, error) {
	if capnp.Struct(s).Uint16(0) != 1 {
		panic("Which() != warning")
	}
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s SeriesResponse) HasWarning() bool {
	if capnp.Struct(s).Uint16(0) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(1)
}

func (s SeriesResponse) WarningBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s SeriesResponse) SetWarning(v string) error {
	capnp.Struct(s).SetUint16(0, 1)
	return capnp.Struct(s).SetText(1, v)
}

func (s SeriesResponse) Hints() ([]byte, error) {
	if capnp.Struct(s).Uint16(0) != 2 {
		panic("Which() != hints")
	}
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s SeriesResponse) HasHints() bool {
	if capnp.Struct(s).Uint16(0) != 2 {
		return false
	}
	return capnp.Struct(s).HasPtr(1)
}

func (s SeriesResponse) SetHints(v []byte) error {
	capnp.Struct(s).SetUint16(0, 2)
	return capnp.Struct(s).SetData(1, v)
}

// SeriesResponse_List is a list of SeriesResponse.
type SeriesResponse_List = capnp.StructList[SeriesResponse]

// NewSeriesResponse creates a new list of SeriesResponse.
func NewSeriesResponse_List(s *capnp.Segment, sz int32) (SeriesResponse_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return capnp.StructList[SeriesResponse](l), err
}

// SeriesResponse_Future is a wrapper for a SeriesResponse promised by a client call.
type SeriesResponse_Future struct{ *capnp.Future }

func (f SeriesResponse_Future) Struct() (SeriesResponse, error) {
	p, err := f.Future.Ptr()
	return SeriesResponse(p.Struct()), err
}
func (p SeriesResponse_Future) Symbols() Symbols_Future {
	return Symbols_Future{Future: p.Future.Field(0, nil)}
}
func (p SeriesResponse_Future) Series() Series_Future {
	return Series_Future{Future: p.Future.Field(1, nil)}
}

type LabelNamesRequest capnp.Struct

// LabelNamesRequest_TypeID is the unique identifier for the type LabelNamesRequest.
const LabelNamesRequest_TypeID = 0xc2c82260fee838b3

func NewLabelNamesRequest(s *capnp.Segment) (LabelNamesRequest, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 32, PointerCount: 4})
	return LabelNamesRequest(st), err
}

func NewRootLabelNamesRequest(s *capnp.Segment) (LabelNamesRequest, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 32, PointerCount: 4})
	return LabelNamesRequest(st), err
}

func ReadRootLabelNamesRequest(msg *capnp.Message) (LabelNamesRequest, error) {
	root, err := msg.Root()
	return LabelNamesRequest(root.Struct()), err
}

func (s LabelNamesRequest) String() string {
	str, _ := text.Marshal(0xc2c82260fee838b3, capnp.Struct(s))
	return str
}

func (s LabelNamesRequest) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (LabelNamesRequest) DecodeFromPtr(p capnp.Ptr) LabelNamesRequest {
	return LabelNamesRequest(capnp.Struct{}.DecodeFromPtr(p))
}

func (s LabelNamesRequest) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s LabelNamesRequest) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s LabelNamesRequest) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s LabelNamesRequest) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s LabelNamesRequest) Symbols() (Symbols, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Symbols(p.Struct()), err
}

func (s LabelNamesRequest) HasSymbols() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s LabelNamesRequest) SetSymbols(v Symbols) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewSymbols sets the symbols field to a newly
// allocated Symbols struct, preferring placement in s's segment.
func (s LabelNamesRequest) NewSymbols() (Symbols, error) {
	ss, err := NewSymbols(capnp.Struct(s).Segment())
	if err != nil {
		return Symbols{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s LabelNamesRequest) PartialResponseDisabled() bool {
	return capnp.Struct(s).Bit(0)
}

func (s LabelNamesRequest) SetPartialResponseDisabled(v bool) {
	capnp.Struct(s).SetBit(0, v)
}

func (s LabelNamesRequest) PartialResponseStrategy() PartialResponseStrategy {
	return PartialResponseStrategy(capnp.Struct(s).Uint16(2))
}

func (s LabelNamesRequest) SetPartialResponseStrategy(v PartialResponseStrategy) {
	capnp.Struct(s).SetUint16(2, uint16(v))
}

func (s LabelNamesRequest) Start() int64 {
	return int64(capnp.Struct(s).Uint64(8))
}

func (s LabelNamesRequest) SetStart(v int64) {
	capnp.Struct(s).SetUint64(8, uint64(v))
}

func (s LabelNamesRequest) End() int64 {
	return int64(capnp.Struct(s).Uint64(16))
}

func (s LabelNamesRequest) SetEnd(v int64) {
	capnp.Struct(s).SetUint64(16, uint64(v))
}

func (s LabelNamesRequest) Hints() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s LabelNamesRequest) HasHints() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s LabelNamesRequest) SetHints(v []byte) error {
	return capnp.Struct(s).SetData(1, v)
}

func (s LabelNamesRequest) Matchers() (LabelMatcher_List, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return LabelMatcher_List(p.List()), err
}

func (s LabelNamesRequest) HasMatchers() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s LabelNamesRequest) SetMatchers(v LabelMatcher_List) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewMatchers sets the matchers field to a newly
// allocated LabelMatcher_List, preferring placement in s's segment.
func (s LabelNamesRequest) NewMatchers(n int32) (LabelMatcher_List, error) {
	l, err := NewLabelMatcher_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return LabelMatcher_List{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}
func (s LabelNamesRequest) WithoutReplicaLabels() (capnp.UInt32List, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return capnp.UInt32List(p.List()), err
}

func (s LabelNamesRequest) HasWithoutReplicaLabels() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s LabelNamesRequest) SetWithoutReplicaLabels(v capnp.UInt32List) error {
	return capnp.Struct(s).SetPtr(3, v.ToPtr())
}

// NewWithoutReplicaLabels sets the withoutReplicaLabels field to a newly
// allocated capnp.UInt32List, preferring placement in s's segment.
func (s LabelNamesRequest) NewWithoutReplicaLabels(n int32) (capnp.UInt32List, error) {
	l, err := capnp.NewUInt32List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.UInt32List{}, err
	}
	err = capnp.Struct(s).SetPtr(3, l.ToPtr())
	return l, err
}
func (s LabelNamesRequest) Limit() int64 {
	return int64(capnp.Struct(s).Uint64(24))
}

func (s LabelNamesRequest) SetLimit(v int64) {
	capnp.Struct(s).SetUint64(24, uint64(v))
}

// LabelNamesRequest_List is a list of LabelNamesRequest.
type LabelNamesRequest_List = capnp.StructList[LabelNamesRequest]

// NewLabelNamesRequest creates a new list of LabelNamesRequest.
func NewLabelNamesRequest_List(s *capnp.Segment, sz int32) (LabelNamesRequest_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 32, PointerCount: 4}, sz)
	return capnp.StructList[LabelNamesRequest](l), err
}

// LabelNamesRequest_Future is a wrapper for a LabelNamesRequest promised by a client call.
type LabelNamesRequest_Future struct{ *capnp.Future }

func (f LabelNamesRequest_Future) Struct() (LabelNamesRequest, error) {
	p, err := f.Future.Ptr()
	return LabelNamesRequest(p.Struct()), err
}
func (p LabelNamesRequest_Future) Symbols() Symbols_Future {
	return Symbols_Future{Future: p.Future.Field(0, nil)}
}

type LabelNamesResponse capnp.Struct

// LabelNamesResponse_TypeID is the unique identifier for the type LabelNamesResponse.
const LabelNamesResponse_TypeID = 0x8848ba07bca77e3b

func NewLabelNamesResponse(s *capnp.Segment) (LabelNamesResponse, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4})
	return LabelNamesResponse(st), err
}

func NewRootLabelNamesResponse(s *capnp.Segment) (LabelNamesResponse, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4})
	return LabelNamesResponse(st), err
}

func ReadRootLabelNamesResponse(msg *capnp.Message) (LabelNamesResponse, error) {
	root, err := msg.Root()
	return LabelNamesResponse(root.Struct()), err
}

func (s LabelNamesResponse) String() string {
	str, _ := text.Marshal(0x8848ba07bca77e3b, capnp.Struct(s))
	return str
}

func (s LabelNamesResponse) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (LabelNamesResponse) DecodeFromPtr(p capnp.Ptr) LabelNamesResponse {
	return LabelNamesResponse(capnp.Struct{}.DecodeFromPtr(p))
}

func (s LabelNamesResponse) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s LabelNamesResponse) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s LabelNamesResponse) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s LabelNamesResponse) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s LabelNamesResponse) Symbols() (Symbols, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Symbols(p.Struct()), err
}

func (s LabelNamesResponse) HasSymbols() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s LabelNamesResponse) SetSymbols(v Symbols) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewSymbols sets the symbols field to a newly
// allocated Symbols struct, preferring placement in s's segment.
func (s LabelNamesResponse) NewSymbols() (Symbols, error) {
	ss, err := NewSymbols(capnp.Struct(s).Segment())
	if err != nil {
		return Symbols{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s LabelNamesResponse) Names() (capnp.UInt32List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.UInt32List(p.List()), err
}

func (s LabelNamesResponse) HasNames() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s LabelNamesResponse) SetNames(v capnp.UInt32List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewNames sets the names field to a newly
// allocated capnp.UInt32List, preferring placement in s's segment.
func (s LabelNamesResponse) NewNames(n int32) (capnp.UInt32List, error) {
	l, err := capnp.NewUInt32List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.UInt32List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s LabelNamesResponse) Warnings() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return capnp.TextList(p.List()), err
}

func (s LabelNamesResponse) HasWarnings() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s LabelNamesResponse) SetWarnings(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewWarnings sets the warnings field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s LabelNamesResponse) NewWarnings(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}
func (s LabelNamesResponse) Hints() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return []byte(p.Data()), err
}

func (s LabelNamesResponse) HasHints() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s LabelNamesResponse) SetHints(v []byte) error {
	return capnp.Struct(s).SetData(3, v)
}

// LabelNamesResponse_List is a list of LabelNamesResponse.
type LabelNamesResponse_List = capnp.StructList[LabelNamesResponse]

// NewLabelNamesResponse creates a new list of LabelNamesResponse.
func NewLabelNamesResponse_List(s *capnp.Segment, sz int32) (LabelNamesResponse_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4}, sz)
	return capnp.StructList[LabelNamesResponse](l), err
}

// LabelNamesResponse_Future is a wrapper for a LabelNamesResponse promised by a client call.
type LabelNamesResponse_Future struct{ *capnp.Future }

func (f LabelNamesResponse_Future) Struct() (LabelNamesResponse, error) {
	p, err := f.Future.Ptr()
	return LabelNamesResponse(p.Struct()), err
}
func (p LabelNamesResponse_Future) Symbols() Symbols_Future {
	return Symbols_Future{Future: p.Future.Field(0, nil)}
}

type LabelValuesRequest capnp.Struct

// LabelValuesRequest_TypeID is the unique identifier for the type LabelValuesRequest.
const LabelValuesRequest_TypeID = 0xb6243c7cf0acb987

func NewLabelValuesRequest(s *capnp.Segment) (LabelValuesRequest, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 32, PointerCount: 4})
	return LabelValuesRequest(st), err
}

func NewRootLabelValuesRequest(s *capnp.Segment) (LabelValuesRequest, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 32, PointerCount: 4})
	return LabelValuesRequest(st), err
}

func ReadRootLabelValuesRequest(msg *capnp.Message) (LabelValuesRequest, error) {
	root, err := msg.Root()
	return LabelValuesRequest(root.Struct()), err
}

func (s LabelValuesRequest) String() string {
	str, _ := text.Marshal(0xb6243c7cf0acb987, capnp.Struct(s))
	return str
}

func (s LabelValuesRequest) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (LabelValuesRequest) DecodeFromPtr(p capnp.Ptr) LabelValuesRequest {
	return LabelValuesRequest(capnp.Struct{}.DecodeFromPtr(p))
}

func (s LabelValuesRequest) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s LabelValuesRequest) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s LabelValuesRequest) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s LabelValuesRequest) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s LabelValuesRequest) Symbols() (Symbols, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Symbols(p.Struct()), err
}

func (s LabelValuesRequest) HasSymbols() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s LabelValuesRequest) SetSymbols(v Symbols) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewSymbols sets the symbols field to a newly
// allocated Symbols struct, preferring placement in s's segment.
func (s LabelValuesRequest) NewSymbols() (Symbols, error) {
	ss, err := NewSymbols(capnp.Struct(s).Segment())
	if err != nil {
		return Symbols{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s LabelValuesRequest) Label() uint32 {
	return capnp.Struct(s).Uint32(0)
}

func (s LabelValuesRequest) SetLabel(v uint32) {
	capnp.Struct(s).SetUint32(0, v)
}

func (s LabelValuesRequest) PartialResponseDisabled() bool {
	return capnp.Struct(s).Bit(32)
}

func (s LabelValuesRequest) SetPartialResponseDisabled(v bool) {
	capnp.Struct(s).SetBit(32, v)
}

func (s LabelValuesRequest) PartialResponseStrategy() PartialResponseStrategy {
	return PartialResponseStrategy(capnp.Struct(s).Uint16(6))
}

func (s LabelValuesRequest) SetPartialResponseStrategy(v PartialResponseStrategy) {
	capnp.Struct(s).SetUint16(6, uint16(v))
}

func (s LabelValuesRequest) Start() int64 {
	return int64(capnp.Struct(s).Uint64(8))
}

func (s LabelValuesRequest) SetStart(v int64) {
	capnp.Struct(s).SetUint64(8, uint64(v))
}

func (s LabelValuesRequest) End() int64 {
	return int64(capnp.Struct(s).Uint64(16))
}

func (s LabelValuesRequest) SetEnd(v int64) {
	capnp.Struct(s).SetUint64(16, uint64(v))
}

func (s LabelValuesRequest) Hints() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s LabelValuesRequest) HasHints() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s LabelValuesRequest) SetHints(v []byte) error {
	return capnp.Struct(s).SetData(1, v)
}

func (s LabelValuesRequest) Matchers() (LabelMatcher_List, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return LabelMatcher_List(p.List()), err
}

func (s LabelValuesRequest) HasMatchers() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s LabelValuesRequest) SetMatchers(v LabelMatcher_List) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewMatchers sets the matchers field to a newly
// allocated LabelMatcher_List, preferring placement in s's segment.
func (s LabelValuesRequest) NewMatchers(n int32) (LabelMatcher_List, error) {
	l, err := NewLabelMatcher_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return LabelMatcher_List{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}
func (s LabelValuesRequest) WithoutReplicaLabels() (capnp.UInt32List, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return capnp.UInt32List(p.List()), err
}

func (s LabelValuesRequest) HasWithoutReplicaLabels() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s LabelValuesRequest) SetWithoutReplicaLabels(v capnp.UInt32List) error {
	return capnp.Struct(s).SetPtr(3, v.ToPtr())
}

// NewWithoutReplicaLabels sets the withoutReplicaLabels field to a newly
// allocated capnp.UInt32List, preferring placement in s's segment.
func (s LabelValuesRequest) NewWithoutReplicaLabels(n int32) (capnp.UInt32List, error) {
	l, err := capnp.NewUInt32List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.UInt32List{}, err
	}
	err = capnp.Struct(s).SetPtr(3, l.ToPtr())
	return l, err
}
func (s LabelValuesRequest) Limit() int64 {
	return int64(capnp.Struct(s).Uint64(24))
}

func (s LabelValuesRequest) SetLimit(v int64) {
	capnp.Struct(s).SetUint64(24, uint64(v))
}

// LabelValuesRequest_List is a list of LabelValuesRequest.
type LabelValuesRequest_List = capnp.StructList[LabelValuesRequest]

// NewLabelValuesRequest creates a new list of LabelValuesRequest.
func NewLabelValuesRequest_List(s *capnp.Segment, sz int32) (LabelValuesRequest_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 32, PointerCount: 4}, sz)
	return capnp.StructList[LabelValuesRequest](l), err
}

// LabelValuesRequest_Future is a wrapper for a LabelValuesRequest promised by a client call.
type LabelValuesRequest_Future struct{ *capnp.Future }

func (f LabelValuesRequest_Future) Struct() (LabelValuesRequest, error) {
	p, err := f.Future.Ptr()
	return LabelValuesRequest(p.Struct()), err
}
func (p LabelValuesRequest_Future) Symbols() Symbols_Future {
	return Symbols_Future{Future: p.Future.Field(0, nil)}
}

type LabelValuesResponse capnp.Struct

// LabelValuesResponse_TypeID is the unique identifier for the type LabelValuesResponse.
const LabelValuesResponse_TypeID = 0xb95f1426dba0c0cb

func NewLabelValuesResponse(s *capnp.Segment) (LabelValuesResponse, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4})
	return LabelValuesResponse(st), err
}

func NewRootLabelValuesResponse(s *capnp.Segment) (LabelValuesResponse, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4})
	return LabelValuesResponse(st), err
}

func ReadRootLabelValuesResponse(msg *capnp.Message) (LabelValuesResponse, error) {
	root, err := msg.Root()
	return LabelValuesResponse(root.Struct()), err
}

func (s LabelValuesResponse) String() string {
	str, _ := text.Marshal(0xb95f1426dba0c0cb, capnp.Struct(s))
	return str
}

func (s LabelValuesResponse) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (LabelValuesResponse) DecodeFromPtr(p capnp.Ptr) LabelValuesResponse {
	return LabelValuesResponse(capnp.Struct{}.DecodeFromPtr(p))
}

func (s LabelValuesResponse) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s LabelValuesResponse) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s LabelValuesResponse) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s LabelValuesResponse) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s LabelValuesResponse) Symbols() (Symbols, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Symbols(p.Struct()), err
}

func (s LabelValuesResponse) HasSymbols() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s LabelValuesResponse) SetSymbols(v Symbols) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewSymbols sets the symbols field to a newly
// allocated Symbols struct, preferring placement in s's segment.
func (s LabelValuesResponse) NewSymbols() (Symbols, error) {
	ss, err := NewSymbols(capnp.Struct(s).Segment())
	if err != nil {
		return Symbols{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s LabelValuesResponse) Values() (capnp.UInt32List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.UInt32List(p.List()), err
}

func (s LabelValuesResponse) HasValues() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s LabelValuesResponse) SetValues(v capnp.UInt32List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewValues sets the values field to a newly
// allocated capnp.UInt32List, preferring placement in s's segment.
func (s LabelValuesResponse) NewValues(n int32) (capnp.UInt32List, error) {
	l, err := capnp.NewUInt32List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.UInt32List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s LabelValuesResponse) Warnings() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return capnp.TextList(p.List()), err
}

func (s LabelValuesResponse) HasWarnings() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s LabelValuesResponse) SetWarnings(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewWarnings sets the warnings field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s LabelValuesResponse) NewWarnings(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}
func (s LabelValuesResponse) Hints() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return []byte(p.Data()), err
}

func (s LabelValuesResponse) HasHints() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s LabelValuesResponse) SetHints(v []byte) error {
	return capnp.Struct(s).SetData(3, v)
}

// LabelValuesResponse_List is a list of LabelValuesResponse.
type LabelValuesResponse_List = capnp.StructList[LabelValuesResponse]

// NewLabelValuesResponse creates a new list of LabelValuesResponse.
func NewLabelValuesResponse_List(s *capnp.Segment, sz int32) (LabelValuesResponse_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4}, sz)
	return capnp.StructList[LabelValuesResponse](l), err
}

// LabelValuesResponse_Future is a wrapper for a LabelValuesResponse promised by a client call.
type LabelValuesResponse_Future struct{ *capnp.Future }

func (f LabelValuesResponse_Future) Struct() (LabelValuesResponse, error) {
	p, err := f.Future.Ptr()
	return LabelValuesResponse(p.Struct()), err
}
func (p LabelValuesResponse_Future) Symbols() Symbols_Future {
	return Symbols_Future{Future: p.Future.Field(0, nil)}
}

type StoreError uint16

// StoreError_TypeID is the unique identifier for the type StoreError.
const StoreError_TypeID = 0xf2c35399142d475a

// Values of StoreError.
const (
	StoreError_none              StoreError = 0
	StoreError_unavailable       StoreError = 1
	StoreError_invalidArgument   StoreError = 2
	StoreError_notFound          StoreError = 3
	StoreError_internal          StoreError = 4
	StoreError_resourceExhausted StoreError = 5
)

// String returns the enum's constant name.
func (c StoreError) String() string {
	switch c {
	case StoreError_none:
		return "none"
	case StoreError_unavailable:
		return "unavailable"
	case StoreError_invalidArgument:
		return "invalidArgument"
	case StoreError_notFound:
		return "notFound"
	case StoreError_internal:
		return "internal"
	case StoreError_resourceExhausted:
		return "resourceExhausted"

	default:
		return ""
	}
}

// StoreErrorFromString returns the enum value with a name,
// or the zero value if there's no such value.
func StoreErrorFromString(c string) StoreError {
	switch c {
	case "none":
		return StoreError_none
	case "unavailable":
		return StoreError_unavailable
	case "invalidArgument":
		return StoreError_invalidArgument
	case "notFound":
		return StoreError_notFound
	case "internal":
		return StoreError_internal
	case "resourceExhausted":
		return StoreError_resourceExhausted

	default:
		return 0
	}
}

type StoreError_List = capnp.EnumList[StoreError]

func NewStoreError_List(s *capnp.Segment, sz int32) (StoreError_List, error) {
	return capnp.NewEnumList[StoreError](s, sz)
}

type LabelSet capnp.Struct

// LabelSet_TypeID is the unique identifier for the type LabelSet.
const LabelSet_TypeID = 0xd7a8e8a3af2f1e82

func NewLabelSet(s *capnp.Segment) (LabelSet, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return LabelSet(st), err
}

func NewRootLabelSet(s *capnp.Segment) (LabelSet, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return LabelSet(st), err
}

func ReadRootLabelSet(msg *capnp.Message) (LabelSet, error) {
	root, err := msg.Root()
	return LabelSet(root.Struct()), err
}

func (s LabelSet) String() string {
	str, _ := text.Marshal(0xd7a8e8a3af2f1e82, capnp.Struct(s))
	return str
}

func (s LabelSet) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (LabelSet) DecodeFromPtr(p capnp.Ptr) LabelSet {
	return LabelSet(capnp.Struct{}.DecodeFromPtr(p))
}

func (s LabelSet) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s LabelSet) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s LabelSet) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s LabelSet) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s LabelSet) Labels() (Label_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Label_List(p.List()), err
}

func (s LabelSet) HasLabels() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s LabelSet) SetLabels(v Label_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLabels sets the labels field to a newly
// allocated Label_List, preferring placement in s's segment.
func (s LabelSet) NewLabels(n int32) (Label_List, error) {
	l, err := NewLabel_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Label_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// LabelSet_List is a list of LabelSet.
type LabelSet_List = capnp.StructList[LabelSet]

// NewLabelSet creates a new list of LabelSet.
func NewLabelSet_List(s *capnp.Segment, sz int32) (LabelSet_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[LabelSet](l), err
}

// LabelSet_Future is a wrapper for a LabelSet promised by a client call.
type LabelSet_Future struct{ *capnp.Future }

func (f LabelSet_Future) Struct() (LabelSet, error) {
	p, err := f.Future.Ptr()
	return LabelSet(p.Struct()), err
}

type TSDBInfo capnp.Struct

// TSDBInfo_TypeID is the unique identifier for the type TSDBInfo.
const TSDBInfo_TypeID = 0xb044b8f3982b7295

func NewTSDBInfo(s *capnp.Segment) (TSDBInfo, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return TSDBInfo(st), err
}

func NewRootTSDBInfo(s *capnp.Segment) (TSDBInfo, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return TSDBInfo(st), err
}

func ReadRootTSDBInfo(msg *capnp.Message) (TSDBInfo, error) {
	root, err := msg.Root()
	return TSDBInfo(root.Struct()), err
}

func (s TSDBInfo) String() string {
	str, _ := text.Marshal(0xb044b8f3982b7295, capnp.Struct(s))
	return str
}

func (s TSDBInfo) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (TSDBInfo) DecodeFromPtr(p capnp.Ptr) TSDBInfo {
	return TSDBInfo(capnp.Struct{}.DecodeFromPtr(p))
}

func (s TSDBInfo) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s TSDBInfo) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s TSDBInfo) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s TSDBInfo) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s TSDBInfo) Labels() (LabelSet, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return LabelSet(p.Struct()), err
}

func (s TSDBInfo) HasLabels() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s TSDBInfo) SetLabels(v LabelSet) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewLabels sets the labels field to a newly
// allocated LabelSet struct, preferring placement in s's segment.
func (s TSDBInfo) NewLabels() (LabelSet, error) {
	ss, err := NewLabelSet(capnp.Struct(s).Segment())
	if err != nil {
		return LabelSet{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s TSDBInfo) MinTime() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s TSDBInfo) SetMinTime(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s TSDBInfo) MaxTime() int64 {
	return int64(capnp.Struct(s).Uint64(8))
}

func (s TSDBInfo) SetMaxTime(v int64) {
	capnp.Struct(s).SetUint64(8, uint64(v))
}

// TSDBInfo_List is a list of TSDBInfo.
type TSDBInfo_List = capnp.StructList[TSDBInfo]

// NewTSDBInfo creates a new list of TSDBInfo.
func NewTSDBInfo_List(s *capnp.Segment, sz int32) (TSDBInfo_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1}, sz)
	return capnp.StructList[TSDBInfo](l), err
}

// TSDBInfo_Future is a wrapper for a TSDBInfo promised by a client call.
type TSDBInfo_Future struct{ *capnp.Future }

func (f TSDBInfo_Future) Struct() (TSDBInfo, error) {
	p, err := f.Future.Ptr()
	return TSDBInfo(p.Struct()), err
}
func (p TSDBInfo_Future) Labels() LabelSet_Future {
	return LabelSet_Future{Future: p.Future.Field(0, nil)}
}

type StoreInfo capnp.Struct

// StoreInfo_TypeID is the unique identifier for the type StoreInfo.
const StoreInfo_TypeID = 0xa6644d2dd839aaae

func NewStoreInfo(s *capnp.Segment) (StoreInfo, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1})
	return StoreInfo(st), err
}

func NewRootStoreInfo(s *capnp.Segment) (StoreInfo, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1})
	return StoreInfo(st), err
}

func ReadRootStoreInfo(msg *capnp.Message) (StoreInfo, error) {
	root, err := msg.Root()
	return StoreInfo(root.Struct()), err
}

func (s StoreInfo) String() string {
	str, _ := text.Marshal(0xa6644d2dd839aaae, capnp.Struct(s))
	return str
}

func (s StoreInfo) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (StoreInfo) DecodeFromPtr(p capnp.Ptr) StoreInfo {
	return StoreInfo(capnp.Struct{}.DecodeFromPtr(p))
}

func (s StoreInfo) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s StoreInfo) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s StoreInfo) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s StoreInfo) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s StoreInfo) MinTime() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s StoreInfo) SetMinTime(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s StoreInfo) MaxTime() int64 {
	return int64(capnp.Struct(s).Uint64(8))
}

func (s StoreInfo) SetMaxTime(v int64) {
	capnp.Struct(s).SetUint64(8, uint64(v))
}

func (s StoreInfo) SupportsSharding() bool {
	return capnp.Struct(s).Bit(128)
}

func (s StoreInfo) SetSupportsSharding(v bool) {
	capnp.Struct(s).SetBit(128, v)
}

func (s StoreInfo) SupportsWithoutReplicaLabels() bool {
	return capnp.Struct(s).Bit(129)
}

func (s StoreInfo) SetSupportsWithoutReplicaLabels(v bool) {
	capnp.Struct(s).SetBit(129, v)
}

func (s StoreInfo) TsdbInfos() (TSDBInfo_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return TSDBInfo_List(p.List()), err
}

func (s StoreInfo) HasTsdbInfos() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s StoreInfo) SetTsdbInfos(v TSDBInfo_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewTsdbInfos sets the tsdbInfos field to a newly
// allocated TSDBInfo_List, preferring placement in s's segment.
func (s StoreInfo) NewTsdbInfos(n int32) (TSDBInfo_List, error) {
	l, err := NewTSDBInfo_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return TSDBInfo_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// StoreInfo_List is a list of StoreInfo.
type StoreInfo_List = capnp.StructList[StoreInfo]

// NewStoreInfo creates a new list of StoreInfo.
func NewStoreInfo_List(s *capnp.Segment, sz int32) (StoreInfo_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1}, sz)
	return capnp.StructList[StoreInfo](l), err
}

// StoreInfo_Future is a wrapper for a StoreInfo promised by a client call.
type StoreInfo_Future struct{ *capnp.Future }

func (f StoreInfo_Future) Struct() (StoreInfo, error) {
	p, err := f.Future.Ptr()
	return StoreInfo(p.Struct()), err
}

type InfoRequest capnp.Struct

// InfoRequest_TypeID is the unique identifier for the type InfoRequest.
const InfoRequest_TypeID = 0xba2034bb0210221e

func NewInfoRequest(s *capnp.Segment) (InfoRequest, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return InfoRequest(st), err
}

func NewRootInfoRequest(s *capnp.Segment) (InfoRequest, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return InfoRequest(st), err
}

func ReadRootInfoRequest(msg *capnp.Message) (InfoRequest, error) {
	root, err := msg.Root()
	return InfoRequest(root.Struct()), err
}

func (s InfoRequest) String() string {
	str, _ := text.Marshal(0xba2034bb0210221e, capnp.Struct(s))
	return str
}

func (s InfoRequest) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (InfoRequest) DecodeFromPtr(p capnp.Ptr) InfoRequest {
	return InfoRequest(capnp.Struct{}.DecodeFromPtr(p))
}

func (s InfoRequest) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s InfoRequest) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s InfoRequest) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s InfoRequest) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// InfoRequest_List is a list of InfoRequest.
type InfoRequest_List = capnp.StructList[InfoRequest]

// NewInfoRequest creates a new list of InfoRequest.
func NewInfoRequest_List(s *capnp.Segment, sz int32) (InfoRequest_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[InfoRequest](l), err
}

// InfoRequest_Future is a wrapper for a InfoRequest promised by a client call.
type InfoRequest_Future struct{ *capnp.Future }

func (f InfoRequest_Future) Struct() (InfoRequest, error) {
	p, err := f.Future.Ptr()
	return InfoRequest(p.Struct()), err
}

type InfoResponse capnp.Struct

// InfoResponse_TypeID is the unique identifier for the type InfoResponse.
const InfoResponse_TypeID = 0xbad96054f319c3cd

func NewInfoResponse(s *capnp.Segment) (InfoResponse, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return InfoResponse(st), err
}

func NewRootInfoResponse(s *capnp.Segment) (InfoResponse, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return InfoResponse(st), err
}

func ReadRootInfoResponse(msg *capnp.Message) (InfoResponse, error) {
	root, err := msg.Root()
	return InfoResponse(root.Struct()), err
}

func (s InfoResponse) String() string {
	str, _ := text.Marshal(0xbad96054f319c3cd, capnp.Struct(s))
	return str
}

func (s InfoResponse) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (InfoResponse) DecodeFromPtr(p capnp.Ptr) InfoResponse {
	return InfoResponse(capnp.Struct{}.DecodeFromPtr(p))
}

func (s InfoResponse) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s InfoResponse) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s InfoResponse) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s InfoResponse) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s InfoResponse) Symbols() (Symbols, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Symbols(p.Struct()), err
}

func (s InfoResponse) HasSymbols() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s InfoResponse) SetSymbols(v Symbols) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewSymbols sets the symbols field to a newly
// allocated Symbols struct, preferring placement in s's segment.
func (s InfoResponse) NewSymbols() (Symbols, error) {
	ss, err := NewSymbols(capnp.Struct(s).Segment())
	if err != nil {
		return Symbols{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s InfoResponse) LabelSets() (LabelSet_List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return LabelSet_List(p.List()), err
}

func (s InfoResponse) HasLabelSets() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s InfoResponse) SetLabelSets(v LabelSet_List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewLabelSets sets the labelSets field to a newly
// allocated LabelSet_List, preferring placement in s's segment.
func (s InfoResponse) NewLabelSets(n int32) (LabelSet_List, error) {
	l, err := NewLabelSet_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return LabelSet_List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s InfoResponse) StoreInfo() (StoreInfo, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return StoreInfo(p.Struct()), err
}

func (s InfoResponse) HasStoreInfo() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s InfoResponse) SetStoreInfo(v StoreInfo) error {
	return capnp.Struct(s).SetPtr(2, capnp.Struct(v).ToPtr())
}

// NewStoreInfo sets the storeInfo field to a newly
// allocated StoreInfo struct, preferring placement in s's segment.
func (s InfoResponse) NewStoreInfo() (StoreInfo, error) {
	ss, err := NewStoreInfo(capnp.Struct(s).Segment())
	if err != nil {
		return StoreInfo{}, err
	}
	err = capnp.Struct(s).SetPtr(2, capnp.Struct(ss).ToPtr())
	return ss, err
}

// InfoResponse_List is a list of InfoResponse.
type InfoResponse_List = capnp.StructList[InfoResponse]

// NewInfoResponse creates a new list of InfoResponse.
func NewInfoResponse_List(s *capnp.Segment, sz int32) (InfoResponse_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return capnp.StructList[InfoResponse](l), err
}

// InfoResponse_Future is a wrapper for a InfoResponse promised by a client call.
type InfoResponse_Future struct{ *capnp.Future }

func (f InfoResponse_Future) Struct() (InfoResponse, error) {
	p, err := f.Future.Ptr()
	return InfoResponse(p.Struct()), err
}
func (p InfoResponse_Future) Symbols() Symbols_Future {
	return Symbols_Future{Future: p.Future.Field(0, nil)}
}
func (p InfoResponse_Future) StoreInfo() StoreInfo_Future {
	return StoreInfo_Future{Future: p.Future.Field(2, nil)}
}

type Store capnp.Client

// Store_TypeID is the unique identifier for the type Store.
const Store_TypeID = 0xc49a7cec019b7be9

func (c Store) Info(ctx context.Context, params func(Store_info_Params) error) (Store_info_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xc49a7cec019b7be9,
			MethodID:      0,
			InterfaceName: "pkg/store/storecapnp/store.capnp:Store",
			MethodName:    "info",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Store_info_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Store_info_Results_Future{Future: ans.Future()}, release

}

func (c Store) Series(ctx context.Context, params func(Store_series_Params) error) (Store_series_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xc49a7cec019b7be9,
			MethodID:      1,
			InterfaceName: "pkg/store/storecapnp/store.capnp:Store",
			MethodName:    "series",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Store_series_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Store_series_Results_Future{Future: ans.Future()}, release

}

func (c Store) LabelNames(ctx context.Context, params func(Store_labelNames_Params) error) (Store_labelNames_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xc49a7cec019b7be9,
			MethodID:      2,
			InterfaceName: "pkg/store/storecapnp/store.capnp:Store",
			MethodName:    "labelNames",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Store_labelNames_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Store_labelNames_Results_Future{Future: ans.Future()}, release

}

func (c Store) LabelValues(ctx context.Context, params func(Store_labelValues_Params) error) (Store_labelValues_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xc49a7cec019b7be9,
			MethodID:      3,
			InterfaceName: "pkg/store/storecapnp/store.capnp:Store",
			MethodName:    "labelValues",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Store_labelValues_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Store_labelValues_Results_Future{Future: ans.Future()}, release

}

func (c Store) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Store) String() string {
	return "Store(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Store) AddRef() Store {
	return Store(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Store) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Store) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Store) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Store) DecodeFromPtr(p capnp.Ptr) Store {
	return Store(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Store) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Store) IsSame(other Store) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Store) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Store) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Store_Server is a Store with a local implementation.
type Store_Server interface {
	Info(context.Context, Store_info) error

	Series(context.Context, Store_series) error

	LabelNames(context.Context, Store_labelNames) error

	LabelValues(context.Context, Store_labelValues) error
}

// Store_NewServer creates a new Server from an implementation of Store_Server.
func Store_NewServer(s Store_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Store_Methods(nil, s), s, c)
}

// Store_ServerToClient creates a new Client from an implementation of Store_Server.
// The caller is responsible for calling Release on the returned Client.
func Store_ServerToClient(s Store_Server) Store {
	return Store(capnp.NewClient(Store_NewServer(s)))
}

// Store_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Store_Methods(methods []server.Method, s Store_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 4)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xc49a7cec019b7be9,
			MethodID:      0,
			InterfaceName: "pkg/store/storecapnp/store.capnp:Store",
			MethodName:    "info",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Info(ctx, Store_info{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xc49a7cec019b7be9,
			MethodID:      1,
			InterfaceName: "pkg/store/storecapnp/store.capnp:Store",
			MethodName:    "series",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Series(ctx, Store_series{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xc49a7cec019b7be9,
			MethodID:      2,
			InterfaceName: "pkg/store/storecapnp/store.capnp:Store",
			MethodName:    "labelNames",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.LabelNames(ctx, Store_labelNames{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xc49a7cec019b7be9,
			MethodID:      3,
			InterfaceName: "pkg/store/storecapnp/store.capnp:Store",
			MethodName:    "labelValues",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.LabelValues(ctx, Store_labelValues{call})
		},
	})

	return methods
}

// Store_info holds the state for a server call to Store.info.
// See server.Call for documentation.
type Store_info struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Store_info) Args() Store_info_Params {
	return Store_info_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Store_info) AllocResults() (Store_info_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Store_info_Results(r), err
}

// Store_series holds the state for a server call to Store.series.
// See server.Call for documentation.
type Store_series struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Store_series) Args() Store_series_Params {
	return Store_series_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Store_series) AllocResults() (Store_series_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Store_series_Results(r), err
}

// Store_labelNames holds the state for a server call to Store.labelNames.
// See server.Call for documentation.
type Store_labelNames struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Store_labelNames) Args() Store_labelNames_Params {
	return Store_labelNames_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Store_labelNames) AllocResults() (Store_labelNames_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Store_labelNames_Results(r), err
}

// Store_labelValues holds the state for a server call to Store.labelValues.
// See server.Call for documentation.
type Store_labelValues struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Store_labelValues) Args() Store_labelValues_Params {
	return Store_labelValues_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Store_labelValues) AllocResults() (Store_labelValues_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Store_labelValues_Results(r), err
}

// Store_List is a list of Store.
type Store_List = capnp.CapList[Store]

// NewStore_List creates a new list of Store.
func NewStore_List(s *capnp.Segment, sz int32) (Store_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Store](l), err
}

type Store_info_Params capnp.Struct

// Store_info_Params_TypeID is the unique identifier for the type Store_info_Params.
const Store_info_Params_TypeID = 0xae476e080c731352

func NewStore_info_Params(s *capnp.Segment) (Store_info_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Store_info_Params(st), err
}

func NewRootStore_info_Params(s *capnp.Segment) (Store_info_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Store_info_Params(st), err
}

func ReadRootStore_info_Params(msg *capnp.Message) (Store_info_Params, error) {
	root, err := msg.Root()
	return Store_info_Params(root.Struct()), err
}

func (s Store_info_Params) String() string {
	str, _ := text.Marshal(0xae476e080c731352, capnp.Struct(s))
	return str
}

func (s Store_info_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Store_info_Params) DecodeFromPtr(p capnp.Ptr) Store_info_Params {
	return Store_info_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Store_info_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Store_info_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Store_info_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Store_info_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Store_info_Params) Req() (InfoRequest, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return InfoRequest(p.Struct()), err
}

func (s Store_info_Params) HasReq() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Store_info_Params) SetReq(v InfoRequest) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewReq sets the req field to a newly
// allocated InfoRequest struct, preferring placement in s's segment.
func (s Store_info_Params) NewReq() (InfoRequest, error) {
	ss, err := NewInfoRequest(capnp.Struct(s).Segment())
	if err != nil {
		return InfoRequest{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Store_info_Params_List is a list of Store_info_Params.
type Store_info_Params_List = capnp.StructList[Store_info_Params]

// NewStore_info_Params creates a new list of Store_info_Params.
func NewStore_info_Params_List(s *capnp.Segment, sz int32) (Store_info_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Store_info_Params](l), err
}

// Store_info_Params_Future is a wrapper for a Store_info_Params promised by a client call.
type Store_info_Params_Future struct{ *capnp.Future }

func (f Store_info_Params_Future) Struct() (Store_info_Params, error) {
	p, err := f.Future.Ptr()
	return Store_info_Params(p.Struct()), err
}
func (p Store_info_Params_Future) Req() InfoRequest_Future {
	return InfoRequest_Future{Future: p.Future.Field(0, nil)}
}

type Store_info_Results capnp.Struct

// Store_info_Results_TypeID is the unique identifier for the type Store_info_Results.
const Store_info_Results_TypeID = 0x9c62bb2e0543c562

func NewStore_info_Results(s *capnp.Segment) (Store_info_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Store_info_Results(st), err
}

func NewRootStore_info_Results(s *capnp.Segment) (Store_info_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Store_info_Results(st), err
}

func ReadRootStore_info_Results(msg *capnp.Message) (Store_info_Results, error) {
	root, err := msg.Root()
	return Store_info_Results(root.Struct()), err
}

func (s Store_info_Results) String() string {
	str, _ := text.Marshal(0x9c62bb2e0543c562, capnp.Struct(s))
	return str
}

func (s Store_info_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Store_info_Results) DecodeFromPtr(p capnp.Ptr) Store_info_Results {
	return Store_info_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Store_info_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Store_info_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Store_info_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Store_info_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Store_info_Results) Resp() (InfoResponse, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return InfoResponse(p.Struct()), err
}

func (s Store_info_Results) HasResp() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Store_info_Results) SetResp(v InfoResponse) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewResp sets the resp field to a newly
// allocated InfoResponse struct, preferring placement in s's segment.
func (s Store_info_Results) NewResp() (InfoResponse, error) {
	ss, err := NewInfoResponse(capnp.Struct(s).Segment())
	if err != nil {
		return InfoResponse{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Store_info_Results) Error() StoreError {
	return StoreError(capnp.Struct(s).Uint16(0))
}

func (s Store_info_Results) SetError(v StoreError) {
	capnp.Struct(s).SetUint16(0, uint16(v))
}

func (s Store_info_Results) ErrorContext() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Store_info_Results) HasErrorContext() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Store_info_Results) ErrorContextBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Store_info_Results) SetErrorContext(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

// Store_info_Results_List is a list of Store_info_Results.
type Store_info_Results_List = capnp.StructList[Store_info_Results]

// NewStore_info_Results creates a new list of Store_info_Results.
func NewStore_info_Results_List(s *capnp.Segment, sz int32) (Store_info_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return capnp.StructList[Store_info_Results](l), err
}

// Store_info_Results_Future is a wrapper for a Store_info_Results promised by a client call.
type Store_info_Results_Future struct{ *capnp.Future }

func (f Store_info_Results_Future) Struct() (Store_info_Results, error) {
	p, err := f.Future.Ptr()
	return Store_info_Results(p.Struct()), err
}
func (p Store_info_Results_Future) Resp() InfoResponse_Future {
	return InfoResponse_Future{Future: p.Future.Field(0, nil)}
}

type Store_series_Params capnp.Struct

// Store_series_Params_TypeID is the unique identifier for the type Store_series_Params.
const Store_series_Params_TypeID = 0xfd3551e41714c18b

func NewStore_series_Params(s *capnp.Segment) (Store_series_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Store_series_Params(st), err
}

func NewRootStore_series_Params(s *capnp.Segment) (Store_series_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Store_series_Params(st), err
}

func ReadRootStore_series_Params(msg *capnp.Message) (Store_series_Params, error) {
	root, err := msg.Root()
	return Store_series_Params(root.Struct()), err
}

func (s Store_series_Params) String() string {
	str, _ := text.Marshal(0xfd3551e41714c18b, capnp.Struct(s))
	return str
}

func (s Store_series_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Store_series_Params) DecodeFromPtr(p capnp.Ptr) Store_series_Params {
	return Store_series_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Store_series_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Store_series_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Store_series_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Store_series_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Store_series_Params) Req() (SeriesRequest, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return SeriesRequest(p.Struct()), err
}

func (s Store_series_Params) HasReq() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Store_series_Params) SetReq(v SeriesRequest) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewReq sets the req field to a newly
// allocated SeriesRequest struct, preferring placement in s's segment.
func (s Store_series_Params) NewReq() (SeriesRequest, error) {
	ss, err := NewSeriesRequest(capnp.Struct(s).Segment())
	if err != nil {
		return SeriesRequest{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Store_series_Params_List is a list of Store_series_Params.
type Store_series_Params_List = capnp.StructList[Store_series_Params]

// NewStore_series_Params creates a new list of Store_series_Params.
func NewStore_series_Params_List(s *capnp.Segment, sz int32) (Store_series_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Store_series_Params](l), err
}

// Store_series_Params_Future is a wrapper for a Store_series_Params promised by a client call.
type Store_series_Params_Future struct{ *capnp.Future }

func (f Store_series_Params_Future) Struct() (Store_series_Params, error) {
	p, err := f.Future.Ptr()
	return Store_series_Params(p.Struct()), err
}
func (p Store_series_Params_Future) Req() SeriesRequest_Future {
	return SeriesRequest_Future{Future: p.Future.Field(0, nil)}
}

type Store_series_Results capnp.Struct

// Store_series_Results_TypeID is the unique identifier for the type Store_series_Results.
const Store_series_Results_TypeID = 0xffd43b81dc8b683b

func NewStore_series_Results(s *capnp.Segment) (Store_series_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Store_series_Results(st), err
}

func NewRootStore_series_Results(s *capnp.Segment) (Store_series_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Store_series_Results(st), err
}

func ReadRootStore_series_Results(msg *capnp.Message) (Store_series_Results, error) {
	root, err := msg.Root()
	return Store_series_Results(root.Struct()), err
}

func (s Store_series_Results) String() string {
	str, _ := text.Marshal(0xffd43b81dc8b683b, capnp.Struct(s))
	return str
}

func (s Store_series_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Store_series_Results) DecodeFromPtr(p capnp.Ptr) Store_series_Results {
	return Store_series_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Store_series_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Store_series_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Store_series_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Store_series_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Store_series_Results) Stream() SeriesStream {
	p, _ := capnp.Struct(s).Ptr(0)
	return SeriesStream(p.Interface().Client())
}

func (s Store_series_Results) HasStream() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Store_series_Results) SetStream(v SeriesStream) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// Store_series_Results_List is a list of Store_series_Results.
type Store_series_Results_List = capnp.StructList[Store_series_Results]

// NewStore_series_Results creates a new list of Store_series_Results.
func NewStore_series_Results_List(s *capnp.Segment, sz int32) (Store_series_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Store_series_Results](l), err
}

// Store_series_Results_Future is a wrapper for a Store_series_Results promised by a client call.
type Store_series_Results_Future struct{ *capnp.Future }

func (f Store_series_Results_Future) Struct() (Store_series_Results, error) {
	p, err := f.Future.Ptr()
	return Store_series_Results(p.Struct()), err
}
func (p Store_series_Results_Future) Stream() SeriesStream {
	return SeriesStream(p.Future.Field(0, nil).Client())
}

type Store_labelNames_Params capnp.Struct

// Store_labelNames_Params_TypeID is the unique identifier for the type Store_labelNames_Params.
const Store_labelNames_Params_TypeID = 0xc49090111f71fd66

func NewStore_labelNames_Params(s *capnp.Segment) (Store_labelNames_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Store_labelNames_Params(st), err
}

func NewRootStore_labelNames_Params(s *capnp.Segment) (Store_labelNames_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Store_labelNames_Params(st), err
}

func ReadRootStore_labelNames_Params(msg *capnp.Message) (Store_labelNames_Params, error) {
	root, err := msg.Root()
	return Store_labelNames_Params(root.Struct()), err
}

func (s Store_labelNames_Params) String() string {
	str, _ := text.Marshal(0xc49090111f71fd66, capnp.Struct(s))
	return str
}

func (s Store_labelNames_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Store_labelNames_Params) DecodeFromPtr(p capnp.Ptr) Store_labelNames_Params {
	return Store_labelNames_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Store_labelNames_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Store_labelNames_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Store_labelNames_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Store_labelNames_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Store_labelNames_Params) Req() (LabelNamesRequest, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return LabelNamesRequest(p.Struct()), err
}

func (s Store_labelNames_Params) HasReq() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Store_labelNames_Params) SetReq(v LabelNamesRequest) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewReq sets the req field to a newly
// allocated LabelNamesRequest struct, preferring placement in s's segment.
func (s Store_labelNames_Params) NewReq() (LabelNamesRequest, error) {
	ss, err := NewLabelNamesRequest(capnp.Struct(s).Segment())
	if err != nil {
		return LabelNamesRequest{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Store_labelNames_Params_List is a list of Store_labelNames_Params.
type Store_labelNames_Params_List = capnp.StructList[Store_labelNames_Params]

// NewStore_labelNames_Params creates a new list of Store_labelNames_Params.
func NewStore_labelNames_Params_List(s *capnp.Segment, sz int32) (Store_labelNames_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Store_labelNames_Params](l), err
}

// Store_labelNames_Params_Future is a wrapper for a Store_labelNames_Params promised by a client call.
type Store_labelNames_Params_Future struct{ *capnp.Future }

func (f Store_labelNames_Params_Future) Struct() (Store_labelNames_Params, error) {
	p, err := f.Future.Ptr()
	return Store_labelNames_Params(p.Struct()), err
}
func (p Store_labelNames_Params_Future) Req() LabelNamesRequest_Future {
	return LabelNamesRequest_Future{Future: p.Future.Field(0, nil)}
}

type Store_labelNames_Results capnp.Struct

// Store_labelNames_Results_TypeID is the unique identifier for the type Store_labelNames_Results.
const Store_labelNames_Results_TypeID = 0xf6e364eb000cd5a3

func NewStore_labelNames_Results(s *capnp.Segment) (Store_labelNames_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Store_labelNames_Results(st), err
}

func NewRootStore_labelNames_Results(s *capnp.Segment) (Store_labelNames_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Store_labelNames_Results(st), err
}

func ReadRootStore_labelNames_Results(msg *capnp.Message) (Store_labelNames_Results, error) {
	root, err := msg.Root()
	return Store_labelNames_Results(root.Struct()), err
}

func (s Store_labelNames_Results) String() string {
	str, _ := text.Marshal(0xf6e364eb000cd5a3, capnp.Struct(s))
	return str
}

func (s Store_labelNames_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Store_labelNames_Results) DecodeFromPtr(p capnp.Ptr) Store_labelNames_Results {
	return Store_labelNames_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Store_labelNames_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Store_labelNames_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Store_labelNames_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Store_labelNames_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Store_labelNames_Results) Resp() (LabelNamesResponse, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return LabelNamesResponse(p.Struct()), err
}

func (s Store_labelNames_Results) HasResp() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Store_labelNames_Results) SetResp(v LabelNamesResponse) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewResp sets the resp field to a newly
// allocated LabelNamesResponse struct, preferring placement in s's segment.
func (s Store_labelNames_Results) NewResp() (LabelNamesResponse, error) {
	ss, err := NewLabelNamesResponse(capnp.Struct(s).Segment())
	if err != nil {
		return LabelNamesResponse{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Store_labelNames_Results) Error() StoreError {
	return StoreError(capnp.Struct(s).Uint16(0))
}

func (s Store_labelNames_Results) SetError(v StoreError) {
	capnp.Struct(s).SetUint16(0, uint16(v))
}

func (s Store_labelNames_Results) ErrorContext() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Store_labelNames_Results) HasErrorContext() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Store_labelNames_Results) ErrorContextBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Store_labelNames_Results) SetErrorContext(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

// Store_labelNames_Results_List is a list of Store_labelNames_Results.
type Store_labelNames_Results_List = capnp.StructList[Store_labelNames_Results]

// NewStore_labelNames_Results creates a new list of Store_labelNames_Results.
func NewStore_labelNames_Results_List(s *capnp.Segment, sz int32) (Store_labelNames_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return capnp.StructList[Store_labelNames_Results](l), err
}

// Store_labelNames_Results_Future is a wrapper for a Store_labelNames_Results promised by a client call.
type Store_labelNames_Results_Future struct{ *capnp.Future }

func (f Store_labelNames_Results_Future) Struct() (Store_labelNames_Results, error) {
	p, err := f.Future.Ptr()
	return Store_labelNames_Results(p.Struct()), err
}
func (p Store_labelNames_Results_Future) Resp() LabelNamesResponse_Future {
	return LabelNamesResponse_Future{Future: p.Future.Field(0, nil)}
}

type Store_labelValues_Params capnp.Struct

// Store_labelValues_Params_TypeID is the unique identifier for the type Store_labelValues_Params.
const Store_labelValues_Params_TypeID = 0xb1f32db0c5cf1788

func NewStore_labelValues_Params(s *capnp.Segment) (Store_labelValues_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Store_labelValues_Params(st), err
}

func NewRootStore_labelValues_Params(s *capnp.Segment) (Store_labelValues_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Store_labelValues_Params(st), err
}

func ReadRootStore_labelValues_Params(msg *capnp.Message) (Store_labelValues_Params, error) {
	root, err := msg.Root()
	return Store_labelValues_Params(root.Struct()), err
}

func (s Store_labelValues_Params) String() string {
	str, _ := text.Marshal(0xb1f32db0c5cf1788, capnp.Struct(s))
	return str
}

func (s Store_labelValues_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Store_labelValues_Params) DecodeFromPtr(p capnp.Ptr) Store_labelValues_Params {
	return Store_labelValues_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Store_labelValues_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Store_labelValues_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Store_labelValues_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Store_labelValues_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Store_labelValues_Params) Req() (LabelValuesRequest, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return LabelValuesRequest(p.Struct()), err
}

func (s Store_labelValues_Params) HasReq() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Store_labelValues_Params) SetReq(v LabelValuesRequest) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewReq sets the req field to a newly
// allocated LabelValuesRequest struct, preferring placement in s's segment.
func (s Store_labelValues_Params) NewReq() (LabelValuesRequest, error) {
	ss, err := NewLabelValuesRequest(capnp.Struct(s).Segment())
	if err != nil {
		return LabelValuesRequest{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Store_labelValues_Params_List is a list of Store_labelValues_Params.
type Store_labelValues_Params_List = capnp.StructList[Store_labelValues_Params]

// NewStore_labelValues_Params creates a new list of Store_labelValues_Params.
func NewStore_labelValues_Params_List(s *capnp.Segment, sz int32) (Store_labelValues_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Store_labelValues_Params](l), err
}

// Store_labelValues_Params_Future is a wrapper for a Store_labelValues_Params promised by a client call.
type Store_labelValues_Params_Future struct{ *capnp.Future }

func (f Store_labelValues_Params_Future) Struct() (Store_labelValues_Params, error) {
	p, err := f.Future.Ptr()
	return Store_labelValues_Params(p.Struct()), err
}
func (p Store_labelValues_Params_Future) Req() LabelValuesRequest_Future {
	return LabelValuesRequest_Future{Future: p.Future.Field(0, nil)}
}

type Store_labelValues_Results capnp.Struct

// Store_labelValues_Results_TypeID is the unique identifier for the type Store_labelValues_Results.
const Store_labelValues_Results_TypeID = 0x9628c90d70c5038c

func NewStore_labelValues_Results(s *capnp.Segment) (Store_labelValues_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Store_labelValues_Results(st), err
}

func NewRootStore_labelValues_Results(s *capnp.Segment) (Store_labelValues_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Store_labelValues_Results(st), err
}

func ReadRootStore_labelValues_Results(msg *capnp.Message) (Store_labelValues_Results, error) {
	root, err := msg.Root()
	return Store_labelValues_Results(root.Struct()), err
}

func (s Store_labelValues_Results) String() string {
	str, _ := text.Marshal(0x9628c90d70c5038c, capnp.Struct(s))
	return str
}

func (s Store_labelValues_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Store_labelValues_Results) DecodeFromPtr(p capnp.Ptr) Store_labelValues_Results {
	return Store_labelValues_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Store_labelValues_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Store_labelValues_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Store_labelValues_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Store_labelValues_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Store_labelValues_Results) Resp() (LabelValuesResponse, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return LabelValuesResponse(p.Struct()), err
}

func (s Store_labelValues_Results) HasResp() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Store_labelValues_Results) SetResp(v LabelValuesResponse) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewResp sets the resp field to a newly
// allocated LabelValuesResponse struct, preferring placement in s's segment.
func (s Store_labelValues_Results) NewResp() (LabelValuesResponse, error) {
	ss, err := NewLabelValuesResponse(capnp.Struct(s).Segment())
	if err != nil {
		return LabelValuesResponse{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Store_labelValues_Results) Error() StoreError {
	return StoreError(capnp.Struct(s).Uint16(0))
}

func (s Store_labelValues_Results) SetError(v StoreError) {
	capnp.Struct(s).SetUint16(0, uint16(v))
}

func (s Store_labelValues_Results) ErrorContext() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Store_labelValues_Results) HasErrorContext() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Store_labelValues_Results) ErrorContextBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Store_labelValues_Results) SetErrorContext(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

// Store_labelValues_Results_List is a list of Store_labelValues_Results.
type Store_labelValues_Results_List = capnp.StructList[Store_labelValues_Results]

// NewStore_labelValues_Results creates a new list of Store_labelValues_Results.
func NewStore_labelValues_Results_List(s *capnp.Segment, sz int32) (Store_labelValues_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return capnp.StructList[Store_labelValues_Results](l), err
}

// Store_labelValues_Results_Future is a wrapper for a Store_labelValues_Results promised by a client call.
type Store_labelValues_Results_Future struct{ *capnp.Future }

func (f Store_labelValues_Results_Future) Struct() (Store_labelValues_Results, error) {
	p, err := f.Future.Ptr()
	return Store_labelValues_Results(p.Struct()), err
}
func (p Store_labelValues_Results_Future) Resp() LabelValuesResponse_Future {
	return LabelValuesResponse_Future{Future: p.Future.Field(0, nil)}
}

type SeriesStream capnp.Client

// SeriesStream_TypeID is the unique identifier for the type SeriesStream.
const SeriesStream_TypeID = 0xa3428059f37ddab9

func (c SeriesStream) Next(ctx context.Context, params func(SeriesStream_next_Params) error) (SeriesStream_next_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xa3428059f37ddab9,
			MethodID:      0,
			InterfaceName: "pkg/store/storecapnp/store.capnp:SeriesStream",
			MethodName:    "next",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(SeriesStream_next_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return SeriesStream_next_Results_Future{Future: ans.Future()}, release

}

func (c SeriesStream) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c SeriesStream) String() string {
	return "SeriesStream(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c SeriesStream) AddRef() SeriesStream {
	return SeriesStream(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c SeriesStream) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c SeriesStream) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c SeriesStream) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (SeriesStream) DecodeFromPtr(p capnp.Ptr) SeriesStream {
	return SeriesStream(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c SeriesStream) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c SeriesStream) IsSame(other SeriesStream) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c SeriesStream) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c SeriesStream) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A SeriesStream_Server is a SeriesStream with a local implementation.
type SeriesStream_Server interface {
	Next(context.Context, SeriesStream_next) error
}

// SeriesStream_NewServer creates a new Server from an implementation of SeriesStream_Server.
func SeriesStream_NewServer(s SeriesStream_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(SeriesStream_Methods(nil, s), s, c)
}

// SeriesStream_ServerToClient creates a new Client from an implementation of SeriesStream_Server.
// The caller is responsible for calling Release on the returned Client.
func SeriesStream_ServerToClient(s SeriesStream_Server) SeriesStream {
	return SeriesStream(capnp.NewClient(SeriesStream_NewServer(s)))
}

// SeriesStream_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func SeriesStream_Methods(methods []server.Method, s SeriesStream_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xa3428059f37ddab9,
			MethodID:      0,
			InterfaceName: "pkg/store/storecapnp/store.capnp:SeriesStream",
			MethodName:    "next",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Next(ctx, SeriesStream_next{call})
		},
	})

	return methods
}

// SeriesStream_next holds the state for a server call to SeriesStream.next.
// See server.Call for documentation.
type SeriesStream_next struct {
	*server.Call
}

// Args returns the call's arguments.
func (c SeriesStream_next) Args() SeriesStream_next_Params {
	return SeriesStream_next_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c SeriesStream_next) AllocResults() (SeriesStream_next_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return SeriesStream_next_Results(r), err
}

// SeriesStream_List is a list of SeriesStream.
type SeriesStream_List = capnp.CapList[SeriesStream]

// NewSeriesStream_List creates a new list of SeriesStream.
func NewSeriesStream_List(s *capnp.Segment, sz int32) (SeriesStream_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[SeriesStream](l), err
}

type SeriesStream_next_Params capnp.Struct

// SeriesStream_next_Params_TypeID is the unique identifier for the type SeriesStream_next_Params.
const SeriesStream_next_Params_TypeID = 0xe0a05c092b8ad329

func NewSeriesStream_next_Params(s *capnp.Segment) (SeriesStream_next_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return SeriesStream_next_Params(st), err
}

func NewRootSeriesStream_next_Params(s *capnp.Segment) (SeriesStream_next_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return SeriesStream_next_Params(st), err
}

func ReadRootSeriesStream_next_Params(msg *capnp.Message) (SeriesStream_next_Params, error) {
	root, err := msg.Root()
	return SeriesStream_next_Params(root.Struct()), err
}

func (s SeriesStream_next_Params) String() string {
	str, _ := text.Marshal(0xe0a05c092b8ad329, capnp.Struct(s))
	return str
}

func (s SeriesStream_next_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (SeriesStream_next_Params) DecodeFromPtr(p capnp.Ptr) SeriesStream_next_Params {
	return SeriesStream_next_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s SeriesStream_next_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s SeriesStream_next_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s SeriesStream_next_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s SeriesStream_next_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// SeriesStream_next_Params_List is a list of SeriesStream_next_Params.
type SeriesStream_next_Params_List = capnp.StructList[SeriesStream_next_Params]

// NewSeriesStream_next_Params creates a new list of SeriesStream_next_Params.
func NewSeriesStream_next_Params_List(s *capnp.Segment, sz int32) (SeriesStream_next_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[SeriesStream_next_Params](l), err
}

// SeriesStream_next_Params_Future is a wrapper for a SeriesStream_next_Params promised by a client call.
type SeriesStream_next_Params_Future struct{ *capnp.Future }

func (f SeriesStream_next_Params_Future) Struct() (SeriesStream_next_Params, error) {
	p, err := f.Future.Ptr()
	return SeriesStream_next_Params(p.Struct()), err
}

type SeriesStream_next_Results capnp.Struct

// SeriesStream_next_Results_TypeID is the unique identifier for the type SeriesStream_next_Results.
const SeriesStream_next_Results_TypeID = 0x88e81c42858378ad

func NewSeriesStream_next_Results(s *capnp.Segment) (SeriesStream_next_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return SeriesStream_next_Results(st), err
}

func NewRootSeriesStream_next_Results(s *capnp.Segment) (SeriesStream_next_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return SeriesStream_next_Results(st), err
}

func ReadRootSeriesStream_next_Results(msg *capnp.Message) (SeriesStream_next_Results, error) {
	root, err := msg.Root()
	return SeriesStream_next_Results(root.Struct()), err
}

func (s SeriesStream_next_Results) String() string {
	str, _ := text.Marshal(0x88e81c42858378ad, capnp.Struct(s))
	return str
}

func (s SeriesStream_next_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (SeriesStream_next_Results) DecodeFromPtr(p capnp.Ptr) SeriesStream_next_Results {
	return SeriesStream_next_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s SeriesStream_next_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s SeriesStream_next_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s SeriesStream_next_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s SeriesStream_next_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s SeriesStream_next_Results) Resp() (SeriesResponse, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return SeriesResponse(p.Struct()), err
}

func (s SeriesStream_next_Results) HasResp() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s SeriesStream_next_Results) SetResp(v SeriesResponse) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewResp sets the resp field to a newly
// allocated SeriesResponse struct, preferring placement in s's segment.
func (s SeriesStream_next_Results) NewResp() (SeriesResponse, error) {
	ss, err := NewSeriesResponse(capnp.Struct(s).Segment())
	if err != nil {
		return SeriesResponse{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s SeriesStream_next_Results) Done() bool {
	return capnp.Struct(s).Bit(0)
}

func (s SeriesStream_next_Results) SetDone(v bool) {
	capnp.Struct(s).SetBit(0, v)
}

func (s SeriesStream_next_Results) Error() StoreError {
	return StoreError(capnp.Struct(s).Uint16(2))
}

func (s SeriesStream_next_Results) SetError(v StoreError) {
	capnp.Struct(s).SetUint16(2, uint16(v))
}

func (s SeriesStream_next_Results) ErrorContext() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s SeriesStream_next_Results) HasErrorContext() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s SeriesStream_next_Results) ErrorContextBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s SeriesStream_next_Results) SetErrorContext(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

// SeriesStream_next_Results_List is a list of SeriesStream_next_Results.
type SeriesStream_next_Results_List = capnp.StructList[SeriesStream_next_Results]

// NewSeriesStream_next_Results creates a new list of SeriesStream_next_Results.
func NewSeriesStream_next_Results_List(s *capnp.Segment, sz int32) (SeriesStream_next_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return capnp.StructList[SeriesStream_next_Results](l), err
}

// SeriesStream_next_Results_Future is a wrapper for a SeriesStream_next_Results promised by a client call.
type SeriesStream_next_Results_Future struct{ *capnp.Future }

func (f SeriesStream_next_Results_Future) Struct() (SeriesStream_next_Results, error) {
	p, err := f.Future.Ptr()
	return SeriesStream_next_Results(p.Struct()), err
}
func (p SeriesStream_next_Results_Future) Resp() SeriesResponse_Future {
	return SeriesResponse_Future{Future: p.Future.Field(0, nil)}
}

const schema_b8e4c1f0a2d3e5f7 = "x\xda\xdcZ\x7fp\x14\xf7u\x7fo\xbfwZ\x09$" +
	"\xdf-{\x02K \x9d\xa4\xc8\x0d(\x88\x80\x80\x09\xc8" +
	"I\x85e\xb0\x81\x91\\\xed\x1du\x88\x86$\xde\xd3\xad" +
	"\xa4\xb5\xef\xf6N\xbb{ 9\x10\x8c]78\xe0L" +
	"\xe8\x94\xc4\xd0&\xb1q\x9d&\x1e\x9c\xd8M\xdc\x9a\xd8" +
	"\x99\x82\x13R\x87\xb6\x13'1S\xe2\xda\x1dh`B" +
	"\x1a3\xb6\x8b\xe3LfB\xb6\xf3\xbe{\xb7\xbb:I" +
	"\xe8l\xf8\xab\x7fi\xef\xdd\xbb\xf7}\xef}\xdf\xfb\xbc" +
	"\x1f\xab\xe5\xfb\xe7\xac\x0b\xad\xa8\xfb\xc9\x0d (G\xc3" +
	"U\xce\xafZ_W\xb5\xad\xfa}\xa0\xb4\xa2\xe0\xfc\xee" +
	"\xc2\xcf\x8f\xbcu\xe2\xfcs\x10\xae\x12\x01V\xf6\x8b\x83" +
	"(\xab\"=~R\xfc\x17\x04t~\xb4}\xdb\xbd\x9f" +
	"\xca>\xfc\x00H\xad\x01n\xc0\x95\xad5](\xaf\xa8" +
	"\x11\x01\xe4\xce\x9a/\x03:7\x7f\xf6\xef_\x10\xbf\xb7" +
	"q/H\xad\x18\x90\x1b\"ac5GP~\x883" +
	"?X\xf3+@\xe7\xa9\xf1\x07\x1e\xec]tq/(" +
	"\xcb\x10\x01\xc2\x02q\xed\x9a\xf3*\x02\xca\x07\xe6\x10\xc7" +
	"\xf2mGS_\x9f\xd0\xf6\x91\x9eb@\x1eWN\x9f" +
	"{/\xca\xbb\xe6\xd2\xe3\xc4\xdc\xcf1@g\xfb\xa9\x8d" +
	"/Y\xab\x8e\x7f\xa1\xcc,~\xfa\x9e\x88\x89\xf2\xc1\xc8" +
	"\x02\x00\xf9+\x91o\x03:\xfb\xd9\xc9|\xdd\x8f\x17\x7f" +
	"\x09\x94\x0f\xfa\xa7\xaf\x8e\xf2\xd37E\x89\xa3\xf1h\xfa" +
	"3_\xea\xbb\xedp\xb9\x97\x908/D\xbbQ\xfem" +
	"\x94\xacy\x9bs\x7f\xeak}K\x9d\x8b\xcfqn," +
	";\xfc!\xa9\x1b\xe5C\x121\x1f\x94z\x00\x9d\xd4\xc9" +
	"[\xc3\xcb\x9eO\xfd\xed\xa4\xc3\x9f\x95\x8e\xd0\xe1'%" +
	"\x12\xf7\xc6\xd2\x15\xcd\xec\xa9\x95_\x9d\xe2su\xde)" +
	"\x94w\xcd#Y\x13\xf3>\x02\xe84\x7fas\xd5\xdd" +
	"\xef\xce\x7f\xb4\xec\xe00\xe3\xee\x9c\x97B\xf9\x00\xe7~" +
	"x\x1e\xb9\xf4\xd8\xab\xbb.\x7f\xe2\xbe\xde\xc7Aje" +
	"\x93\xe4\xea\xb2\x89\xf2.\x99\xcb\x95o\x97\x1f\xa3'\xe7" +
	"[O\xae=\xd3\xd9\x9f\xfe:\xc9f\xe5.xH\x1e" +
	"D\xf9+\xc4\xb7\xf2\x90\x1c\xa7@\xf9\xfd\xea\xc1\x9d\xaf" +
	"\xf6o\xfd\xc6\x14\xa5\x7f\x1a\xbb\x17\xe5\x0b1\x12~." +
	"\xf6g\x80\xce\xcb\xadw\xee\xfb\xea;g\x8e\x96\x05\x0a" +
	"\xf7\xc3\x95X/\xcau\xf5\xc4\\S\xbf\x03\xd0I\xc8" +
	"Vm\xb5q\xfb\xb7@\xfa 9\x8b\x1f\xfe`\xfda" +
	"r\xd6\xc1zr\xe7A\xf3C\x8f\\~n\xfd\xd3\xd3" +
	"\xde\xd4\xb3\xf5\x09\x94\x7f\xcc\xc5\x9d\xac'\xd7\xee]\xf0" +
	"\x93\x93Ow^~&(\xee\x93\xf3\x7fF\xe2\xc6\xe6" +
	"\x93\xb8\xff~\xe0/\x7f4?\xf6\xd9\xefN\xa7\xdc\x81" +
	"\xf9\x9bQ~b>I{l>)\xf7\xb9cG\xdf" +
	"\xda\xf9\xd1\xf6\x7f\xa4\xb3C\xe51_\xb7\xe0\x08\xca7" +
	"-\xa0\xc7\xd6\x05\x1f\x11\x00\x9d\x7f=\xfe\xe8\x7f\xfeI" +
	"\xec\xd3\xc7\xa6\xcb\x90C\x0dO\xa2\xfcL\x03\xc9~\xaa" +
	"\x81.\xab\xb9-*<\xbf\xaa\xe5{\x93\x999\xef\x13" +
	"\x8dw\xa3|\xacQ\x04\xe6\xfc\xfb\x0f\x1a.o\xb9\xeb" +
	"\x17e\\\xee\xfd\x1fl4Q\xfef#\x89|\xa2\x91" +
	"\x8c\xbf\xb4\xe2\x09\xe5\xcd5\xad\xff<]\x98\xfe\xf9\xc2" +
	".\x94\xb5\x85\xc4\xac.$G\xbc\xf4\x9d7\xf7\xad\xfd" +
	"\xa7\xc3\xc7\xcbC\x8b\xbbl\xcf\xc2\x04\xca\x079\xf7\x81" +
	"\x85\xe4\x89\xef\xac\xb9\xf8\xc7\xbb\xda^zqZO\\" +
	"Yx\x18\xe5\xfaE\xf4(-r(X\x86\xaf\x8c\xc5" +
	"\xa5/~\xf1\x87\xc1k\xe8o>E\xd7\xa06\xd3\xe9" +
	"\xbf\xfe\xcc\xdf\xe0\x1b;\x0f\xffpJ\xa8\xeei\xeeF" +
	"\xf9@3\xfd\xe0\xe1f\x11\xe5\xd5q\x8a\xd5\xe5\x7f\xba" +
	"\xa6\xe1\xc4\xa5\xe6\x97\xa7\xb3\xac)\xde\x8dr'\xb1\xc9" +
	"K\xe2\xa4\xeb\xd6\x1as\xff\\\xfd\xa3\xaf\x941o\x10" +
	"DF\xc1\x15\xbf\x1f\xe5C\x9c\xfd`\x9c.\xe2\xfe\xe6" +
	"\x0f\x7f\xfb\xf1\x8b\xdf\xf8\x8f2\x17s\x9d\xf5\x96\x04\xca" +
	"\xbbZx\xe2\xb4\x90\xde\x0f\x9c\xfa\xda\xa7\x8f^8\xf9" +
	"_ -\x13|L\x02\\\xf9\xcd\x96\xc3(\x9f\xe0\x9c" +
	"\xdfo\x19\x01t\xda\x9e\xef}\xe9\x8e7\xb7\x9d\x9d6" +
	"\xbd\xce\xb5\x0c\xa2\xfc[\xce\xfdv\x0b)\xb1\xe4\xe7\x9f" +
	"\xffP\xcd\xb6G\xcf\x82\xb4\x0c\xc1\xb5\xeb\xf5\xd6\x9f!" +
	"\x84\x9c\xc1\xdb;c\x87\x92?\xf8\xdf\xa9y\xd7\x9aB" +
	"\xf9B+\xcf\xbb\xd6/\x03\xfe\xee\xf1\xd3\xb5\xbfI\xff" +
	"\xf2\xdd \xec|\xac\x8d\x87\xbe\xd2F\xe1\xb1\xefDl" +
	"\xc1ye\xf5\x95\xe0\xa5\\j{\x92\x18\xae\xb4\x91q" +
	"7\x8f\xee{m\xcf\xcd\xaf8A\x86\xa6\x0f\xfc\x031" +
	"t~\xa0\x07:\x9d\xfc=#\x1f\xb6\xec\x9c\x19\xd2\xf8" +
	"\x1fmH\xcd\x1by\xf7q\x19\x7f\xee\xbeed\xc4\xbc" +
	"u\xb4\xc0\x8c{\x06\x10\x95\x16\x16\x02\x08!\x80\xf4\xd3" +
	"^\x00\xe5\xdf\x18*g\x04\x94\x10c\xa4\xa2t\x9a\x88" +
	"/3T^\x13\x10\x85\x18\x0a\x00\xd2/\xda\x00\x94W" +
	"\x18*g\x05\x94\x18\xc6\x90\x01H\xafw\x01(g\x18" +
	"*\xe7\x05\x94BB\x0cC\x00\xd29\xe2|\x8d\xa1r" +
	"Q@)\xccb\x18\x06\x90.\x10\xf1,C\xe5\x0d\x01" +
	"\xa5\xaaP\x0c\xab\x00\xa4_\x13\xf1<C\xe5-\x01%" +
	"1\x1c#\xc3\xa4Kt\xf8E\x86\xca;\x02\xee\xce\xea" +
	"\xc6\x16=\xaba\x18\x04\x0c\x03\xee\xce\xaa\xe3\xc1\xcf\xa2" +
	"\xa9\xee\xc0\xa8_4\x001\x0a\x18\x1f\xca\x15\x0c{*" +
	"]\xb4\x0a\xd9i\xa8Y\xdd\x98\x8e\xaa\x8eO\xa5\xee\xe6" +
	"\x925s\xea7\xde\x15\xb0\x99\xae \xce\xef\x80\xbc\x7f" +
	"#w\xe8-m\xf4Sim\x17\x00\x0a\xd2\x0a\xfa\xc4" +
	"\xa4%\xf4'$\xb5\xd2\x9f\xb0\xd4\xd0\x0b@&\xba\x06" +
	"\x91\xfa\xa4,\xa9VR\xc4;6<\xe3\xcd\xf7\xa9)" +
	"-s\x87\x9a\xd5\xac\x84f\xe5s\xa2ai\xa4D\xd4" +
	"\x0b\x01\x95\x1c\xbe\x8d\xa12\x1a\x08\x01\x8dn\xf6.\x86" +
	"\xcaN\x01%\xa1\x18\x03\x13\x9b\x01\x94q\x86\xca_S" +
	"\x0c07\x06\x0e\x10\xe7~\x86\xca#\x02\xee\xb6&\xb2" +
	"\xa9\\\xc6\xc2\xa8\x8f\xe7\xc5;1H\x03\xbc\x01p\x80" +
	"!V\x83@\x8f\xce\x0e\xd54tc\xc4\x02\x80\xd2W" +
	"\xb5\xeeW\xf1Q\xdd\xb0-\xac\x03\x01\xeb\x02\xde\xad\x9a" +
	"\xd1\xcc\xa4f\xea\x9a\x95\xb4MM\xcd.3\xb4q\xbb" +
	"=\xa1Y\x85\x0c\xb3\xad\xa0\xa9\x1d\xbe\xa9\x9e\xa5\x1dE" +
	"K3d)\xba\x96\xeadT\x9a\xa1\x92\x0fD{\xf6" +
	"n\x00%\xc3P\x19\x170bjV\x1e\xa3>\xa6\xb9" +
	"fF\xd29CC\x04\x01\x110\xae\x99f\xce\xc4\x88" +
	"\x0f\x15\x80\x18\x01t8\xfd\xd6\x9c\x01\x11[\x1b\xb7\xb9" +
	"\xc9\xb5\x01#C\xb3\x18\x99\xe8\xd1\xc6\x0a\x9ae\xd35" +
	"\xae+\xd9&?\x83\xbd\x00\xc9\xa3\xc80\xf9\x1cz\xe6" +
	"\xc9\xcfr\xf2\xd3D~\x01}\x0b\xe5c\x9c\xfe]\xa2" +
	"\x1fG\xdfH\xf9\xfb\xb8\x19 \xf9\x02\xd1\xcf\xa0\x9f\xd5" +
	"\xf2i<\x02\x90<C\xf4\xf3D\x0f\x0b<\xb1\xe5s" +
	"8\x08\x90<K\xf4?\x10\xbd\xea8\xcfm\xf9\xf7\xf8" +
	"\"@\xf2\x0fD\xaf\x16(\xbd\xebxz\xcba\x81\xe8" +
	"\xd5\x02\xc3d\x8c\xe8\xd5'bX\x0d K\x02\xc9\x89" +
	"\x12}\x11\xd1kX\x0ck\x00\xe4\x06\xa1\x0b \x19#" +
	"z\x0b\xd1\xe7\x84b8\x07@n\x12:\x00\x927\x12" +
	"\xbd\x9d\xe8s\xc31\x9c\x0b \xb7r\xfeED_L" +
	"\xf4\xdaP\x0ck\x01\xe4\x9b\xb8\xfcv\xa2/'z]" +
	"8\x86u\xd4C\x0b\x09\x80\xe4R\xa2\xaf!\xfa\x0dU" +
	"1\xbc\x01@^-<\x09\x90\\C\xf4-D\x8fT" +
	"\xc50\x02 +\\~\x1f\xd1\xb7\x0aW\x8b\xf8\xd9\xb0" +
	"\xcb\xc9\xaa\xf6\xd0\xa8f\x06\x83?\x1a,]<C\xb2" +
	"\xeaxB\xb3r\x19,\xd8z\xce\xf8\xb8n\x88\xe9\xdc" +
	"\x0eO\x84:2bj#\xaa\x0d\xcc\xcf\xad\x88?:" +
	"\x14e\xe4U\xd3\xd6\xd5LB\xa0\xfc7,m\xbdn" +
	"\xa9\xa9\x8c\x96\x86R\xa0N\xe1H\xda\xa6jk#\x13" +
	"\x80\x11\xbf).\x06\xafu\x8f\x9e\xbfu\xb4`\x00\xbb" +
	"\xc7\xf2\"}R\xb6F,[\xcb\x97t\x8c\x9b\xaa1" +
	"\xe2\x1b=V\xd0\xcc\x89\x8d\xba\x01\xcc&\x9fy}t" +
	"\x11E\xadQ\xd5Lo2\x86\x01s\x18\xf5Ku\xf1" +
	"\xdb\x1d\xba=\x9a+\xd8\x09\xd4\xf2\x19}H\xedS#" +
	")-S\x0e*\xf1\x8c\x9e\xd5m\xef\xc0\xd9\x93\x8a\x03" +
	"d\xbf\x1a\xe7\xb7\xa1\x840\xd8L`Gd\xcbD^" +
	"Sj=\x08\xd9@p\xb1\x8e\xa1\xd2\x17@\xcbMD" +
	"\\\xcfP\x19\x08\xa0e?a\xc8F\x86\xca\x16\x01#" +
	"\xf6D^\xc3\x88/\xd9uf\x84P\x91+^\x0d\x18" +
	"\xdf\xaef\x0a\xde\xa7J \x8f?gH\xfd;\xe9\xa7" +
	"\x96\x0fy\xd3\xeb\xeb\xa9\xdb\x15T\xb7\x08y\xfd\x84n" +
	"}\x0c\x95\xad>\xbay\x8ds\x11\xc4\xdf'\xa0\xcdX" +
	"\x13{\xba)\x92xK2\x8b\xc6\x1d\xd3i\xdc1\xd5" +
	"\xc1\xde4TtpZ\xb5U/.GUk\x14k" +
	"@\xc0\x9a\xca\x94KP\xe8\x92r!O\xb9\xban\x00" +
	"\xa5\x9a\xa1\x12\x13\xb0'\xabg2\xba5%\xd4\xc2\xb3" +
	"\xdc\x98n\x0c\xe7\xf8U\x89\x99\xebwU\xde@rm" +
	"W5s\xb4\x0d\x141\xa2\x1c\"\x80\x1cT\xcd\xf5\x92" +
	":xKS\xd3\x05\x10\xa1\xd2\x1eWS9\xd3\xae " +
	"\x05\x15\x17\x15D\xc3\xb6\xcaz\x93A\xbf8\x97\\\xa2" +
	"w\x04js\xc9%\xd9\xcd~m\x96\x98\xe0\x16\xec\x02" +
	"9/\xef61\x0e\x81R\xbf\x9e\xc9\x00\xf3\xaf,2" +
	"\\0\x860\xea\x0fhE\xa0\x191s\x85\xbcn\x8c" +
	"\x104G\xfd\x89\xac\xe8Z\x17\xd1\xa2\xfe\xf6\xa1\xac\x05" +
	"\x9c\xad~'\xe3\xbcKq\x03+\x0c\xe0\x0d\x19X\xda" +
	"\xce\x90'\x05),F\xa8\x91Y\x87\x03X\x91pz" +
	"\xded\xb0\xe1\x1cI\x8ey>\xdc\xd5[\xec\xda\xfe\"" +
	"\x80X{\x88\xb8\x93\xa1\xb2\x97\x9cx\x9f\xeb\xc4\x07?" +
	"\x0f\xa0\xec-\xf5w{\x8a\xfd\xdd\xff\x00(\x8f0T" +
	"\xfeN@\x0c\xb9-\xfec\x09\x00\xe5Q\x86\xca\x0b\xb3" +
	"\xf7\xe8\x8eU\xc8\xe7s\xa6ma\x92\xc0\x9d{\xd5+" +
	"<\xa5\xef\x84\x8f\x17\xa1}2\xb2\x97\xd8l+\x9d\xda" +
	"d\x0c\xe7\x00-\xbfTz\x0b\x88R\x99\x9b\xd5C\x1c" +
	"l6\x18=C9R\x83\xa3\x0e\xb7\xbb\xc9m\xc5\xeb" +
	"\x13\xbc\x15\x97\xee\x05\x10\xc7s\xa63\xaa[vn\xc4" +
	"T\x01\xb3\xcep&\xa7\xda\x1bu\x0bz8)[\xf1" +
	"e\xbb\xe9\xe1]\xc6\x12\xc2\x8fv\x86\xca\xba\xc0e|" +
	"\x8c\x88k\\ \xeb\xe1x\x1e0\xd3\x1b\xb1]3{" +
	"\x86\xc8\x88\xc0\xf7\xde^\xb1\xcc\x0d\x15\xa1\xd0\x80j\xaa" +
	",k\x05\x01\xae\xcd\x078\xd1\xd4\xc6\xa8H\x976\"" +
	"\x15\xc7\xf9\x96\xe4\xfa\xdeM\xc60\xe6\xca\x90\xbd{\x1a" +
	"\x80\xeb\x9d\x0e\xe0z}d/9$\xea/\x04*l" +
	"\xb0\xdeO\x05%\x87dq\x16\x87x\xeb\xa7\xca\x13\xdf" +
	"\xed\x12\xa1<\x1a:\x8a\xd1\xb0<\x10\x0d\x9dd\xfcb" +
	"\x86\xcazar\xfd\xda\x9d\x1b\x1e\xb64{\xca\x14U" +
	"\xe1\x0c\xe8Z\x98\xd0\xc6\x0abqxX\xec\x0d\x0f5" +
	"|\x1a\x08Q\xb7\x1e\x0d\x0c\x0fuH\xcdn5\x91c" +
	"|xhq\x87\x07\x897\xf71\xa2\xb7\xa0?\x0b\xca" +
	"M\x9c\xdeB\xf4\xa5|x@wxX\xc2\xe5\xb4\x13" +
	"}ypx\xe8\xc46\x80\xe4b\xa2\xaf\xe2\xc3\x03\xba" +
	"\xc3\xc3\x0a\xce\xbf\x94\xe8k\x88.\x0a\xee\xf0\xb0\x9a\x0f" +
	"'\xab\x88>@\xf4j\xe6\x0e\x0f\xfdH\xcd\xfa\x00\xd1" +
	"3\x18\x18\x1et.'M\xf4<^u<\xe51\xe0" +
	"\xf7^\xd7\xb3c\x8e[\xb6jz\x0d\xa9\xa8\x19i\xaf" +
	"7\x9e<\xe4V4\x10\\K\x0f\\a\x80X\xf9H" +
	"\xae\xc2-A\xf7\xf5\xdd\x12\xf4\xf0\x16\xf8\xda\xd7\x043" +
	"'\"U\x91\x846\x16)\xce\xcf\x15\xff\xc2\x8a\xe7K" +
	">\x09\xe0Y\xeft\xb3@\xa2\x88]\xe9\x80O\xd4\x84" +
	"\xdf\xc7\xccl\xbe\xc3\xa30\xa9\xd9\x93\xea\\\x10\xf6\xc8" +
	"\x1b\x96[\xe7\x8b3\x92\xf7\xb6\xa0\xf2=\xd4m\x05c" +
	"\xa8\xac\xab\xed\xf01n\xd2LR\x81\x7fnw{%" +
	"\x1c)\x83\xb6F\x1f\xda<d\xeb\xf6\x91\x8d\xa5&J" +
	"\xc9TV\xf2\xde#\xac\x15W[c\x05\x8d\xb9\xa8\xd6" +
	"\xee\xe9\x10\\%\x96tx\xfbE\x00\xe5\x1d\x86\x89\xc0" +
	"2D\xba\xf2\"@\x82P\xa26\xb8\x0a\xa9\xe1\xe8\xe1" +
	"\x81\xa2\xb7\x0a\xa9\xe3\xa8\xe5\xa3b\x18]4\x938\x7f" +
	"-\xd1o\xe4h&\xb8hV\xcfQ+\xe6\xa1\x9f\xc8" +
	"\\4\xeb\xe4\xa8\xb5\x9c\xe8}A4\xdb\xc4\xe5\xac/" +
	"\xa1\xdcU\xe2\xe5\xff)NUT\xb0\xf9\xbd\xbb\xf5\xda" +
	"\x02\xb8z\xc1\xf6\xde\x92T\x9a$=\xeeI.\x04R" +
	"\x8b^z\x1d\x86\xa5\xb7\x88\xd2\x18\xb5\xe8\x9a\x88\xfe\xfe" +
	"\x1eK{z\xe9\x13\xdd H\xfd\"\x0a\xde\x0b\x17|" +
	"\xfct-\xfc&\xfd\xcbw\xa5[\x06A\x90\xd6\x8a\xc8" +
	"\xbcwbXz-*u\xa6@\x90n\x12#\xd4\x9b" +
	"\xad\xc3\x1e\x8bw\x90\xeb\x8a\xb8p\x87\x9a\x05\xe6\x7f\xbc" +
	"S\xcd\x80X\xa0\xcfA\x1c\xbb\x8aE<[*\xe9?" +
	"\xba\x8aY\xbaJ\xa8hA\x11\x9em]Y\x0c=\x98" +
	"\xb9\xa04\xa1\xe3\x94\x97\x94\x8c\x80M\xc2\x1f\x9d\xd2B" +
	"\xb6\xd7\x1f\xfa\x9a\xd8\x15\xa7\xb4\x92%]G\x19*\xf6" +
	"U\xcb\x8a\xebH\x8c\xfa\xaf@\x8b-d\xb1\xb2\x94\xc6" +
	"\xe0\xf7\\N\xfa\\\xc0F{\x86-A\xfb\xec\x0d}" +
	"\xa58\xd7\xeff\xdd\xb2-\x13,\xef\x06&w\x0c\xe1" +
	",\xa2\xfb\xc6@\x90\x1a\x1a\xf9k\x04\xa9\x0d\x80ic" +
	"\xa2\xa1\x8d1S\x13\x0dS\xab\xa4Guwo\xc5\xf9" +
	"q\xfa\x19\xdc\x0b\x12=\xe5;\xde\x9b\x1f\xc7\x1a\xfd!" +
	"\x1c\x8b\x85\xbf\xd0]\x9c\xc1\xf7\x0b\xdez/\x0dL\x1b" +
	"\xf7\xb2\xde\xce\xd9j&9\xaa\x82h\xa6\xbd\xc9\xbc\xf2" +
	"\xf2\xf0^^\x09\x14\xbb\xfbJ\x87\xe9\x0d\xa6h\xe6\x82" +
	"\xafl\xdc\xfd\xc6\xda\x14\xf7\xf5\xea\xfb\xb9\xafWl\xe6" +
	"\xafl:7\xf3W6K\xfe\x0a b\xe4\x0c\xcd)" +
	"\x18\xeavU\xcf\xa8 \xa62\x9a\xa3\x1b\xdb\xd5\x8c\x9e" +
	"\xbeE0G\x0aY\xcd\xb0\xc1\xc8\xd9\xb7\xe5\x0aF\x1a" +
	"\xc0\xd1\x0d[3\x0d5\x03\x00\x8e\xa9Y\xb9\x829\xa4" +
	"\xe1\x86\xf1Q\xb5`\xd9\x1a\xa6\xdf\x0f,\xf2E\xa0\x8d" +
	"\xd7m\xbb\xe4\xfd\x8f\xc9\xb5m\x97f\x9bI\xdd<m" +
	"\x1fP#\x84\xeaW\xc7t\xef\xffT\xca0\xbd\xc23" +
	"\x12Z\x9c\\d\xcd\xb4\xdb\xb3x\xd8\xa0\xe4\xff\xf3\x06" +
	"]=\xe0\xff\x05\x00\x00\xff\xff\x96'P\x84"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_b8e4c1f0a2d3e5f7,
		Nodes: []uint64{
			0x8069586561dd21e7,
			0x838d6d5e7a5c76c6,
			0x8848ba07bca77e3b,
			0x88e81c42858378ad,
			0x8b6579a662ac5c30,
			0x8ec03473c848ca76,
			0x9628c90d70c5038c,
			0x9a464c967b64ac1a,
			0x9ab8e8ff2c4c9f5e,
			0x9c62bb2e0543c562,
			0x9e33ad031e312cec,
			0xa016f66a064a8e1e,
			0xa3428059f37ddab9,
			0xa6644d2dd839aaae,
			0xa8584dda7c5a35f9,
			0xacd8f49e8b5621d0,
			0xae476e080c731352,
			0xb044b8f3982b7295,
			0xb1f32db0c5cf1788,
			0xb47e1416c68683e2,
			0xb6243c7cf0acb987,
			0xb95f1426dba0c0cb,
			0xba2034bb0210221e,
			0xbad96054f319c3cd,
			0xbf2138ef51a531ed,
			0xc09ab7398befb3c8,
			0xc2c82260fee838b3,
			0xc49090111f71fd66,
			0xc49a7cec019b7be9,
			0xd01eedc119383e30,
			0xd43c690b8c720958,
			0xd7a8e8a3af2f1e82,
			0xdec5e5ac5f9fca83,
			0xe05cef4ec842bb22,
			0xe0a05c092b8ad329,
			0xf2c35399142d475a,
			0xf6e364eb000cd5a3,
			0xfd3551e41714c18b,
			0xffd43b81dc8b683b,
		},
		Compressed: true,
	})
}
