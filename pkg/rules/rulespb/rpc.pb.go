// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rules/rulespb/rpc.proto

package rulespb

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	proto "github.com/gogo/protobuf/proto"
	labelpb "github.com/thanos-io/thanos/pkg/store/labelpb"
	storepb "github.com/thanos-io/thanos/pkg/store/storepb"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// / AlertState represents state of the alert. Has to match 1:1 Prometheus AlertState:
//
// StateInactive is the state of an alert that is neither firing nor pending.
// StateInactive AlertState = iota
// StatePending is the state of an alert that has been active for less than
// the configured threshold duration.
// StatePending
// StateFiring is the state of an alert that has been active for longer than
// the configured threshold duration.
// StateFiring
type AlertState int32

const (
	AlertState_INACTIVE AlertState = 0
	AlertState_PENDING  AlertState = 1
	AlertState_FIRING   AlertState = 2
)

var AlertState_name = map[int32]string{
	0: "INACTIVE",
	1: "PENDING",
	2: "FIRING",
}

var AlertState_value = map[string]int32{
	"INACTIVE": 0,
	"PENDING":  1,
	"FIRING":   2,
}

func (x AlertState) String() string {
	return proto.EnumName(AlertState_name, int32(x))
}

func (AlertState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_91b1d28f30eb5efb, []int{0}
}

type RulesRequest_Type int32

const (
	RulesRequest_ALL RulesRequest_Type = 0
	/// This will make sure strings.ToLower(.String()) will match 'alert' and 'record' values for
	/// Prometheus HTTP API.
	/// NOTE: The implementation has to return empty rule groups as well.
	RulesRequest_ALERT  RulesRequest_Type = 1
	RulesRequest_RECORD RulesRequest_Type = 2
)

var RulesRequest_Type_name = map[int32]string{
	0: "ALL",
	1: "ALERT",
	2: "RECORD",
}

var RulesRequest_Type_value = map[string]int32{
	"ALL":    0,
	"ALERT":  1,
	"RECORD": 2,
}

func (x RulesRequest_Type) String() string {
	return proto.EnumName(RulesRequest_Type_name, int32(x))
}

func (RulesRequest_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_91b1d28f30eb5efb, []int{0, 0}
}

type RulesRequest struct {
	Type                    RulesRequest_Type               `protobuf:"varint,1,opt,name=type,proto3,enum=thanos.RulesRequest_Type" json:"type,omitempty"`
	PartialResponseStrategy storepb.PartialResponseStrategy `protobuf:"varint,2,opt,name=partial_response_strategy,json=partialResponseStrategy,proto3,enum=thanos.PartialResponseStrategy" json:"partial_response_strategy,omitempty"`
	MatcherString           []string                        `protobuf:"bytes,3,rep,name=matcher_string,json=matcherString,proto3" json:"matcher_string,omitempty"`
	RuleName                []string                        `protobuf:"bytes,4,rep,name=rule_name,json=ruleName,proto3" json:"rule_name,omitempty"`
	RuleGroup               []string                        `protobuf:"bytes,5,rep,name=rule_group,json=ruleGroup,proto3" json:"rule_group,omitempty"`
	File                    []string                        `protobuf:"bytes,6,rep,name=file,proto3" json:"file,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}                        `json:"-"`
	XXX_unrecognized        []byte                          `json:"-"`
	XXX_sizecache           int32                           `json:"-"`
}

func (m *RulesRequest) Reset()         { *m = RulesRequest{} }
func (m *RulesRequest) String() string { return proto.CompactTextString(m) }
func (*RulesRequest) ProtoMessage()    {}
func (*RulesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_91b1d28f30eb5efb, []int{0}
}
func (m *RulesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RulesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RulesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RulesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RulesRequest.Merge(m, src)
}
func (m *RulesRequest) XXX_Size() int {
	return m.Size()
}
func (m *RulesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RulesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RulesRequest proto.InternalMessageInfo

func (m *RulesRequest) GetType() RulesRequest_Type {
	if m != nil {
		return m.Type
	}
	return RulesRequest_ALL
}

func (m *RulesRequest) GetPartialResponseStrategy() storepb.PartialResponseStrategy {
	if m != nil {
		return m.PartialResponseStrategy
	}
	return storepb.PartialResponseStrategy_WARN
}

func (m *RulesRequest) GetMatcherString() []string {
	if m != nil {
		return m.MatcherString
	}
	return nil
}

func (m *RulesRequest) GetRuleName() []string {
	if m != nil {
		return m.RuleName
	}
	return nil
}

func (m *RulesRequest) GetRuleGroup() []string {
	if m != nil {
		return m.RuleGroup
	}
	return nil
}

func (m *RulesRequest) GetFile() []string {
	if m != nil {
		return m.File
	}
	return nil
}

type RulesResponse struct {
	// Types that are valid to be assigned to Result:
	//	*RulesResponse_Group
	//	*RulesResponse_Warning
	Result               isRulesResponse_Result `protobuf_oneof:"result"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *RulesResponse) Reset()         { *m = RulesResponse{} }
func (m *RulesResponse) String() string { return proto.CompactTextString(m) }
func (*RulesResponse) ProtoMessage()    {}
func (*RulesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_91b1d28f30eb5efb, []int{1}
}
func (m *RulesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RulesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RulesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RulesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RulesResponse.Merge(m, src)
}
func (m *RulesResponse) XXX_Size() int {
	return m.Size()
}
func (m *RulesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RulesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RulesResponse proto.InternalMessageInfo

type isRulesResponse_Result interface {
	isRulesResponse_Result()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RulesResponse_Group struct {
	Group *RuleGroup `protobuf:"bytes,1,opt,name=group,proto3,oneof" json:"group,omitempty"`
}
type RulesResponse_Warning struct {
	Warning string `protobuf:"bytes,2,opt,name=warning,proto3,oneof" json:"warning,omitempty"`
}

func (*RulesResponse_Group) isRulesResponse_Result()   {}
func (*RulesResponse_Warning) isRulesResponse_Result() {}

func (m *RulesResponse) GetResult() isRulesResponse_Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *RulesResponse) GetGroup() *RuleGroup {
	if x, ok := m.GetResult().(*RulesResponse_Group); ok {
		return x.Group
	}
	return nil
}

func (m *RulesResponse) GetWarning() string {
	if x, ok := m.GetResult().(*RulesResponse_Warning); ok {
		return x.Warning
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RulesResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RulesResponse_Group)(nil),
		(*RulesResponse_Warning)(nil),
	}
}

// / RuleGroups is set of rule groups.
// / This and below APIs are meant to be used for unmarshaling and marshsaling rules from/to Prometheus API.
// / That's why json tag has to be customized and matching https://github.com/prometheus/prometheus/blob/c530b4b456cc5f9ec249f771dff187eb7715dc9b/web/api/v1/api.go#L955
// / NOTE: See rules_custom_test.go for compatibility tests.
// /
// / For rule parsing from YAML configuration other struct is used: https://github.com/prometheus/prometheus/blob/20b1f596f6fb16107ef0c244d240b0ad6da36829/pkg/rulefmt/rulefmt.go#L105
type RuleGroups struct {
	// @gotags: json:"groups"
	Groups               []*RuleGroup `protobuf:"bytes,1,rep,name=groups,proto3" json:"groups"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *RuleGroups) Reset()         { *m = RuleGroups{} }
func (m *RuleGroups) String() string { return proto.CompactTextString(m) }
func (*RuleGroups) ProtoMessage()    {}
func (*RuleGroups) Descriptor() ([]byte, []int) {
	return fileDescriptor_91b1d28f30eb5efb, []int{2}
}
func (m *RuleGroups) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RuleGroups) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RuleGroups.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RuleGroups) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RuleGroups.Merge(m, src)
}
func (m *RuleGroups) XXX_Size() int {
	return m.Size()
}
func (m *RuleGroups) XXX_DiscardUnknown() {
	xxx_messageInfo_RuleGroups.DiscardUnknown(m)
}

var xxx_messageInfo_RuleGroups proto.InternalMessageInfo

func (m *RuleGroups) GetGroups() []*RuleGroup {
	if m != nil {
		return m.Groups
	}
	return nil
}

// / RuleGroup has info for rules which are part of a group.
type RuleGroup struct {
	// @gotags: json:"name"
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name"`
	// @gotags: json:"file"
	File string `protobuf:"bytes,2,opt,name=file,proto3" json:"file"`
	// @gotags: json:"rules"
	Rules []*Rule `protobuf:"bytes,3,rep,name=rules,proto3" json:"rules"`
	// @gotags: json:"interval"
	Interval float64 `protobuf:"fixed64,4,opt,name=interval,proto3" json:"interval"`
	// @gotags: json:"evaluationTime"
	EvaluationDurationSeconds float64 `protobuf:"fixed64,5,opt,name=evaluation_duration_seconds,json=evaluationDurationSeconds,proto3" json:"evaluationTime"`
	// @gotags: json:"lastEvaluation"
	LastEvaluation *Timestamp `protobuf:"bytes,6,opt,name=last_evaluation,json=lastEvaluation,proto3" json:"lastEvaluation"`
	// @gotags: json:"limit"
	Limit int64 `protobuf:"varint,9,opt,name=limit,proto3" json:"limit"`
	// Thanos specific.
	// @gotags: json:"partialResponseStrategy"
	PartialResponseStrategy storepb.PartialResponseStrategy `protobuf:"varint,8,opt,name=PartialResponseStrategy,proto3,enum=thanos.PartialResponseStrategy" json:"partialResponseStrategy"`
	XXX_NoUnkeyedLiteral    struct{}                        `json:"-"`
	XXX_unrecognized        []byte                          `json:"-"`
	XXX_sizecache           int32                           `json:"-"`
}

func (m *RuleGroup) Reset()         { *m = RuleGroup{} }
func (m *RuleGroup) String() string { return proto.CompactTextString(m) }
func (*RuleGroup) ProtoMessage()    {}
func (*RuleGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_91b1d28f30eb5efb, []int{3}
}
func (m *RuleGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RuleGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RuleGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RuleGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RuleGroup.Merge(m, src)
}
func (m *RuleGroup) XXX_Size() int {
	return m.Size()
}
func (m *RuleGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_RuleGroup.DiscardUnknown(m)
}

var xxx_messageInfo_RuleGroup proto.InternalMessageInfo

func (m *RuleGroup) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RuleGroup) GetFile() string {
	if m != nil {
		return m.File
	}
	return ""
}

func (m *RuleGroup) GetRules() []*Rule {
	if m != nil {
		return m.Rules
	}
	return nil
}

func (m *RuleGroup) GetInterval() float64 {
	if m != nil {
		return m.Interval
	}
	return 0
}

func (m *RuleGroup) GetEvaluationDurationSeconds() float64 {
	if m != nil {
		return m.EvaluationDurationSeconds
	}
	return 0
}

func (m *RuleGroup) GetLastEvaluation() *Timestamp {
	if m != nil {
		return m.LastEvaluation
	}
	return nil
}

func (m *RuleGroup) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *RuleGroup) GetPartialResponseStrategy() storepb.PartialResponseStrategy {
	if m != nil {
		return m.PartialResponseStrategy
	}
	return storepb.PartialResponseStrategy_WARN
}

type Rule struct {
	// Types that are valid to be assigned to Result:
	//
	//	*Rule_Recording
	//	*Rule_Alert
	Result               isRule_Result `protobuf_oneof:"result"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Rule) Reset()         { *m = Rule{} }
func (m *Rule) String() string { return proto.CompactTextString(m) }
func (*Rule) ProtoMessage()    {}
func (*Rule) Descriptor() ([]byte, []int) {
	return fileDescriptor_91b1d28f30eb5efb, []int{4}
}
func (m *Rule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Rule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Rule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Rule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Rule.Merge(m, src)
}
func (m *Rule) XXX_Size() int {
	return m.Size()
}
func (m *Rule) XXX_DiscardUnknown() {
	xxx_messageInfo_Rule.DiscardUnknown(m)
}

var xxx_messageInfo_Rule proto.InternalMessageInfo

type isRule_Result interface {
	isRule_Result()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Rule_Recording struct {
	Recording *RecordingRule `protobuf:"bytes,1,opt,name=recording,proto3,oneof" json:"recording,omitempty"`
}
type Rule_Alert struct {
	Alert *Alert `protobuf:"bytes,2,opt,name=alert,proto3,oneof" json:"alert,omitempty"`
}

func (*Rule_Recording) isRule_Result() {}
func (*Rule_Alert) isRule_Result()     {}

func (m *Rule) GetResult() isRule_Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *Rule) GetRecording() *RecordingRule {
	if x, ok := m.GetResult().(*Rule_Recording); ok {
		return x.Recording
	}
	return nil
}

func (m *Rule) GetAlert() *Alert {
	if x, ok := m.GetResult().(*Rule_Alert); ok {
		return x.Alert
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Rule) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Rule_Recording)(nil),
		(*Rule_Alert)(nil),
	}
}

type AlertInstance struct {
	// @gotags: json:"labels"
	Labels *labelpb.LabelSet `protobuf:"bytes,1,opt,name=labels,proto3" json:"labels"`
	// @gotags: json:"annotations"
	Annotations *labelpb.LabelSet `protobuf:"bytes,2,opt,name=annotations,proto3" json:"annotations"`
	// @gotags: json:"state"
	State AlertState `protobuf:"varint,3,opt,name=state,proto3,enum=thanos.AlertState" json:"state"`
	// @gotags: json:"activeAt,omitempty"
	ActiveAt *Timestamp `protobuf:"bytes,4,opt,name=active_at,json=activeAt,proto3" json:"activeAt,omitempty"`
	// @gotags: json:"value"
	Value string `protobuf:"bytes,5,opt,name=value,proto3" json:"value"`
	// Thanos specific. Used mainly for alert API purposes.
	// @gotags: json:"partialResponseStrategy"
	PartialResponseStrategy storepb.PartialResponseStrategy `protobuf:"varint,6,opt,name=PartialResponseStrategy,proto3,enum=thanos.PartialResponseStrategy" json:"partialResponseStrategy"`
	XXX_NoUnkeyedLiteral    struct{}                        `json:"-"`
	XXX_unrecognized        []byte                          `json:"-"`
	XXX_sizecache           int32                           `json:"-"`
}

func (m *AlertInstance) Reset()         { *m = AlertInstance{} }
func (m *AlertInstance) String() string { return proto.CompactTextString(m) }
func (*AlertInstance) ProtoMessage()    {}
func (*AlertInstance) Descriptor() ([]byte, []int) {
	return fileDescriptor_91b1d28f30eb5efb, []int{5}
}
func (m *AlertInstance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlertInstance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlertInstance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlertInstance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlertInstance.Merge(m, src)
}
func (m *AlertInstance) XXX_Size() int {
	return m.Size()
}
func (m *AlertInstance) XXX_DiscardUnknown() {
	xxx_messageInfo_AlertInstance.DiscardUnknown(m)
}

var xxx_messageInfo_AlertInstance proto.InternalMessageInfo

func (m *AlertInstance) GetLabels() *labelpb.LabelSet {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *AlertInstance) GetAnnotations() *labelpb.LabelSet {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *AlertInstance) GetState() AlertState {
	if m != nil {
		return m.State
	}
	return AlertState_INACTIVE
}

func (m *AlertInstance) GetActiveAt() *Timestamp {
	if m != nil {
		return m.ActiveAt
	}
	return nil
}

func (m *AlertInstance) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *AlertInstance) GetPartialResponseStrategy() storepb.PartialResponseStrategy {
	if m != nil {
		return m.PartialResponseStrategy
	}
	return storepb.PartialResponseStrategy_WARN
}

type Alert struct {
	// / state returns the maximum state of alert instances for this rule.
	// @gotags: json:"state"
	State AlertState `protobuf:"varint,1,opt,name=state,proto3,enum=thanos.AlertState" json:"state"`
	// @gotags: json:"name"
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	// @gotags: json:"query"
	Query string `protobuf:"bytes,3,opt,name=query,proto3" json:"query"`
	// @gotags: json:"duration"
	DurationSeconds float64 `protobuf:"fixed64,4,opt,name=duration_seconds,json=durationSeconds,proto3" json:"duration"`
	// @gotags: json:"labels"
	Labels *labelpb.LabelSet `protobuf:"bytes,5,opt,name=labels,proto3" json:"labels"`
	// @gotags: json:"annotations"
	Annotations *labelpb.LabelSet `protobuf:"bytes,6,opt,name=annotations,proto3" json:"annotations"`
	// @gotags: json:"alerts"
	Alerts []*AlertInstance `protobuf:"bytes,7,rep,name=alerts,proto3" json:"alerts"`
	// @gotags: json:"health"
	Health string `protobuf:"bytes,8,opt,name=health,proto3" json:"health"`
	// @gotags: json:"lastError,omitempty"
	LastError string `protobuf:"bytes,9,opt,name=last_error,json=lastError,proto3" json:"lastError,omitempty"`
	// @gotags: json:"evaluationTime"
	EvaluationDurationSeconds float64 `protobuf:"fixed64,10,opt,name=evaluation_duration_seconds,json=evaluationDurationSeconds,proto3" json:"evaluationTime"`
	// @gotags: json:"lastEvaluation,omitempty"
	LastEvaluation *Timestamp `protobuf:"bytes,11,opt,name=last_evaluation,json=lastEvaluation,proto3" json:"lastEvaluation,omitempty"`
	// @gotags: json:"keepFiringFor"
	KeepFiringForSeconds float64  `protobuf:"fixed64,12,opt,name=keep_firing_for_seconds,json=keepFiringForSeconds,proto3" json:"keepFiringFor"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Alert) Reset()         { *m = Alert{} }
func (m *Alert) String() string { return proto.CompactTextString(m) }
func (*Alert) ProtoMessage()    {}
func (*Alert) Descriptor() ([]byte, []int) {
	return fileDescriptor_91b1d28f30eb5efb, []int{6}
}
func (m *Alert) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Alert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Alert.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Alert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Alert.Merge(m, src)
}
func (m *Alert) XXX_Size() int {
	return m.Size()
}
func (m *Alert) XXX_DiscardUnknown() {
	xxx_messageInfo_Alert.DiscardUnknown(m)
}

var xxx_messageInfo_Alert proto.InternalMessageInfo

func (m *Alert) GetState() AlertState {
	if m != nil {
		return m.State
	}
	return AlertState_INACTIVE
}

func (m *Alert) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Alert) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *Alert) GetDurationSeconds() float64 {
	if m != nil {
		return m.DurationSeconds
	}
	return 0
}

func (m *Alert) GetLabels() *labelpb.LabelSet {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Alert) GetAnnotations() *labelpb.LabelSet {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *Alert) GetAlerts() []*AlertInstance {
	if m != nil {
		return m.Alerts
	}
	return nil
}

func (m *Alert) GetHealth() string {
	if m != nil {
		return m.Health
	}
	return ""
}

func (m *Alert) GetLastError() string {
	if m != nil {
		return m.LastError
	}
	return ""
}

func (m *Alert) GetEvaluationDurationSeconds() float64 {
	if m != nil {
		return m.EvaluationDurationSeconds
	}
	return 0
}

func (m *Alert) GetLastEvaluation() *Timestamp {
	if m != nil {
		return m.LastEvaluation
	}
	return nil
}

func (m *Alert) GetKeepFiringForSeconds() float64 {
	if m != nil {
		return m.KeepFiringForSeconds
	}
	return 0
}

type RecordingRule struct {
	// @gotags: json:"name"
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name"`
	// @gotags: json:"query"
	Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query"`
	// @gotags: json:"labels"
	Labels *labelpb.LabelSet `protobuf:"bytes,3,opt,name=labels,proto3" json:"labels"`
	// @gotags: json:"health"
	Health string `protobuf:"bytes,4,opt,name=health,proto3" json:"health"`
	// @gotags: json:"lastError,omitempty"
	LastError string `protobuf:"bytes,5,opt,name=last_error,json=lastError,proto3" json:"lastError,omitempty"`
	// @gotags: json:"evaluationTime"
	EvaluationDurationSeconds float64 `protobuf:"fixed64,6,opt,name=evaluation_duration_seconds,json=evaluationDurationSeconds,proto3" json:"evaluationTime"`
	// @gotags: json:"lastEvaluation"
	LastEvaluation       *Timestamp `protobuf:"bytes,7,opt,name=last_evaluation,json=lastEvaluation,proto3" json:"lastEvaluation"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RecordingRule) Reset()         { *m = RecordingRule{} }
func (m *RecordingRule) String() string { return proto.CompactTextString(m) }
func (*RecordingRule) ProtoMessage()    {}
func (*RecordingRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_91b1d28f30eb5efb, []int{7}
}
func (m *RecordingRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordingRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordingRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecordingRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordingRule.Merge(m, src)
}
func (m *RecordingRule) XXX_Size() int {
	return m.Size()
}
func (m *RecordingRule) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordingRule.DiscardUnknown(m)
}

var xxx_messageInfo_RecordingRule proto.InternalMessageInfo

func (m *RecordingRule) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RecordingRule) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *RecordingRule) GetLabels() *labelpb.LabelSet {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *RecordingRule) GetHealth() string {
	if m != nil {
		return m.Health
	}
	return ""
}

func (m *RecordingRule) GetLastError() string {
	if m != nil {
		return m.LastError
	}
	return ""
}

func (m *RecordingRule) GetEvaluationDurationSeconds() float64 {
	if m != nil {
		return m.EvaluationDurationSeconds
	}
	return 0
}

func (m *RecordingRule) GetLastEvaluation() *Timestamp {
	if m != nil {
		return m.LastEvaluation
	}
	return nil
}

type Timestamp struct {
	// Represents seconds of UTC time since Unix epoch
	// 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
	// 9999-12-31T23:59:59Z inclusive.
	Seconds int64 `protobuf:"varint,1,opt,name=seconds,proto3" json:"seconds,omitempty"`
	// Non-negative fractions of a second at nanosecond resolution. Negative
	// second values with fractions must still have non-negative nanos values
	// that count forward in time. Must be from 0 to 999,999,999
	// inclusive.
	Nanos                int32    `protobuf:"varint,2,opt,name=nanos,proto3" json:"nanos,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Timestamp) Reset()         { *m = Timestamp{} }
func (m *Timestamp) String() string { return proto.CompactTextString(m) }
func (*Timestamp) ProtoMessage()    {}
func (*Timestamp) Descriptor() ([]byte, []int) {
	return fileDescriptor_91b1d28f30eb5efb, []int{8}
}
func (m *Timestamp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Timestamp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Timestamp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Timestamp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Timestamp.Merge(m, src)
}
func (m *Timestamp) XXX_Size() int {
	return m.Size()
}
func (m *Timestamp) XXX_DiscardUnknown() {
	xxx_messageInfo_Timestamp.DiscardUnknown(m)
}

var xxx_messageInfo_Timestamp proto.InternalMessageInfo

func (m *Timestamp) GetSeconds() int64 {
	if m != nil {
		return m.Seconds
	}
	return 0
}

func (m *Timestamp) GetNanos() int32 {
	if m != nil {
		return m.Nanos
	}
	return 0
}

func init() {
	proto.RegisterEnum("thanos.AlertState", AlertState_name, AlertState_value)
	proto.RegisterEnum("thanos.RulesRequest_Type", RulesRequest_Type_name, RulesRequest_Type_value)
	proto.RegisterType((*RulesRequest)(nil), "thanos.RulesRequest")
	proto.RegisterType((*RulesResponse)(nil), "thanos.RulesResponse")
	proto.RegisterType((*RuleGroups)(nil), "thanos.RuleGroups")
	proto.RegisterType((*RuleGroup)(nil), "thanos.RuleGroup")
	proto.RegisterType((*Rule)(nil), "thanos.Rule")
	proto.RegisterType((*AlertInstance)(nil), "thanos.AlertInstance")
	proto.RegisterType((*Alert)(nil), "thanos.Alert")
	proto.RegisterType((*RecordingRule)(nil), "thanos.RecordingRule")
	proto.RegisterType((*Timestamp)(nil), "thanos.Timestamp")
}

func init() { proto.RegisterFile("rules/rulespb/rpc.proto", fileDescriptor_91b1d28f30eb5efb) }

var fileDescriptor_91b1d28f30eb5efb = []byte{
	// 930 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xe1, 0x6e, 0xdb, 0x36,
	0x10, 0xb6, 0x64, 0x4b, 0xb6, 0xce, 0x71, 0xea, 0x11, 0xc9, 0xa2, 0xa4, 0x58, 0x66, 0x08, 0xe8,
	0xe0, 0x0c, 0xa8, 0x33, 0xb8, 0xe8, 0x06, 0x6c, 0xc0, 0x06, 0xb7, 0x71, 0x1a, 0x03, 0x41, 0x56,
	0xd0, 0xc1, 0x80, 0x6d, 0x3f, 0x3c, 0xc6, 0x61, 0x12, 0x61, 0xb2, 0xa4, 0x92, 0x74, 0x86, 0xbc,
	0xc8, 0x9e, 0x65, 0x7b, 0x83, 0xfd, 0xdc, 0x23, 0x14, 0x79, 0x8f, 0x01, 0x03, 0x8f, 0x92, 0x2d,
	0xb7, 0x6e, 0xe3, 0xa6, 0x7f, 0x0c, 0xf2, 0xbe, 0x4f, 0x77, 0xe2, 0x77, 0xf7, 0xd1, 0x82, 0x2d,
	0x31, 0x8d, 0xb8, 0xdc, 0xc7, 0xdf, 0xf4, 0x6c, 0x5f, 0xa4, 0xe3, 0x4e, 0x2a, 0x12, 0x95, 0x10,
	0x57, 0x5d, 0xb1, 0x38, 0x91, 0x3b, 0xdb, 0x52, 0x25, 0x82, 0xef, 0xe3, 0x6f, 0x7a, 0xb6, 0xaf,
	0x6e, 0x52, 0x2e, 0x0d, 0x25, 0x87, 0x22, 0x76, 0xc6, 0xa3, 0x45, 0x28, 0xf8, 0xdb, 0x86, 0x35,
	0xaa, 0x73, 0x52, 0xfe, 0x6a, 0xca, 0xa5, 0x22, 0x8f, 0xa1, 0xa2, 0x71, 0xdf, 0x6a, 0x59, 0xed,
	0xf5, 0xee, 0x76, 0xc7, 0x64, 0xef, 0x14, 0x39, 0x9d, 0xd3, 0x9b, 0x94, 0x53, 0xa4, 0x91, 0x5f,
	0x61, 0x3b, 0x65, 0x42, 0x85, 0x2c, 0x1a, 0x09, 0x2e, 0xd3, 0x24, 0x96, 0x7c, 0x24, 0x95, 0x60,
	0x8a, 0x5f, 0xde, 0xf8, 0x36, 0xe6, 0xf8, 0x3c, 0xcf, 0xf1, 0xd2, 0x10, 0x69, 0xc6, 0x1b, 0x66,
	0x34, 0xba, 0x95, 0x2e, 0x07, 0xc8, 0x23, 0x58, 0x9f, 0x30, 0x35, 0xbe, 0xe2, 0x42, 0xe7, 0x0c,
	0xe3, 0x4b, 0xbf, 0xdc, 0x2a, 0xb7, 0x3d, 0xda, 0xc8, 0xa2, 0x43, 0x0c, 0x92, 0x87, 0xe0, 0x69,
	0x59, 0x46, 0x31, 0x9b, 0x70, 0xbf, 0x82, 0x8c, 0x9a, 0x0e, 0x9c, 0xb0, 0x09, 0x27, 0x9f, 0x01,
	0x20, 0x78, 0x29, 0x92, 0x69, 0xea, 0x3b, 0x88, 0x22, 0xfd, 0x85, 0x0e, 0x10, 0x02, 0x95, 0x8b,
	0x30, 0xe2, 0xbe, 0x8b, 0x00, 0xae, 0x83, 0x2f, 0xa0, 0xa2, 0x4f, 0x48, 0xaa, 0x50, 0xee, 0x1d,
	0x1f, 0x37, 0x4b, 0xc4, 0x03, 0xa7, 0x77, 0xdc, 0xa7, 0xa7, 0x4d, 0x8b, 0x00, 0xb8, 0xb4, 0xff,
	0xfc, 0x47, 0x7a, 0xd0, 0xb4, 0x83, 0xdf, 0xa0, 0x91, 0xc9, 0x62, 0xde, 0x9b, 0xec, 0x81, 0x63,
	0xca, 0x68, 0xf1, 0xea, 0xdd, 0x4f, 0x8a, 0xe2, 0x61, 0xb9, 0xa3, 0x12, 0x35, 0x0c, 0xb2, 0x03,
	0xd5, 0x3f, 0x98, 0x88, 0xf5, 0x99, 0xb4, 0x4a, 0xde, 0x51, 0x89, 0xe6, 0x81, 0x67, 0x35, 0x70,
	0x05, 0x97, 0xd3, 0x48, 0x05, 0xdf, 0x00, 0xcc, 0x9e, 0x95, 0x64, 0x0f, 0x5c, 0x7c, 0x58, 0xfa,
	0x56, 0xab, 0xbc, 0x34, 0x3f, 0xcd, 0x08, 0xc1, 0x6b, 0x1b, 0x3c, 0x5a, 0x3c, 0x24, 0x6a, 0xa3,
	0x5f, 0xcb, 0xa3, 0xb8, 0x9e, 0x1d, 0xdc, 0x36, 0x31, 0xbd, 0x26, 0x01, 0x38, 0x38, 0x5f, 0x28,
	0x73, 0xbd, 0xbb, 0x56, 0xcc, 0x4f, 0x0d, 0x44, 0x76, 0xa0, 0x16, 0xc6, 0x8a, 0x8b, 0x6b, 0x16,
	0xf9, 0x95, 0x96, 0xd5, 0xb6, 0xe8, 0x6c, 0x4f, 0xbe, 0x87, 0x87, 0xfc, 0x9a, 0x45, 0x53, 0xa6,
	0xc2, 0x24, 0x1e, 0x9d, 0x4f, 0x85, 0x59, 0x48, 0x3e, 0x4e, 0xe2, 0x73, 0xe9, 0x3b, 0x48, 0xdf,
	0x9e, 0x53, 0x0e, 0x32, 0xc6, 0xd0, 0x10, 0xc8, 0xb7, 0xf0, 0x20, 0x62, 0x52, 0x8d, 0xe6, 0x0c,
	0xdf, 0x5d, 0x54, 0xf2, 0x34, 0x9c, 0x70, 0xa9, 0xd8, 0x24, 0xa5, 0xeb, 0x9a, 0xd9, 0x9f, 0x11,
	0xc9, 0x06, 0x38, 0x51, 0x38, 0x09, 0x95, 0xef, 0xb5, 0xac, 0x76, 0x99, 0x9a, 0x0d, 0xf9, 0x19,
	0xb6, 0xde, 0x31, 0x75, 0x7e, 0x6d, 0xc5, 0xe1, 0x7c, 0x07, 0x10, 0xc4, 0x50, 0xd1, 0xba, 0x90,
	0xa7, 0xe0, 0x09, 0x3e, 0x4e, 0xc4, 0xb9, 0xee, 0xa5, 0x69, 0xfc, 0xe6, 0x4c, 0xb8, 0x1c, 0xd0,
	0xcc, 0xa3, 0x12, 0x9d, 0x33, 0xc9, 0x23, 0x70, 0x58, 0xc4, 0x85, 0xc2, 0x06, 0xd4, 0xbb, 0x8d,
	0xfc, 0x91, 0x9e, 0x0e, 0xea, 0x39, 0x41, 0xb4, 0x30, 0x0b, 0x7f, 0xd9, 0xd0, 0x40, 0x70, 0x10,
	0x4b, 0xc5, 0xe2, 0x31, 0x27, 0x6d, 0x70, 0xd1, 0xd2, 0x32, 0x2b, 0xdb, 0xcc, 0x73, 0x1c, 0xeb,
	0xe8, 0x90, 0x2b, 0x9a, 0xe1, 0xa4, 0x0b, 0x75, 0x16, 0xc7, 0x89, 0x42, 0xa9, 0x64, 0x56, 0xf2,
	0x6d, 0x7a, 0x91, 0x44, 0xda, 0xe0, 0x48, 0xc5, 0x14, 0xf7, 0xcb, 0x28, 0x14, 0x59, 0x78, 0xc1,
	0xa1, 0x46, 0xa8, 0x21, 0x90, 0x0e, 0x78, 0x6c, 0xac, 0xc2, 0x6b, 0x3e, 0x62, 0x0a, 0x67, 0x62,
	0x69, 0xc3, 0x6a, 0x86, 0xd3, 0x53, 0xba, 0x55, 0xba, 0x6f, 0x1c, 0x07, 0xc2, 0xa3, 0x66, 0xf3,
	0xbe, 0x56, 0xb9, 0x1f, 0xd9, 0xaa, 0xff, 0xca, 0xe0, 0xe0, 0x6b, 0xcf, 0x0f, 0x65, 0xdd, 0x75,
	0xa8, 0xdc, 0x33, 0x76, 0xc1, 0x33, 0x1b, 0xe0, 0xbc, 0x9a, 0x72, 0x71, 0x83, 0x92, 0x78, 0xd4,
	0x6c, 0xc8, 0x1e, 0x34, 0xdf, 0x1a, 0x75, 0xe3, 0x8c, 0x07, 0xe7, 0x6f, 0x0c, 0xf8, 0xbc, 0x63,
	0xce, 0x87, 0x75, 0xcc, 0x5d, 0xa5, 0x63, 0x8f, 0xc1, 0xc5, 0xa1, 0x91, 0x7e, 0x15, 0xfd, 0xbb,
	0xb9, 0x70, 0xba, 0x7c, 0x6c, 0x68, 0x46, 0x22, 0x9f, 0x82, 0x7b, 0xc5, 0x59, 0xa4, 0xae, 0xd0,
	0x0a, 0x1e, 0xcd, 0x76, 0xfa, 0xc6, 0x34, 0x2e, 0x14, 0x22, 0x11, 0x68, 0x27, 0x8f, 0x7a, 0xe8,
	0x36, 0x1d, 0xb8, 0xcb, 0xe4, 0x70, 0x0f, 0x93, 0xd7, 0x57, 0x35, 0xf9, 0x53, 0xd8, 0xfa, 0x9d,
	0xf3, 0x74, 0x74, 0x11, 0xea, 0x8b, 0x7f, 0x74, 0x91, 0x88, 0x59, 0xdd, 0x35, 0xac, 0xbb, 0xa1,
	0xe1, 0x43, 0x44, 0x0f, 0x13, 0x91, 0x95, 0x0c, 0xfe, 0xb4, 0xa1, 0xb1, 0x60, 0xc5, 0xa5, 0x37,
	0xe2, 0xac, 0xbb, 0x76, 0xb1, 0xbb, 0xf3, 0x96, 0x95, 0xef, 0x68, 0xd9, 0x5c, 0xcf, 0xca, 0x7b,
	0xf4, 0x74, 0x3e, 0x50, 0x4f, 0xf7, 0x1e, 0x7a, 0x56, 0x57, 0xd4, 0x33, 0xf8, 0x0e, 0xbc, 0x19,
	0x48, 0x7c, 0xa8, 0xe6, 0x45, 0x2d, 0xbc, 0x43, 0xf3, 0xad, 0x56, 0x26, 0xd6, 0x99, 0x50, 0x19,
	0x87, 0x9a, 0xcd, 0x97, 0x4f, 0x00, 0xe6, 0xb6, 0x21, 0x6b, 0x50, 0x1b, 0x9c, 0xf4, 0x9e, 0x9f,
	0x0e, 0x7e, 0xea, 0x37, 0x4b, 0xa4, 0x0e, 0xd5, 0x97, 0xfd, 0x93, 0x83, 0xc1, 0xc9, 0x0b, 0xf3,
	0x9f, 0x79, 0x38, 0xa0, 0x7a, 0x6d, 0x77, 0x7f, 0x00, 0x07, 0xff, 0x33, 0xc9, 0xd7, 0xf9, 0x62,
	0x63, 0xd9, 0x27, 0xc6, 0xce, 0xe6, 0x1b, 0x51, 0xe3, 0xe8, 0xaf, 0xac, 0x67, 0x9b, 0xff, 0xdc,
	0xee, 0x5a, 0xff, 0xde, 0xee, 0x5a, 0xaf, 0x6f, 0x77, 0xad, 0x5f, 0xaa, 0xd9, 0xf7, 0xd0, 0x99,
	0x8b, 0x9f, 0x33, 0x4f, 0xfe, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x02, 0xfc, 0x7c, 0x3f, 0x27, 0x09,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RulesClient is the client API for Rules service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RulesClient interface {
	// / Rules has info for all rules.
	// / Returned rules are expected to include external labels.
	Rules(ctx context.Context, in *RulesRequest, opts ...grpc.CallOption) (Rules_RulesClient, error)
}

type rulesClient struct {
	cc *grpc.ClientConn
}

func NewRulesClient(cc *grpc.ClientConn) RulesClient {
	return &rulesClient{cc}
}

func (c *rulesClient) Rules(ctx context.Context, in *RulesRequest, opts ...grpc.CallOption) (Rules_RulesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Rules_serviceDesc.Streams[0], "/thanos.Rules/Rules", opts...)
	if err != nil {
		return nil, err
	}
	x := &rulesRulesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Rules_RulesClient interface {
	Recv() (*RulesResponse, error)
	grpc.ClientStream
}

type rulesRulesClient struct {
	grpc.ClientStream
}

func (x *rulesRulesClient) Recv() (*RulesResponse, error) {
	m := new(RulesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RulesServer is the server API for Rules service.
type RulesServer interface {
	// / Rules has info for all rules.
	// / Returned rules are expected to include external labels.
	Rules(*RulesRequest, Rules_RulesServer) error
}

// UnimplementedRulesServer can be embedded to have forward compatible implementations.
type UnimplementedRulesServer struct {
}

func (*UnimplementedRulesServer) Rules(req *RulesRequest, srv Rules_RulesServer) error {
	return status.Errorf(codes.Unimplemented, "method Rules not implemented")
}

func RegisterRulesServer(s *grpc.Server, srv RulesServer) {
	s.RegisterService(&_Rules_serviceDesc, srv)
}

func _Rules_Rules_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RulesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RulesServer).Rules(m, &rulesRulesServer{stream})
}

type Rules_RulesServer interface {
	Send(*RulesResponse) error
	grpc.ServerStream
}

type rulesRulesServer struct {
	grpc.ServerStream
}

func (x *rulesRulesServer) Send(m *RulesResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Rules_serviceDesc = grpc.ServiceDesc{
	ServiceName: "thanos.Rules",
	HandlerType: (*RulesServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Rules",
			Handler:       _Rules_Rules_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "rules/rulespb/rpc.proto",
}

func (m *RulesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RulesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RulesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.File) > 0 {
		for iNdEx := len(m.File) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.File[iNdEx])
			copy(dAtA[i:], m.File[iNdEx])
			i = encodeVarintRpc(dAtA, i, uint64(len(m.File[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.RuleGroup) > 0 {
		for iNdEx := len(m.RuleGroup) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RuleGroup[iNdEx])
			copy(dAtA[i:], m.RuleGroup[iNdEx])
			i = encodeVarintRpc(dAtA, i, uint64(len(m.RuleGroup[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.RuleName) > 0 {
		for iNdEx := len(m.RuleName) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RuleName[iNdEx])
			copy(dAtA[i:], m.RuleName[iNdEx])
			i = encodeVarintRpc(dAtA, i, uint64(len(m.RuleName[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.MatcherString) > 0 {
		for iNdEx := len(m.MatcherString) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MatcherString[iNdEx])
			copy(dAtA[i:], m.MatcherString[iNdEx])
			i = encodeVarintRpc(dAtA, i, uint64(len(m.MatcherString[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.PartialResponseStrategy != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.PartialResponseStrategy))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RulesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RulesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RulesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Result != nil {
		{
			size := m.Result.Size()
			i -= size
			if _, err := m.Result.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *RulesResponse_Group) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RulesResponse_Group) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Group != nil {
		{
			size, err := m.Group.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *RulesResponse_Warning) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RulesResponse_Warning) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Warning)
	copy(dAtA[i:], m.Warning)
	i = encodeVarintRpc(dAtA, i, uint64(len(m.Warning)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *RuleGroups) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuleGroups) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RuleGroups) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Groups) > 0 {
		for iNdEx := len(m.Groups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Groups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RuleGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuleGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RuleGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Limit != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x48
	}
	if m.PartialResponseStrategy != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.PartialResponseStrategy))
		i--
		dAtA[i] = 0x40
	}
	if m.LastEvaluation != nil {
		{
			size, err := m.LastEvaluation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.EvaluationDurationSeconds != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.EvaluationDurationSeconds))))
		i--
		dAtA[i] = 0x29
	}
	if m.Interval != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Interval))))
		i--
		dAtA[i] = 0x21
	}
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.File) > 0 {
		i -= len(m.File)
		copy(dAtA[i:], m.File)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.File)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Rule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Rule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Result != nil {
		{
			size := m.Result.Size()
			i -= size
			if _, err := m.Result.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Rule_Recording) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Rule_Recording) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Recording != nil {
		{
			size, err := m.Recording.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Rule_Alert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Rule_Alert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Alert != nil {
		{
			size, err := m.Alert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AlertInstance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertInstance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlertInstance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PartialResponseStrategy != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.PartialResponseStrategy))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ActiveAt != nil {
		{
			size, err := m.ActiveAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.State != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if m.Annotations != nil {
		{
			size, err := m.Annotations.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Labels != nil {
		{
			size, err := m.Labels.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Alert) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Alert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Alert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.KeepFiringForSeconds != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.KeepFiringForSeconds))))
		i--
		dAtA[i] = 0x61
	}
	if m.LastEvaluation != nil {
		{
			size, err := m.LastEvaluation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.EvaluationDurationSeconds != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.EvaluationDurationSeconds))))
		i--
		dAtA[i] = 0x51
	}
	if len(m.LastError) > 0 {
		i -= len(m.LastError)
		copy(dAtA[i:], m.LastError)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.LastError)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Health) > 0 {
		i -= len(m.Health)
		copy(dAtA[i:], m.Health)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Health)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Alerts) > 0 {
		for iNdEx := len(m.Alerts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Alerts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Annotations != nil {
		{
			size, err := m.Annotations.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Labels != nil {
		{
			size, err := m.Labels.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DurationSeconds != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DurationSeconds))))
		i--
		dAtA[i] = 0x21
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.State != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RecordingRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordingRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecordingRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LastEvaluation != nil {
		{
			size, err := m.LastEvaluation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.EvaluationDurationSeconds != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.EvaluationDurationSeconds))))
		i--
		dAtA[i] = 0x31
	}
	if len(m.LastError) > 0 {
		i -= len(m.LastError)
		copy(dAtA[i:], m.LastError)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.LastError)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Health) > 0 {
		i -= len(m.Health)
		copy(dAtA[i:], m.Health)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Health)))
		i--
		dAtA[i] = 0x22
	}
	if m.Labels != nil {
		{
			size, err := m.Labels.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Timestamp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Timestamp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Timestamp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Nanos != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Nanos))
		i--
		dAtA[i] = 0x10
	}
	if m.Seconds != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Seconds))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintRpc(dAtA []byte, offset int, v uint64) int {
	offset -= sovRpc(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RulesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovRpc(uint64(m.Type))
	}
	if m.PartialResponseStrategy != 0 {
		n += 1 + sovRpc(uint64(m.PartialResponseStrategy))
	}
	if len(m.MatcherString) > 0 {
		for _, s := range m.MatcherString {
			l = len(s)
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if len(m.RuleName) > 0 {
		for _, s := range m.RuleName {
			l = len(s)
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if len(m.RuleGroup) > 0 {
		for _, s := range m.RuleGroup {
			l = len(s)
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if len(m.File) > 0 {
		for _, s := range m.File {
			l = len(s)
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RulesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		n += m.Result.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RulesResponse_Group) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	return n
}
func (m *RulesResponse_Warning) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Warning)
	n += 1 + l + sovRpc(uint64(l))
	return n
}
func (m *RuleGroups) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RuleGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.File)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.Interval != 0 {
		n += 9
	}
	if m.EvaluationDurationSeconds != 0 {
		n += 9
	}
	if m.LastEvaluation != nil {
		l = m.LastEvaluation.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.PartialResponseStrategy != 0 {
		n += 1 + sovRpc(uint64(m.PartialResponseStrategy))
	}
	if m.Limit != 0 {
		n += 1 + sovRpc(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Rule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		n += m.Result.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Rule_Recording) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Recording != nil {
		l = m.Recording.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	return n
}
func (m *Rule_Alert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Alert != nil {
		l = m.Alert.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	return n
}
func (m *AlertInstance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Labels != nil {
		l = m.Labels.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovRpc(uint64(m.State))
	}
	if m.ActiveAt != nil {
		l = m.ActiveAt.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.PartialResponseStrategy != 0 {
		n += 1 + sovRpc(uint64(m.PartialResponseStrategy))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Alert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovRpc(uint64(m.State))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.DurationSeconds != 0 {
		n += 9
	}
	if m.Labels != nil {
		l = m.Labels.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.Annotations != nil {
		l = m.Annotations.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	if len(m.Alerts) > 0 {
		for _, e := range m.Alerts {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	l = len(m.Health)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.LastError)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.EvaluationDurationSeconds != 0 {
		n += 9
	}
	if m.LastEvaluation != nil {
		l = m.LastEvaluation.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.KeepFiringForSeconds != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecordingRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.Labels != nil {
		l = m.Labels.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.Health)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.LastError)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.EvaluationDurationSeconds != 0 {
		n += 9
	}
	if m.LastEvaluation != nil {
		l = m.LastEvaluation.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Timestamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seconds != 0 {
		n += 1 + sovRpc(uint64(m.Seconds))
	}
	if m.Nanos != 0 {
		n += 1 + sovRpc(uint64(m.Nanos))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovRpc(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRpc(x uint64) (n int) {
	return sovRpc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RulesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RulesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RulesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= RulesRequest_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialResponseStrategy", wireType)
			}
			m.PartialResponseStrategy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartialResponseStrategy |= storepb.PartialResponseStrategy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatcherString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatcherString = append(m.MatcherString, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleName = append(m.RuleName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleGroup = append(m.RuleGroup, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = append(m.File, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RulesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RulesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RulesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RuleGroup{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &RulesResponse_Group{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Warning", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = &RulesResponse_Warning{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuleGroups) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuleGroups: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuleGroups: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &RuleGroup{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuleGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuleGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuleGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &Rule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Interval = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvaluationDurationSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.EvaluationDurationSeconds = float64(math.Float64frombits(v))
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastEvaluation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastEvaluation == nil {
				m.LastEvaluation = &Timestamp{}
			}
			if err := m.LastEvaluation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialResponseStrategy", wireType)
			}
			m.PartialResponseStrategy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartialResponseStrategy |= storepb.PartialResponseStrategy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recording", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RecordingRule{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &Rule_Recording{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Alert{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &Rule_Alert{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertInstance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertInstance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertInstance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = &labelpb.LabelSet{}
			}
			if err := m.Labels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &labelpb.LabelSet{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= AlertState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActiveAt == nil {
				m.ActiveAt = &Timestamp{}
			}
			if err := m.ActiveAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialResponseStrategy", wireType)
			}
			m.PartialResponseStrategy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartialResponseStrategy |= storepb.PartialResponseStrategy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Alert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Alert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Alert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= AlertState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DurationSeconds = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = &labelpb.LabelSet{}
			}
			if err := m.Labels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = &labelpb.LabelSet{}
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alerts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alerts = append(m.Alerts, &AlertInstance{})
			if err := m.Alerts[len(m.Alerts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Health", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Health = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvaluationDurationSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.EvaluationDurationSeconds = float64(math.Float64frombits(v))
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastEvaluation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastEvaluation == nil {
				m.LastEvaluation = &Timestamp{}
			}
			if err := m.LastEvaluation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepFiringForSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.KeepFiringForSeconds = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordingRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordingRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordingRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = &labelpb.LabelSet{}
			}
			if err := m.Labels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Health", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Health = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvaluationDurationSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.EvaluationDurationSeconds = float64(math.Float64frombits(v))
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastEvaluation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastEvaluation == nil {
				m.LastEvaluation = &Timestamp{}
			}
			if err := m.LastEvaluation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Timestamp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timestamp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timestamp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seconds", wireType)
			}
			m.Seconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nanos", wireType)
			}
			m.Nanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nanos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRpc(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRpc
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRpc
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRpc
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRpc        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRpc          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRpc = fmt.Errorf("proto: unexpected end of group")
)
