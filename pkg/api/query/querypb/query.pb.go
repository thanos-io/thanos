// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/query/querypb/query.proto

package querypb

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	storepb "github.com/thanos-io/thanos/pkg/store/storepb"
	prompb "github.com/thanos-io/thanos/pkg/store/storepb/prompb"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type EngineType int32

const (
	EngineType_default    EngineType = 0
	EngineType_prometheus EngineType = 1
	EngineType_thanos     EngineType = 2
)

var EngineType_name = map[int32]string{
	0: "default",
	1: "prometheus",
	2: "thanos",
}

var EngineType_value = map[string]int32{
	"default":    0,
	"prometheus": 1,
	"thanos":     2,
}

func (x EngineType) String() string {
	return proto.EnumName(EngineType_name, int32(x))
}

func (EngineType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4b2aba43925d729f, []int{0}
}

type QueryStats struct {
	SamplesTotal int64 `protobuf:"varint,1,opt,name=samples_total,json=samplesTotal,proto3" json:"samples_total,omitempty"`
	PeakSamples  int64 `protobuf:"varint,2,opt,name=peak_samples,json=peakSamples,proto3" json:"peak_samples,omitempty"`
}

func (m *QueryStats) Reset()         { *m = QueryStats{} }
func (m *QueryStats) String() string { return proto.CompactTextString(m) }
func (*QueryStats) ProtoMessage()    {}
func (*QueryStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b2aba43925d729f, []int{0}
}
func (m *QueryStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryStats.Merge(m, src)
}
func (m *QueryStats) XXX_Size() int {
	return m.Size()
}
func (m *QueryStats) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryStats.DiscardUnknown(m)
}

var xxx_messageInfo_QueryStats proto.InternalMessageInfo

type TimeSeriesBatch struct {
	Series []*prompb.TimeSeries `protobuf:"bytes,1,rep,name=series,proto3" json:"series,omitempty"`
}

func (m *TimeSeriesBatch) Reset()         { *m = TimeSeriesBatch{} }
func (m *TimeSeriesBatch) String() string { return proto.CompactTextString(m) }
func (*TimeSeriesBatch) ProtoMessage()    {}
func (*TimeSeriesBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b2aba43925d729f, []int{1}
}
func (m *TimeSeriesBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimeSeriesBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimeSeriesBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimeSeriesBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimeSeriesBatch.Merge(m, src)
}
func (m *TimeSeriesBatch) XXX_Size() int {
	return m.Size()
}
func (m *TimeSeriesBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_TimeSeriesBatch.DiscardUnknown(m)
}

var xxx_messageInfo_TimeSeriesBatch proto.InternalMessageInfo

type QueryRequest struct {
	Query                 string             `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	QueryPlan             *QueryPlan         `protobuf:"bytes,14,opt,name=queryPlan,proto3" json:"queryPlan,omitempty"`
	TimeSeconds           int64              `protobuf:"varint,2,opt,name=time_seconds,json=timeSeconds,proto3" json:"time_seconds,omitempty"`
	TimeoutSeconds        int64              `protobuf:"varint,3,opt,name=timeout_seconds,json=timeoutSeconds,proto3" json:"timeout_seconds,omitempty"`
	MaxResolutionSeconds  int64              `protobuf:"varint,4,opt,name=max_resolution_seconds,json=maxResolutionSeconds,proto3" json:"max_resolution_seconds,omitempty"`
	ReplicaLabels         []string           `protobuf:"bytes,5,rep,name=replica_labels,json=replicaLabels,proto3" json:"replica_labels,omitempty"`
	StoreMatchers         []StoreMatchers    `protobuf:"bytes,6,rep,name=storeMatchers,proto3" json:"storeMatchers"`
	EnableDedup           bool               `protobuf:"varint,7,opt,name=enableDedup,proto3" json:"enableDedup,omitempty"`
	EnablePartialResponse bool               `protobuf:"varint,8,opt,name=enablePartialResponse,proto3" json:"enablePartialResponse,omitempty"`
	SkipChunks            bool               `protobuf:"varint,10,opt,name=skipChunks,proto3" json:"skipChunks,omitempty"`
	ShardInfo             *storepb.ShardInfo `protobuf:"bytes,11,opt,name=shard_info,json=shardInfo,proto3" json:"shard_info,omitempty"`
	LookbackDeltaSeconds  int64              `protobuf:"varint,12,opt,name=lookback_delta_seconds,json=lookbackDeltaSeconds,proto3" json:"lookback_delta_seconds,omitempty"`
	Engine                EngineType         `protobuf:"varint,13,opt,name=engine,proto3,enum=thanos.EngineType" json:"engine,omitempty"`
	// response_batch_size controls how many TimeSeries are batched per response message.
	// If set to 0 or 1, each TimeSeries is sent as a separate response (default behavior).
	ResponseBatchSize int64 `protobuf:"varint,15,opt,name=response_batch_size,json=responseBatchSize,proto3" json:"response_batch_size,omitempty"`
}

func (m *QueryRequest) Reset()         { *m = QueryRequest{} }
func (m *QueryRequest) String() string { return proto.CompactTextString(m) }
func (*QueryRequest) ProtoMessage()    {}
func (*QueryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b2aba43925d729f, []int{2}
}
func (m *QueryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRequest.Merge(m, src)
}
func (m *QueryRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRequest proto.InternalMessageInfo

type StoreMatchers struct {
	LabelMatchers []storepb.LabelMatcher `protobuf:"bytes,1,rep,name=labelMatchers,proto3" json:"labelMatchers"`
}

func (m *StoreMatchers) Reset()         { *m = StoreMatchers{} }
func (m *StoreMatchers) String() string { return proto.CompactTextString(m) }
func (*StoreMatchers) ProtoMessage()    {}
func (*StoreMatchers) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b2aba43925d729f, []int{3}
}
func (m *StoreMatchers) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreMatchers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreMatchers.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreMatchers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreMatchers.Merge(m, src)
}
func (m *StoreMatchers) XXX_Size() int {
	return m.Size()
}
func (m *StoreMatchers) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreMatchers.DiscardUnknown(m)
}

var xxx_messageInfo_StoreMatchers proto.InternalMessageInfo

type QueryResponse struct {
	// Types that are valid to be assigned to Result:
	//	*QueryResponse_Warnings
	//	*QueryResponse_Timeseries
	//	*QueryResponse_Stats
	//	*QueryResponse_TimeseriesBatch
	Result isQueryResponse_Result `protobuf_oneof:"result"`
}

func (m *QueryResponse) Reset()         { *m = QueryResponse{} }
func (m *QueryResponse) String() string { return proto.CompactTextString(m) }
func (*QueryResponse) ProtoMessage()    {}
func (*QueryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b2aba43925d729f, []int{4}
}
func (m *QueryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResponse.Merge(m, src)
}
func (m *QueryResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResponse proto.InternalMessageInfo

type isQueryResponse_Result interface {
	isQueryResponse_Result()
	MarshalTo([]byte) (int, error)
	Size() int
}

type QueryResponse_Warnings struct {
	Warnings string `protobuf:"bytes,1,opt,name=warnings,proto3,oneof" json:"warnings,omitempty"`
}
type QueryResponse_Timeseries struct {
	Timeseries *prompb.TimeSeries `protobuf:"bytes,2,opt,name=timeseries,proto3,oneof" json:"timeseries,omitempty"`
}
type QueryResponse_Stats struct {
	Stats *QueryStats `protobuf:"bytes,3,opt,name=stats,proto3,oneof" json:"stats,omitempty"`
}
type QueryResponse_TimeseriesBatch struct {
	TimeseriesBatch *TimeSeriesBatch `protobuf:"bytes,4,opt,name=timeseries_batch,json=timeseriesBatch,proto3,oneof" json:"timeseries_batch,omitempty"`
}

func (*QueryResponse_Warnings) isQueryResponse_Result()        {}
func (*QueryResponse_Timeseries) isQueryResponse_Result()      {}
func (*QueryResponse_Stats) isQueryResponse_Result()           {}
func (*QueryResponse_TimeseriesBatch) isQueryResponse_Result() {}

func (m *QueryResponse) GetResult() isQueryResponse_Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *QueryResponse) GetWarnings() string {
	if x, ok := m.GetResult().(*QueryResponse_Warnings); ok {
		return x.Warnings
	}
	return ""
}

func (m *QueryResponse) GetTimeseries() *prompb.TimeSeries {
	if x, ok := m.GetResult().(*QueryResponse_Timeseries); ok {
		return x.Timeseries
	}
	return nil
}

func (m *QueryResponse) GetStats() *QueryStats {
	if x, ok := m.GetResult().(*QueryResponse_Stats); ok {
		return x.Stats
	}
	return nil
}

func (m *QueryResponse) GetTimeseriesBatch() *TimeSeriesBatch {
	if x, ok := m.GetResult().(*QueryResponse_TimeseriesBatch); ok {
		return x.TimeseriesBatch
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*QueryResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*QueryResponse_Warnings)(nil),
		(*QueryResponse_Timeseries)(nil),
		(*QueryResponse_Stats)(nil),
		(*QueryResponse_TimeseriesBatch)(nil),
	}
}

type QueryPlan struct {
	// Types that are valid to be assigned to Encoding:
	//	*QueryPlan_Json
	Encoding isQueryPlan_Encoding `protobuf_oneof:"encoding"`
}

func (m *QueryPlan) Reset()         { *m = QueryPlan{} }
func (m *QueryPlan) String() string { return proto.CompactTextString(m) }
func (*QueryPlan) ProtoMessage()    {}
func (*QueryPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b2aba43925d729f, []int{5}
}
func (m *QueryPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryPlan.Merge(m, src)
}
func (m *QueryPlan) XXX_Size() int {
	return m.Size()
}
func (m *QueryPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryPlan.DiscardUnknown(m)
}

var xxx_messageInfo_QueryPlan proto.InternalMessageInfo

type isQueryPlan_Encoding interface {
	isQueryPlan_Encoding()
	MarshalTo([]byte) (int, error)
	Size() int
}

type QueryPlan_Json struct {
	Json []byte `protobuf:"bytes,1,opt,name=json,proto3,oneof" json:"json,omitempty"`
}

func (*QueryPlan_Json) isQueryPlan_Encoding() {}

func (m *QueryPlan) GetEncoding() isQueryPlan_Encoding {
	if m != nil {
		return m.Encoding
	}
	return nil
}

func (m *QueryPlan) GetJson() []byte {
	if x, ok := m.GetEncoding().(*QueryPlan_Json); ok {
		return x.Json
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*QueryPlan) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*QueryPlan_Json)(nil),
	}
}

type QueryRangeRequest struct {
	Query                 string             `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	QueryPlan             *QueryPlan         `protobuf:"bytes,16,opt,name=queryPlan,proto3" json:"queryPlan,omitempty"`
	StartTimeSeconds      int64              `protobuf:"varint,2,opt,name=start_time_seconds,json=startTimeSeconds,proto3" json:"start_time_seconds,omitempty"`
	EndTimeSeconds        int64              `protobuf:"varint,3,opt,name=end_time_seconds,json=endTimeSeconds,proto3" json:"end_time_seconds,omitempty"`
	IntervalSeconds       int64              `protobuf:"varint,4,opt,name=interval_seconds,json=intervalSeconds,proto3" json:"interval_seconds,omitempty"`
	TimeoutSeconds        int64              `protobuf:"varint,5,opt,name=timeout_seconds,json=timeoutSeconds,proto3" json:"timeout_seconds,omitempty"`
	MaxResolutionSeconds  int64              `protobuf:"varint,6,opt,name=max_resolution_seconds,json=maxResolutionSeconds,proto3" json:"max_resolution_seconds,omitempty"`
	ReplicaLabels         []string           `protobuf:"bytes,7,rep,name=replica_labels,json=replicaLabels,proto3" json:"replica_labels,omitempty"`
	StoreMatchers         []StoreMatchers    `protobuf:"bytes,8,rep,name=storeMatchers,proto3" json:"storeMatchers"`
	EnableDedup           bool               `protobuf:"varint,9,opt,name=enableDedup,proto3" json:"enableDedup,omitempty"`
	EnablePartialResponse bool               `protobuf:"varint,10,opt,name=enablePartialResponse,proto3" json:"enablePartialResponse,omitempty"`
	SkipChunks            bool               `protobuf:"varint,12,opt,name=skipChunks,proto3" json:"skipChunks,omitempty"`
	ShardInfo             *storepb.ShardInfo `protobuf:"bytes,13,opt,name=shard_info,json=shardInfo,proto3" json:"shard_info,omitempty"`
	LookbackDeltaSeconds  int64              `protobuf:"varint,14,opt,name=lookback_delta_seconds,json=lookbackDeltaSeconds,proto3" json:"lookback_delta_seconds,omitempty"`
	Engine                EngineType         `protobuf:"varint,15,opt,name=engine,proto3,enum=thanos.EngineType" json:"engine,omitempty"`
	// response_batch_size controls how many TimeSeries are batched per response message.
	// If set to 0 or 1, each TimeSeries is sent as a separate response (default behavior).
	ResponseBatchSize int64 `protobuf:"varint,17,opt,name=response_batch_size,json=responseBatchSize,proto3" json:"response_batch_size,omitempty"`
}

func (m *QueryRangeRequest) Reset()         { *m = QueryRangeRequest{} }
func (m *QueryRangeRequest) String() string { return proto.CompactTextString(m) }
func (*QueryRangeRequest) ProtoMessage()    {}
func (*QueryRangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b2aba43925d729f, []int{6}
}
func (m *QueryRangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRangeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRangeRequest.Merge(m, src)
}
func (m *QueryRangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryRangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRangeRequest proto.InternalMessageInfo

type QueryRangeResponse struct {
	// Types that are valid to be assigned to Result:
	//	*QueryRangeResponse_Warnings
	//	*QueryRangeResponse_Timeseries
	//	*QueryRangeResponse_Stats
	//	*QueryRangeResponse_TimeseriesBatch
	Result isQueryRangeResponse_Result `protobuf_oneof:"result"`
}

func (m *QueryRangeResponse) Reset()         { *m = QueryRangeResponse{} }
func (m *QueryRangeResponse) String() string { return proto.CompactTextString(m) }
func (*QueryRangeResponse) ProtoMessage()    {}
func (*QueryRangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b2aba43925d729f, []int{7}
}
func (m *QueryRangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRangeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRangeResponse.Merge(m, src)
}
func (m *QueryRangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryRangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRangeResponse proto.InternalMessageInfo

type isQueryRangeResponse_Result interface {
	isQueryRangeResponse_Result()
	MarshalTo([]byte) (int, error)
	Size() int
}

type QueryRangeResponse_Warnings struct {
	Warnings string `protobuf:"bytes,1,opt,name=warnings,proto3,oneof" json:"warnings,omitempty"`
}
type QueryRangeResponse_Timeseries struct {
	Timeseries *prompb.TimeSeries `protobuf:"bytes,2,opt,name=timeseries,proto3,oneof" json:"timeseries,omitempty"`
}
type QueryRangeResponse_Stats struct {
	Stats *QueryStats `protobuf:"bytes,3,opt,name=stats,proto3,oneof" json:"stats,omitempty"`
}
type QueryRangeResponse_TimeseriesBatch struct {
	TimeseriesBatch *TimeSeriesBatch `protobuf:"bytes,4,opt,name=timeseries_batch,json=timeseriesBatch,proto3,oneof" json:"timeseries_batch,omitempty"`
}

func (*QueryRangeResponse_Warnings) isQueryRangeResponse_Result()        {}
func (*QueryRangeResponse_Timeseries) isQueryRangeResponse_Result()      {}
func (*QueryRangeResponse_Stats) isQueryRangeResponse_Result()           {}
func (*QueryRangeResponse_TimeseriesBatch) isQueryRangeResponse_Result() {}

func (m *QueryRangeResponse) GetResult() isQueryRangeResponse_Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *QueryRangeResponse) GetWarnings() string {
	if x, ok := m.GetResult().(*QueryRangeResponse_Warnings); ok {
		return x.Warnings
	}
	return ""
}

func (m *QueryRangeResponse) GetTimeseries() *prompb.TimeSeries {
	if x, ok := m.GetResult().(*QueryRangeResponse_Timeseries); ok {
		return x.Timeseries
	}
	return nil
}

func (m *QueryRangeResponse) GetStats() *QueryStats {
	if x, ok := m.GetResult().(*QueryRangeResponse_Stats); ok {
		return x.Stats
	}
	return nil
}

func (m *QueryRangeResponse) GetTimeseriesBatch() *TimeSeriesBatch {
	if x, ok := m.GetResult().(*QueryRangeResponse_TimeseriesBatch); ok {
		return x.TimeseriesBatch
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*QueryRangeResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*QueryRangeResponse_Warnings)(nil),
		(*QueryRangeResponse_Timeseries)(nil),
		(*QueryRangeResponse_Stats)(nil),
		(*QueryRangeResponse_TimeseriesBatch)(nil),
	}
}

func init() {
	proto.RegisterEnum("thanos.EngineType", EngineType_name, EngineType_value)
	proto.RegisterType((*QueryStats)(nil), "thanos.QueryStats")
	proto.RegisterType((*TimeSeriesBatch)(nil), "thanos.TimeSeriesBatch")
	proto.RegisterType((*QueryRequest)(nil), "thanos.QueryRequest")
	proto.RegisterType((*StoreMatchers)(nil), "thanos.StoreMatchers")
	proto.RegisterType((*QueryResponse)(nil), "thanos.QueryResponse")
	proto.RegisterType((*QueryPlan)(nil), "thanos.queryPlan")
	proto.RegisterType((*QueryRangeRequest)(nil), "thanos.QueryRangeRequest")
	proto.RegisterType((*QueryRangeResponse)(nil), "thanos.QueryRangeResponse")
}

func init() { proto.RegisterFile("api/query/querypb/query.proto", fileDescriptor_4b2aba43925d729f) }

var fileDescriptor_4b2aba43925d729f = []byte{
	// 926 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x56, 0xcf, 0x73, 0xdb, 0x44,
	0x14, 0x96, 0x92, 0xd8, 0xb1, 0x9f, 0xfc, 0x43, 0x59, 0x1c, 0xaa, 0x1a, 0x30, 0xc6, 0x4c, 0x07,
	0x93, 0x01, 0xbb, 0xe3, 0x16, 0x6e, 0xcc, 0x80, 0x49, 0x19, 0xc3, 0x94, 0x99, 0x56, 0xf6, 0x89,
	0x8b, 0x66, 0x6d, 0xbf, 0xd8, 0xc2, 0xf2, 0xae, 0xaa, 0x5d, 0x41, 0xd3, 0x2b, 0x33, 0x9c, 0xf9,
	0xb3, 0x72, 0xec, 0x91, 0x13, 0x03, 0xc9, 0xa5, 0x17, 0xfe, 0x07, 0x46, 0x2b, 0xc9, 0x96, 0x32,
	0xa1, 0x24, 0xe4, 0xd6, 0x8b, 0xbd, 0xfb, 0x7d, 0xef, 0xd9, 0x6f, 0xbf, 0x7d, 0xef, 0x9b, 0x85,
	0xf7, 0xa8, 0xef, 0xf6, 0x9f, 0x85, 0x18, 0x9c, 0xc6, 0x9f, 0xfe, 0x34, 0xfe, 0xee, 0xf9, 0x01,
	0x97, 0x9c, 0x14, 0xe5, 0x92, 0x32, 0x2e, 0x9a, 0x8d, 0x05, 0x5f, 0x70, 0x05, 0xf5, 0xa3, 0x55,
	0xcc, 0x36, 0xef, 0x0a, 0xc9, 0x03, 0xec, 0xab, 0x4f, 0x7f, 0xda, 0x97, 0xa7, 0x3e, 0x8a, 0x84,
	0xba, 0x93, 0xa7, 0x02, 0x7f, 0x96, 0x10, 0xed, 0x3c, 0xe1, 0x07, 0x7c, 0x9d, 0x4f, 0xed, 0x4c,
	0x00, 0x9e, 0x46, 0x25, 0x8c, 0x25, 0x95, 0x82, 0x7c, 0x08, 0x55, 0x41, 0xd7, 0xbe, 0x87, 0xc2,
	0x91, 0x5c, 0x52, 0xcf, 0xd2, 0xdb, 0x7a, 0x77, 0xd7, 0xae, 0x24, 0xe0, 0x24, 0xc2, 0xc8, 0x07,
	0x50, 0xf1, 0x91, 0xae, 0x9c, 0x04, 0xb4, 0x76, 0x54, 0x8c, 0x11, 0x61, 0xe3, 0x18, 0xea, 0x7c,
	0x03, 0xf5, 0x89, 0xbb, 0xc6, 0x31, 0x06, 0x2e, 0x8a, 0x21, 0x95, 0xb3, 0x25, 0x79, 0x00, 0x45,
	0xa1, 0xb6, 0x96, 0xde, 0xde, 0xed, 0x1a, 0x83, 0x77, 0xa2, 0x02, 0xd6, 0x28, 0x97, 0x18, 0x0a,
	0x67, 0xc6, 0xfd, 0xd3, 0xde, 0x36, 0xc3, 0x4e, 0x42, 0x3b, 0xbf, 0x14, 0xa0, 0xa2, 0xca, 0xb3,
	0xf1, 0x59, 0x88, 0x42, 0x92, 0x06, 0x14, 0x94, 0x62, 0xaa, 0xb0, 0xb2, 0x1d, 0x6f, 0x48, 0x1f,
	0xca, 0x6a, 0xf1, 0xc4, 0xa3, 0xcc, 0xaa, 0xb5, 0xf5, 0xae, 0x31, 0x38, 0xe8, 0xc5, 0x62, 0xf6,
	0x36, 0x84, 0xbd, 0x8d, 0x89, 0x8e, 0x20, 0xdd, 0x35, 0x3a, 0x02, 0x67, 0x9c, 0xcd, 0x37, 0x47,
	0x90, 0xaa, 0x02, 0x05, 0x91, 0x8f, 0xa0, 0x1e, 0x6d, 0x79, 0x28, 0x37, 0x51, 0xbb, 0x2a, 0xaa,
	0x96, 0xc0, 0x69, 0xe0, 0x43, 0x78, 0x7b, 0x4d, 0x9f, 0x3b, 0x01, 0x0a, 0xee, 0x85, 0xd2, 0xe5,
	0x6c, 0x13, 0xbf, 0xa7, 0xe2, 0x1b, 0x6b, 0xfa, 0xdc, 0xde, 0x90, 0x69, 0xd6, 0x3d, 0xa8, 0x05,
	0xe8, 0x7b, 0xee, 0x8c, 0x3a, 0x1e, 0x9d, 0xa2, 0x27, 0xac, 0x42, 0x7b, 0xb7, 0x5b, 0xb6, 0xab,
	0x09, 0xfa, 0x58, 0x81, 0xe4, 0x2b, 0xa8, 0xaa, 0xcb, 0xfb, 0x3e, 0xd2, 0x10, 0x03, 0x61, 0x15,
	0x95, 0x78, 0x87, 0xe9, 0xe9, 0xc6, 0x59, 0x72, 0xb8, 0x77, 0xf6, 0xc7, 0xfb, 0x9a, 0x9d, 0xcf,
	0x20, 0x6d, 0x30, 0x90, 0xd1, 0xa9, 0x87, 0xc7, 0x38, 0x0f, 0x7d, 0x6b, 0xbf, 0xad, 0x77, 0x4b,
	0x76, 0x16, 0x22, 0x0f, 0xe1, 0x30, 0xde, 0x3e, 0xa1, 0x81, 0x74, 0xa9, 0x67, 0xa3, 0xf0, 0x39,
	0x13, 0x68, 0x95, 0x54, 0xec, 0xd5, 0x24, 0x69, 0x01, 0x88, 0x95, 0xeb, 0x7f, 0xbd, 0x0c, 0xd9,
	0x4a, 0x58, 0xa0, 0x42, 0x33, 0x08, 0xb9, 0x0f, 0x20, 0x96, 0x34, 0x98, 0x3b, 0x2e, 0x3b, 0xe1,
	0x96, 0x91, 0xbf, 0x95, 0x71, 0xc4, 0x7c, 0xcb, 0x4e, 0xb8, 0x5d, 0x16, 0xe9, 0x32, 0x52, 0xd2,
	0xe3, 0x7c, 0x35, 0xa5, 0xb3, 0x95, 0x33, 0x47, 0x4f, 0xd2, 0x8d, 0x92, 0x95, 0x58, 0xc9, 0x94,
	0x3d, 0x8e, 0xc8, 0x54, 0xc9, 0x23, 0x28, 0x22, 0x5b, 0xb8, 0x0c, 0xad, 0x6a, 0x5b, 0xef, 0xd6,
	0x06, 0x24, 0xfd, 0x8f, 0x47, 0x0a, 0x9d, 0x9c, 0xfa, 0x68, 0x27, 0x11, 0xa4, 0x07, 0x6f, 0x05,
	0x49, 0xfd, 0xce, 0x34, 0x12, 0xc8, 0x11, 0xee, 0x0b, 0xb4, 0xea, 0xea, 0xe7, 0x0f, 0x52, 0x4a,
	0x35, 0xec, 0xd8, 0x7d, 0x81, 0xdf, 0xed, 0x95, 0xca, 0x26, 0x74, 0x9e, 0x42, 0x35, 0xa7, 0x33,
	0xf9, 0x12, 0xaa, 0xea, 0xd2, 0x36, 0xb7, 0x12, 0xb7, 0x74, 0x23, 0xfd, 0xe7, 0xc7, 0x19, 0x32,
	0xbd, 0x94, 0x5c, 0x42, 0xe7, 0x95, 0x0e, 0xd5, 0xa4, 0xb1, 0x13, 0x39, 0xdf, 0x85, 0xd2, 0xcf,
	0x34, 0x60, 0x2e, 0x5b, 0x88, 0xb8, 0xb9, 0x47, 0x9a, 0xbd, 0x41, 0xc8, 0x17, 0x00, 0x51, 0xdb,
	0x25, 0x13, 0xb4, 0xa3, 0xc4, 0x7c, 0xdd, 0x04, 0x8d, 0x34, 0x3b, 0x93, 0x40, 0x8e, 0xa0, 0x20,
	0xa2, 0x01, 0x57, 0x2d, 0x6c, 0x6c, 0x25, 0xda, 0x8e, 0xfe, 0x48, 0xb3, 0xe3, 0x10, 0x72, 0x0c,
	0xe6, 0x36, 0x33, 0x56, 0x49, 0x75, 0xb2, 0x31, 0xb8, 0x93, 0xa6, 0x5d, 0x9a, 0xed, 0x91, 0x66,
	0xd7, 0xb7, 0x29, 0x0a, 0x1a, 0x96, 0xa0, 0x18, 0xa0, 0x08, 0x3d, 0xd9, 0xf9, 0x34, 0x33, 0x9c,
	0xa4, 0x01, 0x7b, 0x3f, 0x0a, 0xce, 0xd4, 0x09, 0x2b, 0x23, 0xcd, 0x56, 0xbb, 0x21, 0x40, 0x09,
	0xd9, 0x8c, 0xcf, 0x5d, 0xb6, 0xe8, 0xbc, 0x2a, 0xc0, 0x41, 0xac, 0x0c, 0x65, 0x0b, 0xbc, 0xc1,
	0xdc, 0x9b, 0xd7, 0x98, 0xfb, 0x4f, 0x80, 0x08, 0x49, 0x03, 0xe9, 0x5c, 0x31, 0xfd, 0xa6, 0x62,
	0x26, 0x19, 0x0b, 0xe8, 0x82, 0x89, 0x6c, 0x9e, 0x8f, 0x4d, 0x3c, 0x00, 0xd9, 0x3c, 0x1b, 0xf9,
	0x31, 0x98, 0x2e, 0x93, 0x18, 0xfc, 0x44, 0xbd, 0x4b, 0xd3, 0x5f, 0x4f, 0xf1, 0xd7, 0xf8, 0x4a,
	0xe1, 0x86, 0xbe, 0x52, 0xbc, 0x91, 0xaf, 0xec, 0x5f, 0xcb, 0x57, 0x4a, 0xb7, 0xf5, 0x95, 0xf2,
	0x0d, 0x7c, 0x05, 0xae, 0xef, 0x2b, 0x95, 0xff, 0xf0, 0x95, 0xea, 0xad, 0x7c, 0xa5, 0x76, 0x2d,
	0x5f, 0xa9, 0xff, 0x5f, 0x5f, 0x39, 0xf8, 0x77, 0x5f, 0x31, 0xcc, 0x4a, 0xe7, 0x6f, 0x1d, 0x48,
	0xb6, 0xd5, 0xdf, 0x70, 0x27, 0x38, 0xfa, 0x0c, 0x60, 0xab, 0x1d, 0x31, 0x60, 0x7f, 0x8e, 0x27,
	0x34, 0xf4, 0xa4, 0xa9, 0x91, 0x1a, 0xc0, 0xf6, 0x08, 0xa6, 0x4e, 0x00, 0x92, 0xc7, 0x90, 0xb9,
	0x33, 0xf8, 0x55, 0x87, 0x82, 0x2a, 0x8f, 0x7c, 0x9e, 0x2e, 0x1a, 0xb9, 0xb2, 0x13, 0x93, 0x68,
	0x1e, 0x5e, 0x42, 0x63, 0x3d, 0xef, 0xeb, 0xe4, 0x51, 0xf2, 0xc8, 0x51, 0x3a, 0x93, 0xbb, 0xf9,
	0xb0, 0x8c, 0xcd, 0x34, 0x9b, 0x57, 0x51, 0xe9, 0xcf, 0x0c, 0xef, 0x9d, 0xfd, 0xd5, 0xd2, 0xce,
	0xce, 0x5b, 0xfa, 0xcb, 0xf3, 0x96, 0xfe, 0xe7, 0x79, 0x4b, 0xff, 0xed, 0xa2, 0xa5, 0xbd, 0xbc,
	0x68, 0x69, 0xbf, 0x5f, 0xb4, 0xb4, 0x1f, 0xf6, 0x93, 0x27, 0xdd, 0xb4, 0xa8, 0x5e, 0x56, 0x0f,
	0xfe, 0x09, 0x00, 0x00, 0xff, 0xff, 0x8a, 0xdd, 0xe8, 0xcf, 0xee, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
	Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (Query_QueryClient, error)
	QueryRange(ctx context.Context, in *QueryRangeRequest, opts ...grpc.CallOption) (Query_QueryRangeClient, error)
}

type queryClient struct {
	cc *grpc.ClientConn
}

func NewQueryClient(cc *grpc.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (Query_QueryClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Query_serviceDesc.Streams[0], "/thanos.Query/Query", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryQueryClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Query_QueryClient interface {
	Recv() (*QueryResponse, error)
	grpc.ClientStream
}

type queryQueryClient struct {
	grpc.ClientStream
}

func (x *queryQueryClient) Recv() (*QueryResponse, error) {
	m := new(QueryResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryClient) QueryRange(ctx context.Context, in *QueryRangeRequest, opts ...grpc.CallOption) (Query_QueryRangeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Query_serviceDesc.Streams[1], "/thanos.Query/QueryRange", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryQueryRangeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Query_QueryRangeClient interface {
	Recv() (*QueryRangeResponse, error)
	grpc.ClientStream
}

type queryQueryRangeClient struct {
	grpc.ClientStream
}

func (x *queryQueryRangeClient) Recv() (*QueryRangeResponse, error) {
	m := new(QueryRangeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// QueryServer is the server API for Query service.
type QueryServer interface {
	Query(*QueryRequest, Query_QueryServer) error
	QueryRange(*QueryRangeRequest, Query_QueryRangeServer) error
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) Query(req *QueryRequest, srv Query_QueryServer) error {
	return status.Errorf(codes.Unimplemented, "method Query not implemented")
}
func (*UnimplementedQueryServer) QueryRange(req *QueryRangeRequest, srv Query_QueryRangeServer) error {
	return status.Errorf(codes.Unimplemented, "method QueryRange not implemented")
}

func RegisterQueryServer(s *grpc.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_Query_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(QueryRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServer).Query(m, &queryQueryServer{stream})
}

type Query_QueryServer interface {
	Send(*QueryResponse) error
	grpc.ServerStream
}

type queryQueryServer struct {
	grpc.ServerStream
}

func (x *queryQueryServer) Send(m *QueryResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Query_QueryRange_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(QueryRangeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServer).QueryRange(m, &queryQueryRangeServer{stream})
}

type Query_QueryRangeServer interface {
	Send(*QueryRangeResponse) error
	grpc.ServerStream
}

type queryQueryRangeServer struct {
	grpc.ServerStream
}

func (x *queryQueryRangeServer) Send(m *QueryRangeResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "thanos.Query",
	HandlerType: (*QueryServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Query",
			Handler:       _Query_Query_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "QueryRange",
			Handler:       _Query_QueryRange_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/query/querypb/query.proto",
}

func (m *QueryStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PeakSamples != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.PeakSamples))
		i--
		dAtA[i] = 0x10
	}
	if m.SamplesTotal != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.SamplesTotal))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TimeSeriesBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeSeriesBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimeSeriesBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Series) > 0 {
		for iNdEx := len(m.Series) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Series[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResponseBatchSize != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.ResponseBatchSize))
		i--
		dAtA[i] = 0x78
	}
	if m.QueryPlan != nil {
		{
			size, err := m.QueryPlan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.Engine != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Engine))
		i--
		dAtA[i] = 0x68
	}
	if m.LookbackDeltaSeconds != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.LookbackDeltaSeconds))
		i--
		dAtA[i] = 0x60
	}
	if m.ShardInfo != nil {
		{
			size, err := m.ShardInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.SkipChunks {
		i--
		if m.SkipChunks {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.EnablePartialResponse {
		i--
		if m.EnablePartialResponse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.EnableDedup {
		i--
		if m.EnableDedup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.StoreMatchers) > 0 {
		for iNdEx := len(m.StoreMatchers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StoreMatchers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.ReplicaLabels) > 0 {
		for iNdEx := len(m.ReplicaLabels) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ReplicaLabels[iNdEx])
			copy(dAtA[i:], m.ReplicaLabels[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.ReplicaLabels[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.MaxResolutionSeconds != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.MaxResolutionSeconds))
		i--
		dAtA[i] = 0x20
	}
	if m.TimeoutSeconds != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.TimeoutSeconds))
		i--
		dAtA[i] = 0x18
	}
	if m.TimeSeconds != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.TimeSeconds))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StoreMatchers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreMatchers) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreMatchers) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LabelMatchers) > 0 {
		for iNdEx := len(m.LabelMatchers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LabelMatchers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		{
			size := m.Result.Size()
			i -= size
			if _, err := m.Result.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryResponse_Warnings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResponse_Warnings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Warnings)
	copy(dAtA[i:], m.Warnings)
	i = encodeVarintQuery(dAtA, i, uint64(len(m.Warnings)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *QueryResponse_Timeseries) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResponse_Timeseries) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Timeseries != nil {
		{
			size, err := m.Timeseries.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *QueryResponse_Stats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResponse_Stats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *QueryResponse_TimeseriesBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResponse_TimeseriesBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TimeseriesBatch != nil {
		{
			size, err := m.TimeseriesBatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *QueryPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Encoding != nil {
		{
			size := m.Encoding.Size()
			i -= size
			if _, err := m.Encoding.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryPlan_Json) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryPlan_Json) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Json != nil {
		i -= len(m.Json)
		copy(dAtA[i:], m.Json)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Json)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *QueryRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResponseBatchSize != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.ResponseBatchSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.QueryPlan != nil {
		{
			size, err := m.QueryPlan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Engine != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Engine))
		i--
		dAtA[i] = 0x78
	}
	if m.LookbackDeltaSeconds != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.LookbackDeltaSeconds))
		i--
		dAtA[i] = 0x70
	}
	if m.ShardInfo != nil {
		{
			size, err := m.ShardInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.SkipChunks {
		i--
		if m.SkipChunks {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.EnablePartialResponse {
		i--
		if m.EnablePartialResponse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.EnableDedup {
		i--
		if m.EnableDedup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.StoreMatchers) > 0 {
		for iNdEx := len(m.StoreMatchers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StoreMatchers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ReplicaLabels) > 0 {
		for iNdEx := len(m.ReplicaLabels) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ReplicaLabels[iNdEx])
			copy(dAtA[i:], m.ReplicaLabels[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.ReplicaLabels[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.MaxResolutionSeconds != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.MaxResolutionSeconds))
		i--
		dAtA[i] = 0x30
	}
	if m.TimeoutSeconds != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.TimeoutSeconds))
		i--
		dAtA[i] = 0x28
	}
	if m.IntervalSeconds != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.IntervalSeconds))
		i--
		dAtA[i] = 0x20
	}
	if m.EndTimeSeconds != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.EndTimeSeconds))
		i--
		dAtA[i] = 0x18
	}
	if m.StartTimeSeconds != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.StartTimeSeconds))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryRangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		{
			size := m.Result.Size()
			i -= size
			if _, err := m.Result.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryRangeResponse_Warnings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRangeResponse_Warnings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Warnings)
	copy(dAtA[i:], m.Warnings)
	i = encodeVarintQuery(dAtA, i, uint64(len(m.Warnings)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *QueryRangeResponse_Timeseries) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRangeResponse_Timeseries) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Timeseries != nil {
		{
			size, err := m.Timeseries.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *QueryRangeResponse_Stats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRangeResponse_Stats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *QueryRangeResponse_TimeseriesBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRangeResponse_TimeseriesBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TimeseriesBatch != nil {
		{
			size, err := m.TimeseriesBatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func encodeVarintQuery(dAtA []byte, offset int, v uint64) int {
	offset -= sovQuery(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *QueryStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SamplesTotal != 0 {
		n += 1 + sovQuery(uint64(m.SamplesTotal))
	}
	if m.PeakSamples != 0 {
		n += 1 + sovQuery(uint64(m.PeakSamples))
	}
	return n
}

func (m *TimeSeriesBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Series) > 0 {
		for _, e := range m.Series {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.TimeSeconds != 0 {
		n += 1 + sovQuery(uint64(m.TimeSeconds))
	}
	if m.TimeoutSeconds != 0 {
		n += 1 + sovQuery(uint64(m.TimeoutSeconds))
	}
	if m.MaxResolutionSeconds != 0 {
		n += 1 + sovQuery(uint64(m.MaxResolutionSeconds))
	}
	if len(m.ReplicaLabels) > 0 {
		for _, s := range m.ReplicaLabels {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.StoreMatchers) > 0 {
		for _, e := range m.StoreMatchers {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.EnableDedup {
		n += 2
	}
	if m.EnablePartialResponse {
		n += 2
	}
	if m.SkipChunks {
		n += 2
	}
	if m.ShardInfo != nil {
		l = m.ShardInfo.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.LookbackDeltaSeconds != 0 {
		n += 1 + sovQuery(uint64(m.LookbackDeltaSeconds))
	}
	if m.Engine != 0 {
		n += 1 + sovQuery(uint64(m.Engine))
	}
	if m.QueryPlan != nil {
		l = m.QueryPlan.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.ResponseBatchSize != 0 {
		n += 1 + sovQuery(uint64(m.ResponseBatchSize))
	}
	return n
}

func (m *StoreMatchers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LabelMatchers) > 0 {
		for _, e := range m.LabelMatchers {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		n += m.Result.Size()
	}
	return n
}

func (m *QueryResponse_Warnings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Warnings)
	n += 1 + l + sovQuery(uint64(l))
	return n
}
func (m *QueryResponse_Timeseries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timeseries != nil {
		l = m.Timeseries.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}
func (m *QueryResponse_Stats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}
func (m *QueryResponse_TimeseriesBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TimeseriesBatch != nil {
		l = m.TimeseriesBatch.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}
func (m *QueryPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Encoding != nil {
		n += m.Encoding.Size()
	}
	return n
}

func (m *QueryPlan_Json) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Json != nil {
		l = len(m.Json)
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}
func (m *QueryRangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.StartTimeSeconds != 0 {
		n += 1 + sovQuery(uint64(m.StartTimeSeconds))
	}
	if m.EndTimeSeconds != 0 {
		n += 1 + sovQuery(uint64(m.EndTimeSeconds))
	}
	if m.IntervalSeconds != 0 {
		n += 1 + sovQuery(uint64(m.IntervalSeconds))
	}
	if m.TimeoutSeconds != 0 {
		n += 1 + sovQuery(uint64(m.TimeoutSeconds))
	}
	if m.MaxResolutionSeconds != 0 {
		n += 1 + sovQuery(uint64(m.MaxResolutionSeconds))
	}
	if len(m.ReplicaLabels) > 0 {
		for _, s := range m.ReplicaLabels {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.StoreMatchers) > 0 {
		for _, e := range m.StoreMatchers {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.EnableDedup {
		n += 2
	}
	if m.EnablePartialResponse {
		n += 2
	}
	if m.SkipChunks {
		n += 2
	}
	if m.ShardInfo != nil {
		l = m.ShardInfo.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.LookbackDeltaSeconds != 0 {
		n += 1 + sovQuery(uint64(m.LookbackDeltaSeconds))
	}
	if m.Engine != 0 {
		n += 1 + sovQuery(uint64(m.Engine))
	}
	if m.QueryPlan != nil {
		l = m.QueryPlan.Size()
		n += 2 + l + sovQuery(uint64(l))
	}
	if m.ResponseBatchSize != 0 {
		n += 2 + sovQuery(uint64(m.ResponseBatchSize))
	}
	return n
}

func (m *QueryRangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		n += m.Result.Size()
	}
	return n
}

func (m *QueryRangeResponse_Warnings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Warnings)
	n += 1 + l + sovQuery(uint64(l))
	return n
}
func (m *QueryRangeResponse_Timeseries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timeseries != nil {
		l = m.Timeseries.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}
func (m *QueryRangeResponse_Stats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}
func (m *QueryRangeResponse_TimeseriesBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TimeseriesBatch != nil {
		l = m.TimeseriesBatch.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func sovQuery(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQuery(x uint64) (n int) {
	return sovQuery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QueryStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SamplesTotal", wireType)
			}
			m.SamplesTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SamplesTotal |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeakSamples", wireType)
			}
			m.PeakSamples = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeakSamples |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeSeriesBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeSeriesBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeSeriesBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Series", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Series = append(m.Series, &prompb.TimeSeries{})
			if err := m.Series[len(m.Series)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeSeconds", wireType)
			}
			m.TimeSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutSeconds", wireType)
			}
			m.TimeoutSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxResolutionSeconds", wireType)
			}
			m.MaxResolutionSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxResolutionSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaLabels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplicaLabels = append(m.ReplicaLabels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreMatchers = append(m.StoreMatchers, StoreMatchers{})
			if err := m.StoreMatchers[len(m.StoreMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableDedup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableDedup = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnablePartialResponse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnablePartialResponse = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipChunks", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipChunks = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardInfo == nil {
				m.ShardInfo = &storepb.ShardInfo{}
			}
			if err := m.ShardInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LookbackDeltaSeconds", wireType)
			}
			m.LookbackDeltaSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LookbackDeltaSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Engine", wireType)
			}
			m.Engine = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Engine |= EngineType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryPlan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QueryPlan == nil {
				m.QueryPlan = &QueryPlan{}
			}
			if err := m.QueryPlan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseBatchSize", wireType)
			}
			m.ResponseBatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseBatchSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreMatchers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreMatchers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreMatchers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LabelMatchers = append(m.LabelMatchers, storepb.LabelMatcher{})
			if err := m.LabelMatchers[len(m.LabelMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Warnings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = &QueryResponse_Warnings{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeseries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &prompb.TimeSeries{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &QueryResponse_Timeseries{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QueryStats{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &QueryResponse_Stats{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeseriesBatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TimeSeriesBatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &QueryResponse_TimeseriesBatch{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: queryPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: queryPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Json", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Encoding = &QueryPlan_Json{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimeSeconds", wireType)
			}
			m.StartTimeSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimeSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTimeSeconds", wireType)
			}
			m.EndTimeSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTimeSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalSeconds", wireType)
			}
			m.IntervalSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntervalSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutSeconds", wireType)
			}
			m.TimeoutSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxResolutionSeconds", wireType)
			}
			m.MaxResolutionSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxResolutionSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaLabels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplicaLabels = append(m.ReplicaLabels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreMatchers = append(m.StoreMatchers, StoreMatchers{})
			if err := m.StoreMatchers[len(m.StoreMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableDedup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableDedup = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnablePartialResponse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnablePartialResponse = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipChunks", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipChunks = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardInfo == nil {
				m.ShardInfo = &storepb.ShardInfo{}
			}
			if err := m.ShardInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LookbackDeltaSeconds", wireType)
			}
			m.LookbackDeltaSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LookbackDeltaSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Engine", wireType)
			}
			m.Engine = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Engine |= EngineType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryPlan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QueryPlan == nil {
				m.QueryPlan = &QueryPlan{}
			}
			if err := m.QueryPlan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseBatchSize", wireType)
			}
			m.ResponseBatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseBatchSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Warnings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = &QueryRangeResponse_Warnings{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeseries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &prompb.TimeSeries{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &QueryRangeResponse_Timeseries{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QueryStats{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &QueryRangeResponse_Stats{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeseriesBatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TimeSeriesBatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &QueryRangeResponse_TimeseriesBatch{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQuery
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQuery
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQuery
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
